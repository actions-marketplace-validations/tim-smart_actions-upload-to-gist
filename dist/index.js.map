{"version":3,"file":"index.js","mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/GA;;;;;;;;ACAA;;;;;;;ACAA;;;;;;;ACAA;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChxBA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC75BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1VA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACh9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5jCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACzPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpyBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClIA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/pCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3sBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChJA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/+BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChCA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACptBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3VA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChHA;AACA;AACA;AACA;AACA;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3cA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3aA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxvGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACzJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["../webpack://actions-upload-to-gist/./node_modules/.pnpm/dotenv@16.0.3/node_modules/dotenv/lib/main.js","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@vercel+ncc@0.36.1/node_modules/@vercel/ncc/dist/ncc/@@notfound.js","../webpack://actions-upload-to-gist/external node-commonjs \"fs\"","../webpack://actions-upload-to-gist/external node-commonjs \"os\"","../webpack://actions-upload-to-gist/external node-commonjs \"path\"","../webpack://actions-upload-to-gist/webpack/bootstrap","../webpack://actions-upload-to-gist/webpack/runtime/compat","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/debug.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/Debug.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/opCodes/configError.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+core@0.1.1/node_modules/@fp-ts/core/mjs/Function.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+core@0.1.1/node_modules/@fp-ts/core/mjs/internal/effect.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+core@0.1.1/node_modules/@fp-ts/core/mjs/internal/Option.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+core@0.1.1/node_modules/@fp-ts/core/mjs/internal/Either.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+core@0.1.1/node_modules/@fp-ts/core/mjs/typeclass/Covariant.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+core@0.1.1/node_modules/@fp-ts/core/mjs/typeclass/Traversable.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+core@0.1.1/node_modules/@fp-ts/core/mjs/Either.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+core@0.1.1/node_modules/@fp-ts/core/mjs/internal/ReadonlyArray.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+core@0.1.1/node_modules/@fp-ts/core/mjs/typeclass/Compactable.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+core@0.1.1/node_modules/@fp-ts/core/mjs/typeclass/FlatMap.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+core@0.1.1/node_modules/@fp-ts/core/mjs/Option.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+core@0.1.1/node_modules/@fp-ts/core/mjs/typeclass/Contravariant.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+core@0.1.1/node_modules/@fp-ts/core/mjs/Predicate.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+core@0.1.1/node_modules/@fp-ts/core/mjs/typeclass/Equivalence.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+core@0.1.1/node_modules/@fp-ts/core/mjs/typeclass/Semigroup.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+core@0.1.1/node_modules/@fp-ts/core/mjs/typeclass/Monoid.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+core@0.1.1/node_modules/@fp-ts/core/mjs/typeclass/Order.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+core@0.1.1/node_modules/@fp-ts/core/mjs/String.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+core@0.1.1/node_modules/@fp-ts/core/mjs/typeclass/SemiProduct.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+core@0.1.1/node_modules/@fp-ts/core/mjs/typeclass/TraversableFilterable.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+core@0.1.1/node_modules/@fp-ts/core/mjs/ReadonlyArray.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+data@0.1.1/node_modules/@fp-ts/data/mjs/Dual.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+data@0.1.1/node_modules/@fp-ts/data/mjs/internal/Equal.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+data@0.1.1/node_modules/@fp-ts/data/mjs/Random.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+data@0.1.1/node_modules/@fp-ts/data/mjs/Hash.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+data@0.1.1/node_modules/@fp-ts/data/mjs/Equal.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+data@0.1.1/node_modules/@fp-ts/data/mjs/Chunk.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/configError.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/Config/Error.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/configSecret.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/opCodes/config.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+data@0.1.1/node_modules/@fp-ts/data/mjs/internal/HashMap/config.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+data@0.1.1/node_modules/@fp-ts/data/mjs/internal/HashMap/bitwise.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+data@0.1.1/node_modules/@fp-ts/data/mjs/internal/HashMap/array.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+data@0.1.1/node_modules/@fp-ts/data/mjs/internal/Stack.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+data@0.1.1/node_modules/@fp-ts/data/mjs/internal/HashMap/node.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+data@0.1.1/node_modules/@fp-ts/data/mjs/internal/HashMap.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+data@0.1.1/node_modules/@fp-ts/data/mjs/internal/HashSet.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+data@0.1.1/node_modules/@fp-ts/data/mjs/HashSet.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/config.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/Config.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+data@0.1.1/node_modules/@fp-ts/data/mjs/MutableRef.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/fiberId.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/Fiber/Id.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/opCodes/cause.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/cause.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/runtimeFlagsPatch.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+data@0.1.1/node_modules/@fp-ts/data/mjs/internal/Differ/ChunkPatch.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+data@0.1.1/node_modules/@fp-ts/data/mjs/Differ/ChunkPatch.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+data@0.1.1/node_modules/@fp-ts/data/mjs/internal/Context.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+data@0.1.1/node_modules/@fp-ts/data/mjs/internal/Differ/ContextPatch.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+data@0.1.1/node_modules/@fp-ts/data/mjs/Differ/ContextPatch.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+data@0.1.1/node_modules/@fp-ts/data/mjs/internal/HashMap/keySet.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+data@0.1.1/node_modules/@fp-ts/data/mjs/HashMap.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+data@0.1.1/node_modules/@fp-ts/data/mjs/internal/Differ/HashMapPatch.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+data@0.1.1/node_modules/@fp-ts/data/mjs/Differ/HashMapPatch.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+data@0.1.1/node_modules/@fp-ts/data/mjs/internal/Differ/HashSetPatch.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+data@0.1.1/node_modules/@fp-ts/data/mjs/Differ/HashSetPatch.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+data@0.1.1/node_modules/@fp-ts/data/mjs/internal/Differ/OrPatch.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+data@0.1.1/node_modules/@fp-ts/data/mjs/Differ/OrPatch.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+data@0.1.1/node_modules/@fp-ts/data/mjs/internal/Differ.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+data@0.1.1/node_modules/@fp-ts/data/mjs/Differ.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/runtimeFlags.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/Fiber/Runtime/Flags/Patch.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/opCodes/deferred.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/deferred.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/opCodes/effect.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/scheduler.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+data@0.1.1/node_modules/@fp-ts/data/mjs/Context.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/core.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/cause-pretty.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/Exit.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/executionStrategy.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/ExecutionStrategy.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/clock.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+data@0.1.1/node_modules/@fp-ts/data/mjs/List.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/configProvider/pathPatch.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/string-utils.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/configProvider.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/random.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/defaultServices.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/Clock.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/fiberRefs.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/FiberRefs.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/fiberRefs/patch.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/metric/label.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/singleShotGen.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+core@0.1.1/node_modules/@fp-ts/core/mjs/typeclass/Bounded.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+core@0.1.1/node_modules/@fp-ts/core/mjs/Number.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/Logger/Level.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/logSpan.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/Logger/Span.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/Random.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/ref.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/Ref.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+data@0.1.1/node_modules/@fp-ts/data/mjs/Duration.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/effect.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/fiberStatus.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/Fiber/Status.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/fiberMessage.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/fiberScope.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/fiber.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/Deferred.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/logger.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/main-thread.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/metric/keyType.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/metric/key.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/metric/state.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/metric/hook.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/metric/pair.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+data@0.1.1/node_modules/@fp-ts/data/mjs/MutableHashMap.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/metric/registry.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/metric.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/metric/boundaries.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/supervisor.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/supervisor/patch.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+data@0.1.1/node_modules/@fp-ts/data/mjs/MutableList.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@fp-ts+data@0.1.1/node_modules/@fp-ts/data/mjs/MutableQueue.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/fiberRuntime.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/schedule/interval.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/Schedule/Interval.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/schedule/intervals.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/Schedule/Intervals.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/schedule/decision.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/Schedule/Decision.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/schedule.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/effect/circular.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/Fiber.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/runtime.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/cause-pretty-run.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/Cause.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/opCodes/layer.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/synchronizedRef.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/Scope.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/layer.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/Layer.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/internal_effect_untraced/layer/circular.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/Effect.mjs","../webpack://actions-upload-to-gist/./node_modules/.pnpm/@effect+io@0.1.8/node_modules/@effect/io/mjs/Config/Provider.mjs","../webpack://actions-upload-to-gist/./build/main.js"],"sourcesContent":["const fs = require('fs')\nconst path = require('path')\nconst os = require('os')\nconst packageJson = require('../package.json')\n\nconst version = packageJson.version\n\nconst LINE = /(?:^|^)\\s*(?:export\\s+)?([\\w.-]+)(?:\\s*=\\s*?|:\\s+?)(\\s*'(?:\\\\'|[^'])*'|\\s*\"(?:\\\\\"|[^\"])*\"|\\s*`(?:\\\\`|[^`])*`|[^#\\r\\n]+)?\\s*(?:#.*)?(?:$|$)/mg\n\n// Parser src into an Object\nfunction parse (src) {\n  const obj = {}\n\n  // Convert buffer to string\n  let lines = src.toString()\n\n  // Convert line breaks to same format\n  lines = lines.replace(/\\r\\n?/mg, '\\n')\n\n  let match\n  while ((match = LINE.exec(lines)) != null) {\n    const key = match[1]\n\n    // Default undefined or null to empty string\n    let value = (match[2] || '')\n\n    // Remove whitespace\n    value = value.trim()\n\n    // Check if double quoted\n    const maybeQuote = value[0]\n\n    // Remove surrounding quotes\n    value = value.replace(/^(['\"`])([\\s\\S]*)\\1$/mg, '$2')\n\n    // Expand newlines if double quoted\n    if (maybeQuote === '\"') {\n      value = value.replace(/\\\\n/g, '\\n')\n      value = value.replace(/\\\\r/g, '\\r')\n    }\n\n    // Add to object\n    obj[key] = value\n  }\n\n  return obj\n}\n\nfunction _log (message) {\n  console.log(`[dotenv@${version}][DEBUG] ${message}`)\n}\n\nfunction _resolveHome (envPath) {\n  return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath\n}\n\n// Populates process.env from .env file\nfunction config (options) {\n  let dotenvPath = path.resolve(process.cwd(), '.env')\n  let encoding = 'utf8'\n  const debug = Boolean(options && options.debug)\n  const override = Boolean(options && options.override)\n\n  if (options) {\n    if (options.path != null) {\n      dotenvPath = _resolveHome(options.path)\n    }\n    if (options.encoding != null) {\n      encoding = options.encoding\n    }\n  }\n\n  try {\n    // Specifying an encoding returns a string instead of a buffer\n    const parsed = DotenvModule.parse(fs.readFileSync(dotenvPath, { encoding }))\n\n    Object.keys(parsed).forEach(function (key) {\n      if (!Object.prototype.hasOwnProperty.call(process.env, key)) {\n        process.env[key] = parsed[key]\n      } else {\n        if (override === true) {\n          process.env[key] = parsed[key]\n        }\n\n        if (debug) {\n          if (override === true) {\n            _log(`\"${key}\" is already defined in \\`process.env\\` and WAS overwritten`)\n          } else {\n            _log(`\"${key}\" is already defined in \\`process.env\\` and was NOT overwritten`)\n          }\n        }\n      }\n    })\n\n    return { parsed }\n  } catch (e) {\n    if (debug) {\n      _log(`Failed to load ${dotenvPath} ${e.message}`)\n    }\n\n    return { error: e }\n  }\n}\n\nconst DotenvModule = {\n  config,\n  parse\n}\n\nmodule.exports.config = DotenvModule.config\nmodule.exports.parse = DotenvModule.parse\nmodule.exports = DotenvModule\n",null,"module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(\"fs\");","module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(\"os\");","module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = new URL('.', import.meta.url).pathname.slice(import.meta.url.match(/^file:\\/\\/\\/\\w:/) ? 1 : 0, -1) + \"/\";","/** @internal */\nconst levels = [\"All\", \"Fatal\", \"Error\", \"Warning\", \"Info\", \"Debug\", \"Trace\", \"None\"];\n/** @internal */\nexport const restoreOn = body => function () {\n  if (runtimeDebug.tracingEnabled) {\n    // @ts-expect-error\n    return body.apply(this, arguments);\n  }\n  runtimeDebug.tracingEnabled = true;\n  try {\n    // @ts-expect-error\n    return body.apply(this, arguments);\n  } finally {\n    runtimeDebug.tracingEnabled = false;\n  }\n};\n/** @internal */\nexport const restoreOff = body => function () {\n  if (!runtimeDebug.tracingEnabled) {\n    // @ts-expect-error\n    return body.apply(this, arguments);\n  }\n  runtimeDebug.tracingEnabled = false;\n  try {\n    // @ts-expect-error\n    return body.apply(this, arguments);\n  } finally {\n    runtimeDebug.tracingEnabled = true;\n  }\n};\nconst processEnv = typeof process !== \"undefined\" ? process.env : undefined;\n/** @internal */\nexport const runtimeDebug = {\n  minumumLogLevel: processEnv && processEnv[\"EFFECT_LOG_LEVEL\"] && /*#__PURE__*/levels.includes(processEnv[\"EFFECT_LOG_LEVEL\"]) ? processEnv[\"EFFECT_LOG_LEVEL\"] : \"Info\",\n  traceStackLimit: processEnv && processEnv[\"EFFECT_TRACING_STACK_LIMIT\"] ? /*#__PURE__*/Number.parseInt(processEnv[\"EFFECT_TRACING_STACK_LIMIT\"]) : 5,\n  tracingEnabled: processEnv && processEnv[\"EFFECT_TRACING_ENABLED\"] && processEnv[\"EFFECT_TRACING_ENABLED\"] === \"false\" ? false : true,\n  parseStack: error => {\n    const stack = error.stack;\n    if (stack) {\n      const lines = stack.split(\"\\n\");\n      let starts = 0;\n      for (let i = 0; i < lines.length; i++) {\n        if (lines[i].startsWith(\"Error\")) {\n          starts = i;\n        }\n      }\n      const frames = [];\n      for (let i = starts + 1; i < lines.length; i++) {\n        if (lines[i].includes(\"at\")) {\n          const blocks = lines[i].split(\" \").filter(i => i.length > 0 && i !== \"at\");\n          const name = blocks.length === 2 && !blocks[0].includes(\"<anonymous>\") ? blocks[0] : undefined;\n          const file = blocks.length === 2 ? blocks[1] : blocks[0];\n          const matchFrame = file?.match(/\\(?(.*):(\\d+):(\\d+)/);\n          if (matchFrame) {\n            frames.push({\n              name,\n              fileName: matchFrame[1],\n              line: Number.parseInt(matchFrame[2]),\n              column: Number.parseInt(matchFrame[3])\n            });\n          } else {\n            frames.push(undefined);\n          }\n        } else {\n          frames.push(undefined);\n        }\n      }\n      return frames;\n    }\n    return [];\n  },\n  filterStackFrame: _ => _ != null && !_.fileName.match(/\\/internal_effect_untraced/)\n};\n//# sourceMappingURL=debug.mjs.map","/**\n * @since 1.0.0\n */\nimport * as debug from \"@effect/io/internal_effect_untraced/debug\";\n/**\n * @since 1.0.0\n * @category debug\n */\nexport const runtimeDebug = debug.runtimeDebug;\nconst sourceLocationProto = /*#__PURE__*/Object.setPrototypeOf({\n  toFrame() {\n    if (\"parsed\" in this) {\n      return this.parsed;\n    }\n    const stack = runtimeDebug.parseStack(this);\n    if (stack && stack.length >= 2 && stack[0] && stack[1]) {\n      this.parsed = {\n        ...stack[this.depth - 1],\n        name: stack[this.depth - 2]?.name\n      };\n    } else {\n      this.parsed = undefined;\n    }\n    return this.parsed;\n  }\n}, Error.prototype);\n/**\n * @since 1.0.0\n */\nexport const sourceLocation = error => {\n  ;\n  error.depth = Error.stackTraceLimit;\n  Object.setPrototypeOf(error, sourceLocationProto);\n  return error;\n};\n/**\n * @since 1.0.0\n */\nexport const bodyWithTrace = body => {\n  if (!runtimeDebug.tracingEnabled) {\n    return body(void 0, debug.restoreOff);\n  }\n  runtimeDebug.tracingEnabled = false;\n  try {\n    const limit = Error.stackTraceLimit;\n    Error.stackTraceLimit = 3;\n    const source = sourceLocation(new Error());\n    Error.stackTraceLimit = limit;\n    return body(source, debug.restoreOn);\n  } finally {\n    runtimeDebug.tracingEnabled = true;\n  }\n};\n/**\n * @since 1.0.0\n */\nexport const methodWithTrace = body => {\n  // @ts-expect-error\n  return function () {\n    if (!runtimeDebug.tracingEnabled) {\n      // @ts-expect-error\n      return body(void 0, debug.restoreOff).apply(this, arguments);\n    }\n    runtimeDebug.tracingEnabled = false;\n    try {\n      const limit = Error.stackTraceLimit;\n      Error.stackTraceLimit = 2;\n      const error = sourceLocation(new Error());\n      Error.stackTraceLimit = limit;\n      // @ts-expect-error\n      return body(error, debug.restoreOn).apply(this, arguments);\n    } finally {\n      runtimeDebug.tracingEnabled = true;\n    }\n  };\n};\n/**\n * @since 1.0.0\n */\nexport const pipeableWithTrace = body => {\n  // @ts-expect-error\n  return function () {\n    if (!runtimeDebug.tracingEnabled) {\n      const a = body(void 0, debug.restoreOff);\n      // @ts-expect-error\n      return self => untraced(() => a.apply(this, arguments)(self));\n    }\n    runtimeDebug.tracingEnabled = false;\n    try {\n      const limit = Error.stackTraceLimit;\n      Error.stackTraceLimit = 2;\n      const source = sourceLocation(new Error());\n      Error.stackTraceLimit = limit;\n      const f = body(source, debug.restoreOn);\n      // @ts-expect-error\n      return self => untraced(() => f.apply(this, arguments)(self));\n    } finally {\n      runtimeDebug.tracingEnabled = true;\n    }\n  };\n};\n/**\n * @since 1.0.0\n */\nexport const dual = (dfLen, body) => {\n  // @ts-expect-error\n  return function () {\n    if (arguments.length === dfLen) {\n      // @ts-expect-error\n      return body.apply(this, arguments);\n    }\n    return self => body(self, ...arguments);\n  };\n};\n/**\n * @since 1.0.0\n */\nexport const dualWithTrace = (dfLen, body) => {\n  // @ts-expect-error\n  return function () {\n    if (!runtimeDebug.tracingEnabled) {\n      const f = body(void 0, debug.restoreOff);\n      if (arguments.length === dfLen) {\n        // @ts-expect-error\n        return untraced(() => f.apply(this, arguments));\n      }\n      return self => untraced(() => f(self, ...arguments));\n    }\n    runtimeDebug.tracingEnabled = false;\n    try {\n      const limit = Error.stackTraceLimit;\n      Error.stackTraceLimit = 2;\n      const source = sourceLocation(new Error());\n      Error.stackTraceLimit = limit;\n      const f = body(source, debug.restoreOn);\n      if (arguments.length === dfLen) {\n        // @ts-expect-error\n        return untraced(() => f.apply(this, arguments));\n      }\n      return self => untraced(() => f(self, ...arguments));\n    } finally {\n      runtimeDebug.tracingEnabled = true;\n    }\n  };\n};\n/**\n * @since 1.0.0\n */\nexport const untraced = body => {\n  if (!runtimeDebug.tracingEnabled) {\n    return body(debug.restoreOff);\n  }\n  runtimeDebug.tracingEnabled = false;\n  try {\n    return body(debug.restoreOn);\n  } finally {\n    runtimeDebug.tracingEnabled = true;\n  }\n};\n/**\n * @since 1.0.0\n */\nexport const untracedDual = (dfLen, body) => {\n  // @ts-expect-error\n  return function () {\n    if (!runtimeDebug.tracingEnabled) {\n      const f = body(debug.restoreOff);\n      if (arguments.length === dfLen) {\n        // @ts-expect-error\n        return untraced(() => f.apply(this, arguments));\n      }\n      return self => untraced(() => f(self, ...arguments));\n    }\n    runtimeDebug.tracingEnabled = false;\n    try {\n      const f = body(debug.restoreOn);\n      if (arguments.length === dfLen) {\n        // @ts-expect-error\n        return untraced(() => f.apply(this, arguments));\n      }\n      return self => untraced(() => f(self, ...arguments));\n    } finally {\n      runtimeDebug.tracingEnabled = true;\n    }\n  };\n};\n/**\n * @since 1.0.0\n */\nexport const untracedMethod = body => {\n  // @ts-expect-error\n  return function () {\n    if (!runtimeDebug.tracingEnabled) {\n      // @ts-expect-error\n      return untraced(() => body(debug.restoreOff).apply(this, arguments));\n    }\n    runtimeDebug.tracingEnabled = false;\n    try {\n      // @ts-expect-error\n      return untraced(() => body(debug.restoreOn).apply(this, arguments));\n    } finally {\n      runtimeDebug.tracingEnabled = true;\n    }\n  };\n};\n/**\n * @since 1.0.0\n */\nexport const traced = body => {\n  if (runtimeDebug.tracingEnabled) {\n    return body(debug.restoreOn);\n  }\n  runtimeDebug.tracingEnabled = true;\n  try {\n    return body(debug.restoreOff);\n  } finally {\n    runtimeDebug.tracingEnabled = false;\n  }\n};\n//# sourceMappingURL=Debug.mjs.map","/** @internal */\nexport const OP_AND = \"And\";\n/** @internal */\nexport const OP_OR = \"Or\";\n/** @internal */\nexport const OP_INVALID_DATA = \"InvalidData\";\n/** @internal */\nexport const OP_MISSING_DATA = \"MissingData\";\n/** @internal */\nexport const OP_SOURCE_UNAVAILABLE = \"SourceUnavailable\";\n/** @internal */\nexport const OP_UNSUPPORTED = \"Unsupported\";\n//# sourceMappingURL=configError.mjs.map","import * as semigroup from \"@fp-ts/core/typeclass/Semigroup\";\n/**\n * @since 1.0.0\n */\nexport const compose = bc => ab => flow(ab, bc);\n/**\n * Unary functions form a semigroup as long as you can provide a semigroup for the codomain.\n *\n * @example\n * import { Predicate } from '@fp-ts/core/Predicate'\n * import { pipe, getSemigroup } from '@fp-ts/core/Function'\n * import * as B from '@fp-ts/core/Boolean'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const S1 = getSemigroup(B.SemigroupAll)<number>()\n *\n * assert.deepStrictEqual(S1.combine(f, g)(1), true)\n * assert.deepStrictEqual(S1.combine(f, g)(3), false)\n *\n * const S2 = getSemigroup(B.SemigroupAny)<number>()\n *\n * assert.deepStrictEqual(S2.combine(f, g)(1), true)\n * assert.deepStrictEqual(S2.combine(f, g)(3), true)\n *\n * @category instances\n * @since 1.0.0\n */\nexport const getSemigroup = Semigroup => () => semigroup.fromCombine((self, that) => a => Semigroup.combine(self(a), that(a)));\n/**\n * Unary functions form a monoid as long as you can provide a monoid for the codomain.\n *\n * @example\n * import { Predicate } from '@fp-ts/core/Predicate'\n * import { getMonoid, pipe } from '@fp-ts/core/Function'\n * import * as B from '@fp-ts/core/Boolean'\n *\n * const f: Predicate<number> = (n) => n <= 2\n * const g: Predicate<number> = (n) => n >= 0\n *\n * const M1 = getMonoid(B.MonoidAll)<number>()\n *\n * assert.deepStrictEqual(M1.combine(f, g)(1), true)\n * assert.deepStrictEqual(M1.combine(f, g)(3), false)\n *\n * const M2 = getMonoid(B.MonoidAny)<number>()\n *\n * assert.deepStrictEqual(M2.combine(f, g)(1), true)\n * assert.deepStrictEqual(M2.combine(f, g)(3), true)\n *\n * @category instances\n * @since 1.0.0\n */\nexport const getMonoid = Monoid => () => {\n  const S = getSemigroup(Monoid)();\n  const empty = () => Monoid.empty;\n  return {\n    ...S,\n    combineAll: collection => S.combineMany(empty, collection),\n    empty\n  };\n};\n/**\n * @since 1.0.0\n */\nexport const apply = a => self => self(a);\n/**\n * @since 1.0.0\n */\nexport const identity = a => a;\n/**\n * @since 1.0.0\n */\nexport const unsafeCoerce = identity;\n/**\n * @since 1.0.0\n */\nexport const constant = a => () => a;\n/**\n * A thunk that returns always `true`.\n *\n * @since 1.0.0\n */\nexport const constTrue = /*#__PURE__*/constant(true);\n/**\n * A thunk that returns always `false`.\n *\n * @since 1.0.0\n */\nexport const constFalse = /*#__PURE__*/constant(false);\n/**\n * A thunk that returns always `null`.\n *\n * @since 1.0.0\n */\nexport const constNull = /*#__PURE__*/constant(null);\n/**\n * A thunk that returns always `undefined`.\n *\n * @since 1.0.0\n */\nexport const constUndefined = /*#__PURE__*/constant(undefined);\n/**\n * A thunk that returns always `void`.\n *\n * @since 1.0.0\n */\nexport const constVoid = constUndefined;\n/**\n * Flips the arguments of a curried function.\n *\n * @example\n * import { flip } from '@fp-ts/core/Function'\n *\n * const f = (a: number) => (b: string) => a - b.length\n *\n * assert.strictEqual(flip(f)('aaa')(2), -1)\n *\n * @since 1.0.0\n */\nexport const flip = f => b => a => f(a)(b);\nexport function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {\n  switch (arguments.length) {\n    case 1:\n      return ab;\n    case 2:\n      return function () {\n        return bc(ab.apply(this, arguments));\n      };\n    case 3:\n      return function () {\n        return cd(bc(ab.apply(this, arguments)));\n      };\n    case 4:\n      return function () {\n        return de(cd(bc(ab.apply(this, arguments))));\n      };\n    case 5:\n      return function () {\n        return ef(de(cd(bc(ab.apply(this, arguments)))));\n      };\n    case 6:\n      return function () {\n        return fg(ef(de(cd(bc(ab.apply(this, arguments))))));\n      };\n    case 7:\n      return function () {\n        return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));\n      };\n    case 8:\n      return function () {\n        return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));\n      };\n    case 9:\n      return function () {\n        return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));\n      };\n  }\n  return;\n}\n/**\n * @since 1.0.0\n */\nexport const absurd = _ => {\n  throw new Error(\"Called `absurd` function which should be uncallable\");\n};\n/**\n * Creates a tupled version of this function: instead of `n` arguments, it accepts a single tuple argument.\n *\n * @example\n * import { tupled } from '@fp-ts/core/Function'\n *\n * const add = tupled((x: number, y: number): number => x + y)\n *\n * assert.strictEqual(add([1, 2]), 3)\n *\n * @since 1.0.0\n */\nexport const tupled = f => a => f(...a);\n/**\n * Inverse function of `tupled`\n *\n * @since 1.0.0\n */\nexport const untupled = f => (...a) => f(a);\nexport function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {\n  switch (arguments.length) {\n    case 1:\n      return a;\n    case 2:\n      return ab(a);\n    case 3:\n      return bc(ab(a));\n    case 4:\n      return cd(bc(ab(a)));\n    case 5:\n      return de(cd(bc(ab(a))));\n    case 6:\n      return ef(de(cd(bc(ab(a)))));\n    case 7:\n      return fg(ef(de(cd(bc(ab(a))))));\n    case 8:\n      return gh(fg(ef(de(cd(bc(ab(a)))))));\n    case 9:\n      return hi(gh(fg(ef(de(cd(bc(ab(a))))))));\n    default:\n      {\n        let ret = arguments[0];\n        for (let i = 1; i < arguments.length; i++) {\n          ret = arguments[i](ret);\n        }\n        return ret;\n      }\n  }\n}\n/**\n * Type hole simulation\n *\n * @since 1.0.0\n */\nexport const hole = absurd;\n/**\n * `SK` function (SKI combinator calculus).\n *\n * @since 1.0.0\n */\nexport const SK = (_, b) => b;\n//# sourceMappingURL=Function.mjs.map","/**\n * @since 1.0.0\n */\n/** @internal */\nexport const structural = /*#__PURE__*/Symbol.for(\"@effect/data/Equal/structural\");\n/** @internal */\nexport const proto = /*#__PURE__*/Object.setPrototypeOf({\n  [structural]: true\n}, Object.prototype);\n//# sourceMappingURL=effect.mjs.map","/**\n * @since 1.0.0\n */\nimport { proto, structural } from \"@fp-ts/core/internal/effect\";\n/** @internal */\nexport const isOption = u => typeof u === \"object\" && u != null && structural in u && \"_tag\" in u && (u[\"_tag\"] === \"None\" || u[\"_tag\"] === \"Some\");\n/** @internal */\nexport const isNone = fa => fa._tag === \"None\";\n/** @internal */\nexport const isSome = fa => fa._tag === \"Some\";\n/** @internal */\nexport const none = /*#__PURE__*/Object.setPrototypeOf({\n  _tag: \"None\"\n}, proto);\n/** @internal */\nexport const some = a => Object.setPrototypeOf({\n  _tag: \"Some\",\n  value: a\n}, proto);\n/** @internal */\nexport const fromNullable = a => a == null ? none : some(a);\n//# sourceMappingURL=Option.mjs.map","/**\n * @since 1.0.0\n */\nimport { proto, structural } from \"@fp-ts/core/internal/effect\";\nimport * as option from \"@fp-ts/core/internal/Option\";\n/** @internal */\nexport const isEither = u => typeof u === \"object\" && u != null && structural in u && \"_tag\" in u && (u[\"_tag\"] === \"Left\" || u[\"_tag\"] === \"Right\");\n/** @internal */\nexport const isLeft = ma => ma._tag === \"Left\";\n/** @internal */\nexport const isRight = ma => ma._tag === \"Right\";\n/** @internal */\nexport const left = e => Object.setPrototypeOf({\n  _tag: \"Left\",\n  left: e\n}, proto);\n/** @internal */\nexport const right = a => Object.setPrototypeOf({\n  _tag: \"Right\",\n  right: a\n}, proto);\n/** @internal */\nexport const getLeft = self => isRight(self) ? option.none : option.some(self.left);\n/** @internal */\nexport const getRight = self => isLeft(self) ? option.none : option.some(self.right);\n/** @internal */\nexport const fromNullable = onNullable => a => a == null ? left(onNullable()) : right(a);\n/** @internal */\nexport const fromOption = onNone => fa => option.isNone(fa) ? left(onNone()) : right(fa.value);\n//# sourceMappingURL=Either.mjs.map","/**\n * Returns a default `map` composition.\n *\n * @since 1.0.0\n */\nexport const mapComposition = (F, G) => f => F.map(G.map(f));\n/**\n * Returns a default `imap` implementation.\n *\n * @since 1.0.0\n */\nexport const imap = map => (to, _) => map(to);\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const make = map => ({\n  map,\n  imap: imap(map)\n});\n/**\n * @category mapping\n * @since 1.0.0\n */\nexport const flap = F => a => F.map(f => f(a));\n/**\n * @category mapping\n * @since 1.0.0\n */\nexport const as = F => b => F.map(() => b);\n/**\n * @category mapping\n * @since 1.0.0\n */\nexport const asUnit = F => as(F)(undefined);\nconst let_ = F => (name, f) => F.map(a => Object.assign({}, a, {\n  [name]: f(a)\n}));\nexport {\n/**\n * @since 1.0.0\n */\nlet_ as let };\n//# sourceMappingURL=Covariant.mjs.map","/**\n * @since 1.0.0\n */\nimport { identity, pipe } from \"@fp-ts/core/Function\";\n/**\n * Returns a default `traverse` composition.\n *\n * @since 1.0.0\n */\nexport const traverseComposition = (T, G) => F => f => T.traverse(F)(G.traverse(F)(f));\n/**\n * Returns a default `sequence` composition.\n *\n * @since 1.0.0\n */\nexport const sequenceComposition = (T, G) => F => self => T.sequence(F)(pipe(self, T.map(G.sequence(F))));\n/**\n * Returns a default `sequence` implementation.\n *\n * @since 1.0.0\n */\nexport const sequence = traverse => F => traverse(F)(identity);\n/**\n * Given a function which returns a `F` effect, thread this effect\n * through the running of this function on all the values in `T`,\n * returning an `T<A>` in a `F` context, ignoring the values\n * returned by the provided function.\n *\n * @since 1.0.0\n */\nexport const traverseTap = T => F => f => T.traverse(F)(a => pipe(f(a), F.map(() => a)));\n//# sourceMappingURL=Traversable.mjs.map","import { constNull, constUndefined, identity, pipe } from \"@fp-ts/core/Function\";\nimport * as either from \"@fp-ts/core/internal/Either\";\nimport * as option from \"@fp-ts/core/internal/Option\";\nimport * as applicative from \"@fp-ts/core/typeclass/Applicative\";\nimport * as bicovariant from \"@fp-ts/core/typeclass/Bicovariant\";\nimport * as chainable from \"@fp-ts/core/typeclass/Chainable\";\nimport * as covariant from \"@fp-ts/core/typeclass/Covariant\";\nimport * as flatMap_ from \"@fp-ts/core/typeclass/FlatMap\";\nimport * as invariant from \"@fp-ts/core/typeclass/Invariant\";\nimport * as of_ from \"@fp-ts/core/typeclass/Of\";\nimport * as product_ from \"@fp-ts/core/typeclass/Product\";\nimport * as semiApplicative from \"@fp-ts/core/typeclass/SemiApplicative\";\nimport * as semiCoproduct from \"@fp-ts/core/typeclass/SemiCoproduct\";\nimport * as semiProduct from \"@fp-ts/core/typeclass/SemiProduct\";\nimport * as traversable from \"@fp-ts/core/typeclass/Traversable\";\n/**\n * Constructs a new `Either` holding a `Right` value. This usually represents a successful value due to the right bias\n * of this structure.\n *\n * @category constructors\n * @since 1.0.0\n */\nexport const right = either.right;\n/**\n * Constructs a new `Either` holding a `Left` value. This usually represents a failure, due to the right-bias of this\n * structure.\n *\n * @category constructors\n * @since 1.0.0\n */\nexport const left = either.left;\n/**\n * Alias of `right`.\n *\n * @category constructors\n * @since 1.0.0\n */\nexport const of = right;\n/**\n * Returns `true` if the specified value is an instance of `Either`, `false`\n * otherwise.\n *\n * @category guards\n * @since 1.0.0\n */\nexport const isEither = either.isEither;\n/**\n * Returns `true` if the either is an instance of `Left`, `false` otherwise.\n *\n * @category guards\n * @since 1.0.0\n */\nexport const isLeft = either.isLeft;\n/**\n * Returns `true` if the either is an instance of `Right`, `false` otherwise.\n *\n * @category guards\n * @since 1.0.0\n */\nexport const isRight = either.isRight;\n/**\n * Returns an effect whose Right is mapped by the specified `f` function.\n *\n * @category mapping\n * @since 1.0.0\n */\nexport const map = f => self => isRight(self) ? right(f(self.right)) : self;\n/**\n * @category mapping\n * @since 1.0.0\n */\nexport const imap = /*#__PURE__*/covariant.imap(map);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Invariant = {\n  imap\n};\n/**\n * @category mapping\n * @since 1.0.0\n */\nexport const tupled = /*#__PURE__*/invariant.tupled(Invariant);\n/**\n * @category do notation\n * @since 1.0.0\n */\nexport const bindTo = /*#__PURE__*/invariant.bindTo(Invariant);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Covariant = {\n  ...Invariant,\n  map\n};\n/**\n * @category mapping\n * @since 1.0.0\n */\nexport const flap = /*#__PURE__*/covariant.flap(Covariant);\n/**\n * Maps the Right value of this effect to the specified constant value.\n *\n * @category mapping\n * @since 1.0.0\n */\nexport const as = /*#__PURE__*/covariant.as(Covariant);\n/**\n * Returns the effect Eithering from mapping the Right of this effect to unit.\n *\n * @category mapping\n * @since 1.0.0\n */\nexport const asUnit = /*#__PURE__*/covariant.asUnit(Covariant);\nconst let_ = /*#__PURE__*/covariant.let(Covariant);\nexport {\n/**\n * @category do notation\n * @since 1.0.0\n */\nlet_ as let };\n/**\n * Returns an effect whose Left and Right channels have been mapped by\n * the specified pair of functions, `f` and `g`.\n *\n * @category mapping\n * @since 1.0.0\n */\nexport const bimap = (f, g) => self => isLeft(self) ? left(f(self.left)) : right(g(self.right));\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Bicovariant = {\n  bimap\n};\n/**\n * Returns an effect with its error channel mapped using the specified\n * function. This can be used to lift a \"smaller\" error into a \"larger\" error.\n *\n * @category error handling\n * @since 1.0.0\n */\nexport const mapLeft = /*#__PURE__*/bicovariant.mapLeft(Bicovariant);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Of = {\n  of\n};\n/**\n * @since 1.0.0\n */\nexport const unit = /*#__PURE__*/of_.unit(Of);\n/**\n * @category do notation\n * @since 1.0.0\n */\nexport const Do = /*#__PURE__*/of_.Do(Of);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Pointed = {\n  ...Of,\n  ...Covariant\n};\n/**\n * @category sequencing\n * @since 1.0.0\n */\nexport const flatMap = f => self => isLeft(self) ? self : f(self.right);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const FlatMap = {\n  flatMap\n};\n/**\n * @since 1.0.0\n */\nexport const flatten = /*#__PURE__*/flatMap_.flatten(FlatMap);\n/**\n * @since 1.0.0\n */\nexport const andThen = /*#__PURE__*/flatMap_.andThen(FlatMap);\n/**\n * @since 1.0.0\n */\nexport const composeKleisliArrow = /*#__PURE__*/flatMap_.composeKleisliArrow(FlatMap);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Chainable = {\n  ...FlatMap,\n  ...Covariant\n};\n/**\n * @category do notation\n * @since 1.0.0\n */\nexport const bind = /*#__PURE__*/chainable.bind(Chainable);\n/**\n * Sequences the specified effect after this effect, but ignores the value\n * produced by the effect.\n *\n * @category sequencing\n * @since 1.0.0\n */\nexport const andThenDiscard = /*#__PURE__*/chainable.andThenDiscard(Chainable);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Monad = {\n  ...Pointed,\n  ...FlatMap\n};\nconst productMany = (self, collection) => {\n  if (isLeft(self)) {\n    return self;\n  }\n  const out = [self.right];\n  for (const e of collection) {\n    if (isLeft(e)) {\n      return e;\n    }\n    out.push(e.right);\n  }\n  return right(out);\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const SemiProduct = {\n  ...Invariant,\n  product: (self, that) => isRight(self) ? isRight(that) ? right([self.right, that.right]) : that : self,\n  productMany\n};\n/**\n * A variant of `bind` that sequentially ignores the scope.\n *\n * @category do notation\n * @since 1.0.0\n */\nexport const andThenBind = /*#__PURE__*/semiProduct.andThenBind(SemiProduct);\n/**\n * Adds an element to the end of a tuple.\n *\n * @since 1.0.0\n */\nexport const element = /*#__PURE__*/semiProduct.element(SemiProduct);\nconst productAll = collection => {\n  const out = [];\n  for (const e of collection) {\n    if (isLeft(e)) {\n      return e;\n    }\n    out.push(e.right);\n  }\n  return right(out);\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Product = {\n  ...Of,\n  ...SemiProduct,\n  productAll\n};\n/**\n * @since 1.0.0\n */\nexport const tuple = /*#__PURE__*/product_.tuple(Product);\n/**\n * @since 1.0.0\n */\nexport const struct = /*#__PURE__*/product_.struct(Product);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const SemiApplicative = {\n  ...SemiProduct,\n  ...Covariant\n};\n/**\n * Semigroup returning the left-most `Left` value. If both operands are `Right`s then the inner values\n * are concatenated using the provided `Semigroup`.\n *\n * | x        | y        | x |> combine(y)        |\n * | ---------| ---------| -----------------------|\n * | left(a)  | left(b)  | left(a)                |\n * | left(a)  | right(2) | left(a)                |\n * | right(1) | left(b)  | left(b)                |\n * | right(1) | right(2) | right(1 |> combine(2)) |\n *\n * @category combining\n * @since 1.0.0\n */\nexport const getFirstLeftSemigroup = /*#__PURE__*/semiApplicative.liftSemigroup(SemiApplicative);\n/**\n * @category lifting\n * @since 1.0.0\n */\nexport const lift2 = /*#__PURE__*/semiApplicative.lift2(SemiApplicative);\n/**\n * @category lifting\n * @since 1.0.0\n */\nexport const lift3 = /*#__PURE__*/semiApplicative.lift3(SemiApplicative);\n/**\n * @since 1.0.0\n */\nexport const ap = /*#__PURE__*/semiApplicative.ap(SemiApplicative);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Applicative = {\n  ...SemiApplicative,\n  ...Product\n};\n/**\n * Monoid returning the left-most `Left` value. If both operands are `Right`s then the inner values\n * are concatenated using the provided `Monoid`.\n *\n * The `empty` value is `right(M.empty)`.\n *\n * @category combining\n * @since 1.0.0\n */\nexport const getFirstLeftMonoid = /*#__PURE__*/applicative.liftMonoid(Applicative);\n/**\n * @category error handling\n * @since 1.0.0\n */\nexport const firstSuccessOf = collection => self => {\n  let out = self;\n  if (isRight(out)) {\n    return out;\n  }\n  for (out of collection) {\n    if (isRight(out)) {\n      return out;\n    }\n  }\n  return out;\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const SemiCoproduct = {\n  ...Invariant,\n  coproduct: (self, that) => isRight(self) ? self : that,\n  coproductMany: (self, collection) => pipe(self, firstSuccessOf(collection))\n};\n/**\n * Semigroup returning the left-most `Right` value.\n *\n * | x        | y        | x |> combine(y) |\n * | ---------| ---------| ----------------|\n * | left(a)  | left(b)  | left(b)         |\n * | left(a)  | right(2) | right(2)        |\n * | right(1) | left(b)  | right(1)        |\n * | right(1) | right(2) | right(1)        |\n *\n * @category combining\n * @since 1.0.0\n */\nexport const getFirstRightSemigroup = /*#__PURE__*/semiCoproduct.getSemigroup(SemiCoproduct);\n/**\n * Returns the wrapped value if it's a `Right` or a default value if is a `Left`.\n *\n * @example\n * import * as E from '@fp-ts/core/Either'\n * import { pipe } from '@fp-ts/core/Function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     E.right(1),\n *     E.getOrElse(() => 0)\n *   ),\n *   1\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     E.left('error'),\n *     E.getOrElse(() => 0)\n *   ),\n *   0\n * )\n *\n * @category getters\n * @since 1.0.0\n */\nexport const getOrElse = onLeft => self => isLeft(self) ? onLeft() : self.right;\n/**\n * Recovers from all errors.\n *\n * @category error handling\n * @since 1.0.0\n */\nexport const catchAll = onLeft => self => isLeft(self) ? onLeft(self.left) : self;\n/**\n * Executes this effect and returns its value, if it succeeds, but otherwise\n * executes the specified effect.\n *\n * | x          | y          | x |> orElse(y) |\n * | ---------- | ---------- | ---------------|\n * | left(a)    | left(b)    | left(b)        |\n * | left(a)    | right(2)   | right(2)       |\n * | right(1)   | left(b)    | right(1)       |\n * | right(1)   | right(2)   | right(1)       |\n *\n * @category error handling\n * @since 1.0.0\n */\nexport const orElse = that => self => isLeft(self) ? that : self;\n/**\n * Returns an effect that will produce the value of this effect, unless it\n * fails, in which case, it will produce the value of the specified effect.\n *\n * @category error handling\n * @since 1.0.0\n */\nexport const orElseEither = that => self => isLeft(self) ? pipe(that, map(right)) : pipe(self, map(left));\n/**\n * Executes this effect and returns its value, if it succeeds, but otherwise\n * fails with the specified error.\n *\n * @category error handling\n * @since 1.0.0\n */\nexport const orElseFail = onLeft => catchAll(() => left(onLeft()));\n/**\n * Executes this effect and returns its value, if it succeeds, but otherwise\n * succeeds with the specified value.\n *\n * @category error handling\n * @since 1.0.0\n */\nexport const orElseSucceed = onLeft => catchAll(() => right(onLeft()));\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const SemiAlternative = {\n  ...Covariant,\n  ...SemiCoproduct\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Foldable = {\n  reduce: (b, f) => self => isLeft(self) ? b : f(b, self.right)\n};\n/**\n * Takes two functions and an `Either` value, if the value is a `Left` the inner value is applied to the first function,\n * if the value is a `Right` the inner value is applied to the second function.\n *\n * @example\n * import * as E from '@fp-ts/core/Either'\n * import { pipe } from '@fp-ts/core/Function'\n *\n * const onLeft  = (errors: ReadonlyArray<string>): string => `Errors: ${errors.join(', ')}`\n *\n * const onRight = (value: number): string => `Ok: ${value}`\n *\n * assert.strictEqual(\n *   pipe(\n *     E.right(1),\n *     E.match(onLeft , onRight)\n *   ),\n *   'Ok: 1'\n * )\n * assert.strictEqual(\n *   pipe(\n *     E.left(['error 1', 'error 2']),\n *     E.match(onLeft , onRight)\n *   ),\n *   'Errors: error 1, error 2'\n * )\n *\n * @category pattern matching\n * @since 1.0.0\n */\nexport const match = (onLeft, onRight) => self => isLeft(self) ? onLeft(self.left) : onRight(self.right);\n/**\n * Takes a lazy default and a nullable value, if the value is not nully, turn it into a `Right`, if the value is nully use\n * the provided default as a `Left`.\n *\n * @example\n * import * as E from '@fp-ts/core/Either'\n *\n * const parse = E.fromNullable(() => 'nullable')\n *\n * assert.deepStrictEqual(parse(1), E.right(1))\n * assert.deepStrictEqual(parse(null), E.left('nullable'))\n *\n * @category conversions\n * @since 1.0.0\n */\nexport const fromNullable = either.fromNullable;\n/**\n * @category lifting\n * @since 1.0.0\n */\nexport const liftNullable = (f, onNullable) => (...a) => fromNullable(() => onNullable(...a))(f(...a));\n/**\n * @category sequencing\n * @since 1.0.0\n */\nexport const flatMapNullable = (f, onNullable) => flatMap(liftNullable(f, onNullable));\n/**\n * Returns a `Refinement` from a `Either` returning function.\n * This function ensures that a `Refinement` definition is type-safe.\n *\n * @category conversions\n * @since 1.0.0\n */\nexport const toRefinement = f => a => isRight(f(a));\n/**\n * Constructs a new `Either` from a function that might throw.\n *\n * @example\n * import * as E from '@fp-ts/core/Either'\n * import { identity } from '@fp-ts/core/Function'\n *\n * const unsafeHead = <A>(as: ReadonlyArray<A>): A => {\n *   if (as.length > 0) {\n *     return as[0]\n *   } else {\n *     throw new Error('empty array')\n *   }\n * }\n *\n * const head = <A>(as: ReadonlyArray<A>): E.Either<unknown, A> =>\n *   E.fromThrowable(() => unsafeHead(as), identity)\n *\n * assert.deepStrictEqual(head([]), E.left(new Error('empty array')))\n * assert.deepStrictEqual(head([1, 2, 3]), E.right(1))\n *\n * @category interop\n * @since 1.0.0\n */\nexport const fromThrowable = (f, onThrow) => {\n  try {\n    return right(f());\n  } catch (e) {\n    return left(onThrow(e));\n  }\n};\n/**\n * @category interop\n * @since 1.0.0\n */\nexport const getOrThrow = onLeft => self => {\n  if (isRight(self)) {\n    return self.right;\n  }\n  throw onLeft(self.left);\n};\n/**\n * Lifts a function that may throw to one returning a `Either`.\n *\n * @category interop\n * @since 1.0.0\n */\nexport const liftThrowable = (f, onThrow) => (...a) => fromThrowable(() => f(...a), onThrow);\n/**\n * @category getters\n * @since 1.0.0\n */\nexport const merge = /*#__PURE__*/match(identity, identity);\n/**\n * @since 1.0.0\n */\nexport const reverse = self => isLeft(self) ? right(self.left) : left(self.right);\n/**\n * @category filtering\n * @since 1.0.0\n */\nexport const compact = onNone => self => isLeft(self) ? self : option.isNone(self.right) ? left(onNone()) : right(self.right.value);\n/**\n * @category filtering\n * @since 1.0.0\n */\nexport const filter = (predicate, onFalse) => self => isLeft(self) ? self : predicate(self.right) ? self : left(onFalse());\n/**\n * @category filtering\n * @since 1.0.0\n */\nexport const filterMap = (f, onNone) => self => pipe(self, flatMap(a => {\n  const ob = f(a);\n  return option.isNone(ob) ? left(onNone()) : right(ob.value);\n}));\n/**\n * @category traversing\n * @since 1.0.0\n */\nexport const traverse = F => f => self => isLeft(self) ? F.of(left(self.left)) : pipe(f(self.right), F.map(right));\n/**\n * @category traversing\n * @since 1.0.0\n */\nexport const sequence = /*#__PURE__*/traversable.sequence(traverse);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Traversable = {\n  traverse,\n  sequence\n};\n/**\n * @category traversing\n * @since 1.0.0\n */\nexport const traverseTap = /*#__PURE__*/traversable.traverseTap(Traversable);\n/**\n * Returns an effect that effectfully \"peeks\" at the success of this effect.\n *\n * @since 1.0.0\n */\nexport const tap = /*#__PURE__*/chainable.tap(Chainable);\n/**\n * @category debugging\n * @since 1.0.0\n */\nexport const inspectRight = onRight => self => {\n  if (isRight(self)) {\n    onRight(self.right);\n  }\n  return self;\n};\n/**\n * Returns an effect that effectfully \"peeks\" at the failure of this effect.\n *\n * @category error handling\n * @since 1.0.0\n */\nexport const tapError = onLeft => self => {\n  if (isRight(self)) {\n    return self;\n  }\n  const out = onLeft(self.left);\n  return isLeft(out) ? out : self;\n};\n/**\n * @category debugging\n * @since 1.0.0\n */\nexport const inspectLeft = onLeft => self => {\n  if (isLeft(self)) {\n    onLeft(self.left);\n  }\n  return self;\n};\n/**\n * @category conversions\n * @since 1.0.0\n */\nexport const fromIterable = onEmpty => collection => {\n  for (const a of collection) {\n    return right(a);\n  }\n  return left(onEmpty());\n};\n/**\n * @example\n * import * as E from '@fp-ts/core/Either'\n * import { pipe } from '@fp-ts/core/Function'\n * import * as O from '@fp-ts/core/Option'\n *\n * assert.deepStrictEqual(pipe(O.some(1), E.fromOption(() => 'error')), E.right(1))\n * assert.deepStrictEqual(pipe(O.none(), E.fromOption(() => 'error')), E.left('error'))\n *\n * @category conversions\n * @since 1.0.0\n */\nexport const fromOption = either.fromOption;\n/**\n * Converts a `Either` to an `Option` discarding the Right.\n *\n * @example\n * import * as O from '@fp-ts/core/Option'\n * import * as E from '@fp-ts/core/Either'\n *\n * assert.deepStrictEqual(E.getLeft(E.right('ok')), O.none())\n * assert.deepStrictEqual(E.getLeft(E.left('err')), O.some('err'))\n *\n * @category getters\n * @since 1.0.0\n */\nexport const getLeft = either.getLeft;\n/**\n * Converts a `Either` to an `Option` discarding the error.\n *\n * @example\n * import * as O from '@fp-ts/core/Option'\n * import * as E from '@fp-ts/core/Either'\n *\n * assert.deepStrictEqual(E.getRight(E.right('ok')), O.some('ok'))\n * assert.deepStrictEqual(E.getRight(E.left('err')), O.none())\n *\n * @category getters\n * @since 1.0.0\n */\nexport const getRight = either.getRight;\n/**\n * @category getters\n * @since 1.0.0\n */\nexport const getOrNull = /*#__PURE__*/getOrElse(constNull);\n/**\n * @category getters\n * @since 1.0.0\n */\nexport const getOrUndefined = /*#__PURE__*/getOrElse(constUndefined);\n/**\n * @example\n * import { liftPredicate, left, right } from '@fp-ts/core/Either'\n * import { pipe } from '@fp-ts/core/Function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     1,\n *     liftPredicate((n) => n > 0, () => 'error')\n *   ),\n *   right(1)\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     -1,\n *     liftPredicate((n) => n > 0, () => 'error')\n *   ),\n *   left('error')\n * )\n *\n * @category lifting\n * @since 1.0.0\n */\nexport const liftPredicate = (predicate, onFalse) => b => predicate(b) ? right(b) : left(onFalse());\n/**\n * @category lifting\n * @since 1.0.0\n */\nexport const liftOption = (f, onNone) => (...a) => fromOption(() => onNone(...a))(f(...a));\n/**\n * @category sequencing\n * @since 1.0.0\n */\nexport const flatMapOption = (f, onNone) => self => pipe(self, flatMap(liftOption(f, onNone)));\n/**\n * Returns a function that checks if an `Either` contains a given value using a provided `equivalence` function.\n *\n * @since 1.0.0\n */\nexport const contains = equivalence => a => self => isLeft(self) ? false : equivalence(self.right, a);\n/**\n * Returns `false` if `Left` or returns the Either of the application of the given predicate to the `Right` value.\n *\n * @example\n * import * as E from '@fp-ts/core/Either'\n *\n * const f = E.exists((n: number) => n > 2)\n *\n * assert.strictEqual(f(E.left('a')), false)\n * assert.strictEqual(f(E.right(1)), false)\n * assert.strictEqual(f(E.right(3)), true)\n *\n * @since 1.0.0\n */\nexport const exists = predicate => self => isLeft(self) ? false : predicate(self.right);\n//# sourceMappingURL=Either.mjs.map","/** @internal */\nexport const isNonEmpty = as => as.length > 0;\n/** @internal */\nexport const fromIterable = collection => Array.isArray(collection) ? collection : Array.from(collection);\n//# sourceMappingURL=ReadonlyArray.mjs.map","import { pipe } from \"@fp-ts/core/Function\";\nimport * as either from \"@fp-ts/core/internal/Either\";\n/**\n * Returns a default `compact` composition.\n *\n * @since 1.0.0\n */\nexport const compactComposition = (F, G) => F.map(G.compact);\n/**\n * @since 1.0.0\n */\nexport const separate = F => self => {\n  return [pipe(self, F.map(either.getLeft), F.compact), pipe(self, F.map(either.getRight), F.compact)];\n};\n//# sourceMappingURL=Compactable.mjs.map","/**\n * @since 1.0.0\n */\nimport { identity, pipe } from \"@fp-ts/core/Function\";\n/**\n * @since 1.0.0\n */\nexport const flatten = F => self => pipe(self, F.flatMap(identity));\n/**\n * A variant of `flatMap` that ignores the value produced by this effect.\n *\n * @since 1.0.0\n */\nexport const andThen = F => that => F.flatMap(() => that);\n/**\n * @since 1.0.0\n */\nexport const composeKleisliArrow = F => bc => ab => a => pipe(ab(a), F.flatMap(bc));\n//# sourceMappingURL=FlatMap.mjs.map","import { constNull, constUndefined, pipe } from \"@fp-ts/core/Function\";\nimport * as either from \"@fp-ts/core/internal/Either\";\nimport * as option from \"@fp-ts/core/internal/Option\";\nimport * as readonlyArray from \"@fp-ts/core/internal/ReadonlyArray\";\nimport * as applicative from \"@fp-ts/core/typeclass/Applicative\";\nimport * as chainable from \"@fp-ts/core/typeclass/Chainable\";\nimport * as compactable from \"@fp-ts/core/typeclass/Compactable\";\nimport * as covariant from \"@fp-ts/core/typeclass/Covariant\";\nimport * as filterable from \"@fp-ts/core/typeclass/Filterable\";\nimport * as flatMap_ from \"@fp-ts/core/typeclass/FlatMap\";\nimport * as foldable from \"@fp-ts/core/typeclass/Foldable\";\nimport * as invariant from \"@fp-ts/core/typeclass/Invariant\";\nimport * as of_ from \"@fp-ts/core/typeclass/Of\";\nimport * as order from \"@fp-ts/core/typeclass/Order\";\nimport * as product_ from \"@fp-ts/core/typeclass/Product\";\nimport * as semiApplicative from \"@fp-ts/core/typeclass/SemiApplicative\";\nimport * as semiCoproduct from \"@fp-ts/core/typeclass/SemiCoproduct\";\nimport * as semiProduct from \"@fp-ts/core/typeclass/SemiProduct\";\nimport * as traversable from \"@fp-ts/core/typeclass/Traversable\";\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const none = () => option.none;\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const some = option.some;\n/**\n * Returns `true` if the specified value is an instance of `Option`, `false`\n * otherwise.\n *\n * @example\n * import { some, none, isOption } from '@fp-ts/core/Option'\n *\n * assert.strictEqual(isOption(some(1)), true)\n * assert.strictEqual(isOption(none()), true)\n * assert.strictEqual(isOption({}), false)\n *\n * @category guards\n * @since 1.0.0\n */\nexport const isOption = option.isOption;\n/**\n * Constructs a new `Option` from a nullable type. If the value is `null` or `undefined`, returns `None`, otherwise\n * returns the value wrapped in a `Some`.\n *\n * @example\n * import { none, some, fromNullable } from '@fp-ts/core/Option'\n *\n * assert.deepStrictEqual(fromNullable(undefined), none())\n * assert.deepStrictEqual(fromNullable(null), none())\n * assert.deepStrictEqual(fromNullable(1), some(1))\n *\n * @category conversions\n * @since 1.0.0\n */\nexport const fromNullable = option.fromNullable;\n/**\n * Returns a `Refinement` from a `Option` returning function.\n * This function ensures that a `Refinement` definition is type-safe.\n *\n * @category conversions\n * @since 1.0.0\n */\nexport const toRefinement = f => a => isSome(f(a));\n/**\n * Converts an exception into an `Option`. If `f` throws, returns `None`, otherwise returns the output wrapped in a\n * `Some`.\n *\n * @example\n * import { none, some, fromThrowable } from '@fp-ts/core/Option'\n *\n * assert.deepStrictEqual(\n *   fromThrowable(() => {\n *     throw new Error()\n *   }),\n *   none()\n * )\n * assert.deepStrictEqual(fromThrowable(() => 1), some(1))\n *\n * @category interop\n * @since 1.0.0\n */\nexport const fromThrowable = f => {\n  try {\n    return some(f());\n  } catch (e) {\n    return option.none;\n  }\n};\n/**\n * Lifts a function that may throw to one returning a `Option`.\n *\n * @category interop\n * @since 1.0.0\n */\nexport const liftThrowable = f => (...a) => fromThrowable(() => f(...a));\n/**\n * @category interop\n * @since 1.0.0\n */\nexport const getOrThrow = onError => self => {\n  if (isSome(self)) {\n    return self.value;\n  }\n  throw onError();\n};\n/**\n * Returns an effect whose success is mapped by the specified `f` function.\n *\n * @category mapping\n * @since 1.0.0\n */\nexport const map = f => self => isNone(self) ? option.none : some(f(self.value));\n/**\n * @category mapping\n * @since 1.0.0\n */\nexport const imap = /*#__PURE__*/covariant.imap(map);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Invariant = {\n  imap\n};\n/**\n * @since 1.0.0\n */\nexport const tupled = /*#__PURE__*/invariant.tupled(Invariant);\n/**\n * @category do notation\n * @since 1.0.0\n */\nexport const bindTo = /*#__PURE__*/invariant.bindTo(Invariant);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Covariant = {\n  ...Invariant,\n  map\n};\nconst let_ = /*#__PURE__*/covariant.let(Covariant);\nexport {\n/**\n * @category do notation\n * @since 1.0.0\n */\nlet_ as let };\n/**\n * @category mapping\n * @since 1.0.0\n */\nexport const flap = /*#__PURE__*/covariant.flap(Covariant);\n/**\n * Maps the success value of this effect to the specified constant value.\n *\n * @category mapping\n * @since 1.0.0\n */\nexport const as = /*#__PURE__*/covariant.as(Covariant);\n/**\n * Returns the effect resulting from mapping the success of this effect to unit.\n *\n * @category mapping\n * @since 1.0.0\n */\nexport const asUnit = /*#__PURE__*/covariant.asUnit(Covariant);\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const of = some;\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Of = {\n  of: some\n};\n/**\n * @since 1.0.0\n */\nexport const unit = /*#__PURE__*/of_.unit(Of);\n/**\n * @category do notation\n * @since 1.0.0\n */\nexport const Do = /*#__PURE__*/of_.Do(Of);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Pointed = {\n  ...Of,\n  ...Covariant\n};\n/**\n * @category sequencing\n * @since 1.0.0\n */\nexport const flatMap = f => self => isNone(self) ? option.none : f(self.value);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const FlatMap = {\n  flatMap\n};\n/**\n * @since 1.0.0\n */\nexport const flatten = /*#__PURE__*/flatMap_.flatten(FlatMap);\n/**\n * @since 1.0.0\n */\nexport const andThen = /*#__PURE__*/flatMap_.andThen(FlatMap);\n/**\n * @since 1.0.0\n */\nexport const composeKleisliArrow = /*#__PURE__*/flatMap_.composeKleisliArrow(FlatMap);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Chainable = {\n  ...FlatMap,\n  ...Covariant\n};\n/**\n * @category do notation\n * @since 1.0.0\n */\nexport const bind = /*#__PURE__*/chainable.bind(Chainable);\n/**\n * Returns an effect that effectfully \"peeks\" at the success of this effect.\n *\n * @since 1.0.0\n */\nexport const tap = /*#__PURE__*/chainable.tap(Chainable);\n/**\n * @category debugging\n * @since 1.0.0\n */\nexport const inspectSome = onSome => self => {\n  if (isSome(self)) {\n    onSome(self.value);\n  }\n  return self;\n};\n/**\n * @category debugging\n * @since 1.0.0\n */\nexport const inspectNone = onNone => self => {\n  if (isNone(self)) {\n    onNone();\n  }\n  return self;\n};\n/**\n * Sequences the specified effect after this effect, but ignores the value\n * produced by the effect.\n *\n * @category sequencing\n * @since 1.0.0\n */\nexport const andThenDiscard = /*#__PURE__*/chainable.andThenDiscard(Chainable);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Monad = {\n  ...Pointed,\n  ...FlatMap\n};\nconst productMany = (self, collection) => {\n  if (isNone(self)) {\n    return option.none;\n  }\n  const out = [self.value];\n  for (const o of collection) {\n    if (isNone(o)) {\n      return option.none;\n    }\n    out.push(o.value);\n  }\n  return some(out);\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const SemiProduct = {\n  ...Invariant,\n  product: (self, that) => isSome(self) && isSome(that) ? some([self.value, that.value]) : option.none,\n  productMany\n};\n/**\n * A variant of `bind` that sequentially ignores the scope.\n *\n * @category do notation\n * @since 1.0.0\n */\nexport const andThenBind = /*#__PURE__*/semiProduct.andThenBind(SemiProduct);\n/**\n * Adds an element to the end of a tuple.\n *\n * @since 1.0.0\n */\nexport const element = /*#__PURE__*/semiProduct.element(SemiProduct);\nconst productAll = collection => {\n  const out = [];\n  for (const o of collection) {\n    if (isNone(o)) {\n      return option.none;\n    }\n    out.push(o.value);\n  }\n  return some(out);\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Product = {\n  ...Of,\n  ...SemiProduct,\n  productAll\n};\n/**\n * @since 1.0.0\n */\nexport const tuple = /*#__PURE__*/product_.tuple(Product);\n/**\n * @since 1.0.0\n */\nexport const struct = /*#__PURE__*/product_.struct(Product);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const SemiApplicative = {\n  ...SemiProduct,\n  ...Covariant\n};\n/**\n * Monoid returning the left-most non-`None` value. If both operands are `Some`s then the inner values are\n * combined using the provided `Semigroup`\n *\n * | x       | y       | combine(y)(x)       |\n * | ------- | ------- | ------------------- |\n * | none    | none    | none                |\n * | some(a) | none    | some(a)             |\n * | none    | some(a) | some(a)             |\n * | some(a) | some(b) | some(combine(b)(a)) |\n *\n * @example\n * import { getMonoid, some, none } from '@fp-ts/core/Option'\n * import * as N from '@fp-ts/core/Number'\n * import { pipe } from '@fp-ts/core/Function'\n *\n * const M = getMonoid(N.SemigroupSum)\n * assert.deepStrictEqual(M.combine(none(), none()), none())\n * assert.deepStrictEqual(M.combine(some(1), none()), some(1))\n * assert.deepStrictEqual(M.combine(none(), some(1)), some(1))\n * assert.deepStrictEqual(M.combine(some(1), some(2)), some(3))\n *\n * @category lifting\n * @since 1.0.0\n */\nexport const getMonoid = Semigroup => {\n  const combine = (self, that) => isNone(self) ? that : isNone(that) ? self : some(Semigroup.combine(self.value, that.value));\n  return {\n    combine,\n    combineMany: (self, collection) => {\n      let c = self;\n      for (const o of collection) {\n        c = combine(c, o);\n      }\n      return c;\n    },\n    combineAll: collection => {\n      let c = option.none;\n      for (const o of collection) {\n        c = combine(c, o);\n      }\n      return c;\n    },\n    empty: option.none\n  };\n};\n/**\n * Lifts a binary function into `Option`.\n *\n * @category lifting\n * @since 1.0.0\n */\nexport const lift2 = /*#__PURE__*/semiApplicative.lift2(SemiApplicative);\n/**\n * Lifts a ternary function into `Option`.\n *\n * @category lifting\n * @since 1.0.0\n */\nexport const lift3 = /*#__PURE__*/semiApplicative.lift3(SemiApplicative);\n/**\n * @since 1.0.0\n */\nexport const ap = /*#__PURE__*/semiApplicative.ap(SemiApplicative);\n/**\n * Semigroup returning the left-most `None` value. If both operands are `Right`s then the inner values\n * are concatenated using the provided `Semigroup`.\n *\n * @category combining\n * @since 1.0.0\n */\nexport const getFirstNoneSemigroup = /*#__PURE__*/semiApplicative.liftSemigroup(SemiApplicative);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Applicative = {\n  ...SemiApplicative,\n  ...Product\n};\n/**\n * Monoid returning the left-most `None` value. If both operands are `Right`s then the inner values\n * are concatenated using the provided `Monoid`.\n *\n * The `empty` value is `some(M.empty)`.\n *\n * @category combining\n * @since 1.0.0\n */\nexport const getFirstNoneMonoid = /*#__PURE__*/applicative.liftMonoid(Applicative);\n/**\n * @category error handling\n * @since 1.0.0\n */\nexport const firstSomeOf = collection => self => {\n  let out = self;\n  if (isSome(out)) {\n    return out;\n  }\n  for (out of collection) {\n    if (isSome(out)) {\n      return out;\n    }\n  }\n  return out;\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const SemiCoproduct = {\n  ...Invariant,\n  coproduct: (self, that) => isSome(self) ? self : that,\n  coproductMany: (self, collection) => pipe(self, firstSomeOf(collection))\n};\n/**\n * Semigroup returning the left-most `Some` value.\n *\n * @category combining\n * @since 1.0.0\n */\nexport const getFirstSomeSemigroup = /*#__PURE__*/semiCoproduct.getSemigroup(SemiCoproduct);\n/**\n * @since 1.0.0\n */\nexport const coproductEither = that => self => isNone(self) ? pipe(that, map(either.right)) : pipe(self, map(either.left));\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Coproduct = {\n  ...SemiCoproduct,\n  zero: none,\n  coproductAll: collection => {\n    const options = readonlyArray.fromIterable(collection);\n    return options.length > 0 ? SemiCoproduct.coproductMany(options[0], options.slice(1)) : option.none;\n  }\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const SemiAlternative = {\n  ...Covariant,\n  ...SemiCoproduct\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Alternative = {\n  ...SemiAlternative,\n  ...Coproduct\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Foldable = {\n  reduce: (b, f) => self => isNone(self) ? b : f(b, self.value)\n};\n/**\n * @since 1.0.0\n */\nexport const toArray = /*#__PURE__*/foldable.toArray(Foldable);\n/**\n * Alias of `flatten`.\n *\n * @category filtering\n * @since 1.0.0\n */\nexport const compact = flatten;\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Compactable = {\n  compact\n};\n/**\n * @category filtering\n * @since 1.0.0\n */\nexport const separate = /*#__PURE__*/compactable.separate({\n  ...Covariant,\n  ...Compactable\n});\n/**\n * @category filtering\n * @since 1.0.0\n */\nexport const filterMap = f => self => isNone(self) ? option.none : f(self.value);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Filterable = {\n  filterMap\n};\n/**\n * @category filtering\n * @since 1.0.0\n */\nexport const filter = /*#__PURE__*/filterable.filter(Filterable);\n/**\n * @category traversing\n * @since 1.0.0\n */\nexport const traverse = F => f => self => isNone(self) ? F.of(option.none) : pipe(f(self.value), F.map(some));\n/**\n * @category traversing\n * @since 1.0.0\n */\nexport const sequence = /*#__PURE__*/traversable.sequence(traverse);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Traversable = {\n  traverse,\n  sequence\n};\n/**\n * @category traversing\n * @since 1.0.0\n */\nexport const traverseTap = /*#__PURE__*/traversable.traverseTap(Traversable);\n/**\n * Returns `true` if the option is `None`, `false` otherwise.\n *\n * @example\n * import { some, none, isNone } from '@fp-ts/core/Option'\n *\n * assert.strictEqual(isNone(some(1)), false)\n * assert.strictEqual(isNone(none()), true)\n *\n * @category guards\n * @since 1.0.0\n */\nexport const isNone = option.isNone;\n/**\n * Returns `true` if the option is an instance of `Some`, `false` otherwise.\n *\n * @example\n * import { some, none, isSome } from '@fp-ts/core/Option'\n *\n * assert.strictEqual(isSome(some(1)), true)\n * assert.strictEqual(isSome(none()), false)\n *\n * @category guards\n * @since 1.0.0\n */\nexport const isSome = option.isSome;\n/**\n * @category conversions\n * @since 1.0.0\n */\nexport const fromIterable = collection => {\n  for (const a of collection) {\n    return some(a);\n  }\n  return option.none;\n};\n/**\n * Converts a `Either` to an `Option` discarding the error.\n *\n * @example\n * import * as O from '@fp-ts/core/Option'\n * import * as E from '@fp-ts/core/Either'\n *\n * assert.deepStrictEqual(O.fromEither(E.right(1)), O.some(1))\n * assert.deepStrictEqual(O.fromEither(E.left('a')), O.none())\n *\n * @category conversions\n * @since 1.0.0\n */\nexport const fromEither = either.getRight;\n/**\n * @category conversions\n * @since 1.0.0\n */\nexport const toEither = either.fromOption;\n/**\n * Takes a (lazy) default value, a function, and an `Option` value, if the `Option` value is `None` the default value is\n * returned, otherwise the function is applied to the value inside the `Some` and the result is returned.\n *\n * @example\n * import { some, none, match } from '@fp-ts/core/Option'\n * import { pipe } from '@fp-ts/core/Function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     match(() => 'a none', a => `a some containing ${a}`)\n *   ),\n *   'a some containing 1'\n * )\n *\n * assert.strictEqual(\n *   pipe(\n *     none(),\n *     match(() => 'a none', a => `a some containing ${a}`)\n *   ),\n *   'a none'\n * )\n *\n * @category pattern matching\n * @since 1.0.0\n */\nexport const match = (onNone, onSome) => self => isNone(self) ? onNone() : onSome(self.value);\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns the given default value\n *\n * @example\n * import { some, none, getOrElse } from '@fp-ts/core/Option'\n * import { pipe } from '@fp-ts/core/Function'\n *\n * assert.strictEqual(pipe(some(1), getOrElse(() => 0)), 1)\n * assert.strictEqual(pipe(none(), getOrElse(() => 0)), 0)\n *\n * @category error handling\n * @since 1.0.0\n */\nexport const getOrElse = onNone => self => isNone(self) ? onNone() : self.value;\n/**\n * Returns a *smart constructor* from a function that returns a nullable value.\n *\n * @example\n * import { liftNullable, none, some } from '@fp-ts/core/Option'\n *\n * const f = (s: string): number | undefined => {\n *   const n = parseFloat(s)\n *   return isNaN(n) ? undefined : n\n * }\n *\n * const g = liftNullable(f)\n *\n * assert.deepStrictEqual(g('1'), some(1))\n * assert.deepStrictEqual(g('a'), none())\n *\n * @category lifting\n * @since 1.0.0\n */\nexport const liftNullable = f => (...a) => fromNullable(f(...a));\n/**\n * This is `flatMap` + `fromNullable`, useful when working with optional values.\n *\n * @example\n * import { some, none, fromNullable, flatMapNullable } from '@fp-ts/core/Option'\n * import { pipe } from '@fp-ts/core/Function'\n *\n * interface Employee {\n *   company?: {\n *     address?: {\n *       street?: {\n *         name?: string\n *       }\n *     }\n *   }\n * }\n *\n * const employee1: Employee = { company: { address: { street: { name: 'high street' } } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     fromNullable(employee1.company),\n *     flatMapNullable(company => company.address),\n *     flatMapNullable(address => address.street),\n *     flatMapNullable(street => street.name)\n *   ),\n *   some('high street')\n * )\n *\n * const employee2: Employee = { company: { address: { street: {} } } }\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     fromNullable(employee2.company),\n *     flatMapNullable(company => company.address),\n *     flatMapNullable(address => address.street),\n *     flatMapNullable(street => street.name)\n *   ),\n *   none()\n * )\n *\n * @category sequencing\n * @since 1.0.0\n */\nexport const flatMapNullable = f => self => isNone(self) ? option.none : fromNullable(f(self.value));\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns `null`.\n *\n * @example\n * import { some, none, getOrNull } from '@fp-ts/core/Option'\n * import { pipe } from '@fp-ts/core/Function'\n *\n * assert.strictEqual(pipe(some(1), getOrNull), 1)\n * assert.strictEqual(pipe(none(), getOrNull), null)\n *\n * @category conversions\n * @since 1.0.0\n */\nexport const getOrNull = /*#__PURE__*/getOrElse(constNull);\n/**\n * Extracts the value out of the structure, if it exists. Otherwise returns `undefined`.\n *\n * @example\n * import { some, none, getOrUndefined } from '@fp-ts/core/Option'\n * import { pipe } from '@fp-ts/core/Function'\n *\n * assert.strictEqual(pipe(some(1), getOrUndefined), 1)\n * assert.strictEqual(pipe(none(), getOrUndefined), undefined)\n *\n * @category conversions\n * @since 1.0.0\n */\nexport const getOrUndefined = /*#__PURE__*/getOrElse(constUndefined);\n/**\n * Lazy version of `orElse`.\n *\n * @category error handling\n * @since 1.0.0\n */\nexport const catchAll = that => self => isNone(self) ? that() : self;\n/**\n * Identifies an associative operation on a type constructor. It is similar to `Semigroup`, except that it applies to\n * types of kind `* -> *`.\n *\n * In case of `Option` returns the left-most non-`None` value.\n *\n * | x       | y       | pipe(x, orElse(y) |\n * | ------- | ------- | ------------------|\n * | none    | none    | none              |\n * | some(a) | none    | some(a)           |\n * | none    | some(b) | some(b)           |\n * | some(a) | some(b) | some(a)           |\n *\n * @example\n * import * as O from '@fp-ts/core/Option'\n * import { pipe } from '@fp-ts/core/Function'\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     O.none(),\n *     O.orElse(O.none())\n *   ),\n *   O.none()\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     O.some('a'),\n *     O.orElse<string>(O.none())\n *   ),\n *   O.some('a')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     O.none(),\n *     O.orElse(O.some('b'))\n *   ),\n *   O.some('b')\n * )\n * assert.deepStrictEqual(\n *   pipe(\n *     O.some('a'),\n *     O.orElse(O.some('b'))\n *   ),\n *   O.some('a')\n * )\n *\n * @category error handling\n * @since 1.0.0\n */\nexport const orElse = that => catchAll(() => that);\n/**\n * Returns an effect that will produce the value of this effect, unless it\n * fails, in which case, it will produce the value of the specified effect.\n *\n * @category error handling\n * @since 1.0.0\n */\nexport const orElseEither = that => self => isNone(self) ? pipe(that, map(either.right)) : pipe(self, map(either.left));\n/**\n * Executes this effect and returns its value, if it succeeds, but otherwise\n * succeeds with the specified value.\n *\n * @category error handling\n * @since 1.0.0\n */\nexport const orElseSucceed = onNone => catchAll(() => some(onNone()));\n/**\n * The `Order` instance allows `Option` values to be compared with\n * `compare`, whenever there is an `Order` instance for\n * the type the `Option` contains.\n *\n * `None` is considered to be less than any `Some` value.\n *\n * @example\n * import { none, some, liftOrder } from '@fp-ts/core/Option'\n * import * as N from '@fp-ts/core/Number'\n * import { pipe } from '@fp-ts/core/Function'\n *\n * const O = liftOrder(N.Order)\n * assert.strictEqual(O.compare(none(), none()), 0)\n * assert.strictEqual(O.compare(none(), some(1)), -1)\n * assert.strictEqual(O.compare(some(1), none()), 1)\n * assert.strictEqual(O.compare(some(1), some(2)), -1)\n * assert.strictEqual(O.compare(some(1), some(1)), 0)\n *\n * @category sorting\n * @since 1.0.0\n */\nexport const liftOrder = O => order.fromCompare((self, that) => isSome(self) ? isSome(that) ? O.compare(self.value, that.value) : 1 : -1);\n/**\n * Returns a *smart constructor* based on the given predicate.\n *\n * @example\n * import * as O from '@fp-ts/core/Option'\n *\n * const getOption = O.liftPredicate((n: number) => n >= 0)\n *\n * assert.deepStrictEqual(getOption(-1), O.none())\n * assert.deepStrictEqual(getOption(1), O.some(1))\n *\n * @category lifting\n * @since 1.0.0\n */\nexport const liftPredicate = predicate => b => predicate(b) ? some(b) : option.none;\n/**\n * @category lifting\n * @since 1.0.0\n */\nexport const liftEither = f => (...a) => fromEither(f(...a));\n/**\n * @category sequencing\n * @since 1.0.0\n */\nexport const flatMapEither = f => self => pipe(self, flatMap(liftEither(f)));\n/**\n * Returns a function that checks if an `Option` contains a given value using a provided `equivalence` function.\n *\n * @since 1.0.0\n */\nexport const contains = equivalence => a => self => isNone(self) ? false : equivalence(self.value, a);\n/**\n * Returns `true` if the predicate is satisfied by the wrapped value\n *\n * @example\n * import { some, none, exists } from '@fp-ts/core/Option'\n * import { pipe } from '@fp-ts/core/Function'\n *\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     exists(n => n > 0)\n *   ),\n *   true\n * )\n * assert.strictEqual(\n *   pipe(\n *     some(1),\n *     exists(n => n > 1)\n *   ),\n *   false\n * )\n * assert.strictEqual(\n *   pipe(\n *     none(),\n *     exists(n => n > 0)\n *   ),\n *   false\n * )\n *\n * @since 1.0.0\n */\nexport const exists = predicate => self => isNone(self) ? false : predicate(self.value);\n//# sourceMappingURL=Option.mjs.map","/**\n * Composing two contravariant functors yields a Covariant functor.\n *\n * Returns a default `map` composition.\n *\n * @since 1.0.0\n */\nexport const contramapComposition = (F, G) => f => F.contramap(G.contramap(f));\n/**\n * Returns a default `imap` implementation.\n *\n * @since 1.0.0\n */\nexport const imap = contramap => (_, from) => contramap(from);\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const make = contramap => ({\n  contramap,\n  imap: imap(contramap)\n});\n//# sourceMappingURL=Contravariant.mjs.map","/**\n * @since 1.0.0\n */\nimport { constFalse, constTrue, pipe } from \"@fp-ts/core/Function\";\nimport * as readonlyArray from \"@fp-ts/core/internal/ReadonlyArray\";\nimport * as contravariant from \"@fp-ts/core/typeclass/Contravariant\";\nimport * as invariant from \"@fp-ts/core/typeclass/Invariant\";\nimport * as monoid from \"@fp-ts/core/typeclass/Monoid\";\nimport * as of_ from \"@fp-ts/core/typeclass/Of\";\nimport * as product_ from \"@fp-ts/core/typeclass/Product\";\nimport * as semiProduct from \"@fp-ts/core/typeclass/SemiProduct\";\n/**\n * @category guards\n * @since 1.0.0\n */\nexport const isString = u => typeof u === \"string\";\n/**\n * @category guards\n * @since 1.0.0\n */\nexport const isNumber = u => typeof u === \"number\";\n/**\n * @category guards\n * @since 1.0.0\n */\nexport const isBoolean = u => typeof u === \"boolean\";\n/**\n * @category guards\n * @since 1.0.0\n */\nexport const isBigInt = u => typeof u === \"bigint\";\n/**\n * @category guards\n * @since 1.0.0\n */\nexport const isSymbol = u => typeof u === \"symbol\";\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const id = () => _ => true;\n/**\n * @since 1.0.0\n */\nexport const compose = bc => ab => i => ab(i) && bc(i);\n/**\n * @since 1.0.0\n */\nexport const contramap = f => self => b => self(f(b));\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Contravariant = /*#__PURE__*/contravariant.make(contramap);\n/**\n * @since 1.0.0\n */\nexport const imap = Contravariant.imap;\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Invariant = {\n  imap\n};\n/**\n * @since 1.0.0\n */\n// @ts-expect-error\nexport const tupled = /*#__PURE__*/invariant.tupled(Invariant);\n/**\n * @category do notation\n * @since 1.0.0\n */\nexport const bindTo = /*#__PURE__*/invariant.bindTo(Invariant);\n/**\n * @since 1.0.0\n */\nexport const of = _ => id();\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Of = {\n  of\n};\n/**\n * @since 1.0.0\n */\nexport const Do = /*#__PURE__*/of_.Do(Of);\n/**\n * @since 1.0.0\n */\nexport const unit = /*#__PURE__*/of_.unit(Of);\nconst productMany = (self, collection) => {\n  return ([head, ...tail]) => {\n    if (self(head) === false) {\n      return false;\n    }\n    const predicates = readonlyArray.fromIterable(collection);\n    for (let i = 0; i < predicates.length; i++) {\n      if (predicates[i](tail[i]) === false) {\n        return false;\n      }\n    }\n    return true;\n  };\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const SemiProduct = {\n  imap,\n  product: (self, that) => ([a, b]) => self(a) && that(b),\n  productMany\n};\nconst productAll = collection => as => {\n  const predicates = readonlyArray.fromIterable(collection);\n  for (let i = 0; i < predicates.length; i++) {\n    if (predicates[i](as[i]) === false) {\n      return false;\n    }\n  }\n  return true;\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Product = {\n  ...SemiProduct,\n  of,\n  productAll\n};\n/**\n * @since 1.0.0\n */\nexport const andThenBind = /*#__PURE__*/semiProduct.andThenBind(SemiProduct);\n/**\n * Adds an element to the end of a tuple.\n *\n * @since 1.0.0\n */\nexport const element = /*#__PURE__*/semiProduct.element(SemiProduct);\n/**\n * @since 1.0.0\n */\nexport const tuple = /*#__PURE__*/product_.tuple(Product);\n/**\n * @since 1.0.0\n */\nexport const struct = /*#__PURE__*/product_.struct(Product);\n/**\n * @since 1.0.0\n */\nexport const not = self => a => !self(a);\n/**\n * @since 1.0.0\n */\nexport const or = that => self => a => self(a) || that(a);\n/**\n * @since 1.0.0\n */\nexport const and = that => self => a => self(a) && that(a);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const getSemigroupAny = () => ({\n  combine: (self, that) => pipe(self, or(that)),\n  combineMany: (self, collection) => a => {\n    if (self(a)) {\n      return true;\n    }\n    for (const p of collection) {\n      if (p(a)) {\n        return true;\n      }\n    }\n    return false;\n  }\n});\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const getMonoidAny = () => monoid.fromSemigroup(getSemigroupAny(), constFalse);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const getSemigroupAll = () => ({\n  combine: (self, that) => pipe(self, and(that)),\n  combineMany: (self, collection) => a => {\n    if (!self(a)) {\n      return false;\n    }\n    for (const p of collection) {\n      if (!p(a)) {\n        return false;\n      }\n    }\n    return true;\n  }\n});\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const getMonoidAll = () => monoid.fromSemigroup(getSemigroupAll(), constTrue);\n/**\n * @since 1.0.0\n */\nexport const all = collection => getMonoidAll().combineAll(collection);\n/**\n * @since 1.0.0\n */\nexport const any = collection => getMonoidAny().combineAll(collection);\n//# sourceMappingURL=Predicate.mjs.map","import * as contravariant from \"@fp-ts/core/typeclass/Contravariant\";\nimport * as monoid from \"@fp-ts/core/typeclass/Monoid\";\n/**\n * Return an `Equivalence` that uses strict equality (===) to compare values\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const strict = () => (x, y) => x === y;\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const string = /*#__PURE__*/strict();\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const number = /*#__PURE__*/strict();\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const boolean = /*#__PURE__*/strict();\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const bigint = /*#__PURE__*/strict();\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const symbol = /*#__PURE__*/strict();\n/**\n * Given a tuple of `Equivalence`s returns a new `Equivalence` that compares values of a tuple\n * by applying each `Equivalence` to the corresponding element of the tuple.\n *\n * @category constructors\n * @since 1.0.0\n */\nexport const tuple = (...equivalences) => (x, y) => equivalences.every((equivalence, i) => equivalence(x[i], y[i]));\n/**\n * Given an `Equivalence` of type `A`, returns a new `Equivalence` of type `ReadonlyArray<A>`.\n * The returned `Equivalence` compares arrays by first checking their length and then applying the provided `Equivalence` to each element.\n * If all comparisons return true, the arrays are considered equal.\n *\n * @category constructors\n * @since 1.0.0\n */\nexport const array = equivalence => (x, y) => x.length === y.length && x.every((a, i) => equivalence(a, y[i]));\n/**\n * Given a struct of `Equivalence`s returns a new `Equivalence` that compares values of a struct\n * by applying each `Equivalence` to the corresponding property of the struct.\n *\n * @category constructors\n * @since 1.0.0\n */\nexport const struct = equivalences => (x, y) => {\n  for (const key in equivalences) {\n    if (!equivalences[key](x[key], y[key])) {\n      return false;\n    }\n  }\n  return true;\n};\n/**\n * Given an `Equivalence` of type `A`, returns a new `Equivalence` of type `{ readonly [x: string]: A }`.\n * The returned `Equivalence` compares records by first checking their number of keys and then applying the provided `Equivalence` to each value.\n * If all comparisons return true, the records are considered equal.\n *\n * @category constructors\n * @since 1.0.0\n */\nexport const record = equivalence => (x, y) => {\n  const keys = Object.keys(x);\n  if (Object.keys(y).length !== keys.length) {\n    return false;\n  }\n  for (const key of keys) {\n    if (!equivalence(x[key], y[key])) {\n      return false;\n    }\n  }\n  return true;\n};\n/**\n * @category instances\n * @since 2.10.0\n */\nexport const getSemigroup = () => ({\n  combine: (self, that) => (x, y) => self(x, y) && that(x, y),\n  combineMany: (self, collection) => (x, y) => {\n    if (!self(x, y)) {\n      return false;\n    }\n    for (const equivalence of collection) {\n      if (!equivalence(x, y)) {\n        return false;\n      }\n    }\n    return true;\n  }\n});\nconst empty = () => true;\n/**\n * @category instances\n * @since 2.6.0\n */\nexport const getMonoid = () => monoid.fromSemigroup(getSemigroup(), empty);\n/**\n * @category combinators\n * @since 1.0.0\n */\nexport const contramap = f => self => (x, y) => self(f(x), f(y));\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Contravariant = /*#__PURE__*/contravariant.make(contramap);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Invariant = {\n  imap: Contravariant.imap\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const SemiProduct = {\n  imap: Contravariant.imap,\n  product: tuple,\n  productMany: (self, collection) => tuple(self, ...collection)\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Product = {\n  ...SemiProduct,\n  of: () => empty,\n  productAll: collection => tuple(...collection)\n};\n//# sourceMappingURL=Equivalence.mjs.map","import { fromIterable } from \"@fp-ts/core/internal/ReadonlyArray\";\n/**\n * Useful when `combineMany` can't be optimised.\n *\n * @category constructors\n * @since 1.0.0\n */\nexport const fromCombine = combine => ({\n  combine,\n  combineMany: (self, collection) => {\n    let out = self;\n    for (const a of collection) {\n      out = combine(out, a);\n    }\n    return out;\n  }\n});\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const string = /*#__PURE__*/fromCombine((self, that) => self + that);\n/**\n * `number` semigroup under addition.\n *\n * @category instances\n * @since 1.0.0\n */\nexport const numberSum = /*#__PURE__*/fromCombine((self, that) => self + that);\n/**\n * `number` semigroup under multiplication.\n *\n * @category instances\n * @since 1.0.0\n */\nexport const numberMultiply = {\n  combine: (self, that) => self * that,\n  combineMany: (self, collection) => {\n    if (self === 0) {\n      return 0;\n    }\n    let out = self;\n    for (const n of collection) {\n      if (n === 0) {\n        return 0;\n      }\n      out = out * n;\n    }\n    return out;\n  }\n};\n/**\n * `bigint` semigroup under addition.\n *\n * @category instances\n * @since 1.0.0\n */\nexport const bigintSum = /*#__PURE__*/fromCombine((self, that) => self + that);\n/**\n * `bigint` semigroup under multiplication.\n *\n * @category instances\n * @since 1.0.0\n */\nexport const bigintMultiply = {\n  combine: (self, that) => self * that,\n  combineMany: (self, collection) => {\n    if (self === 0n) {\n      return 0n;\n    }\n    let out = self;\n    for (const n of collection) {\n      if (n === 0n) {\n        return 0n;\n      }\n      out = out * n;\n    }\n    return out;\n  }\n};\n/**\n * `boolean` semigroup under conjunction.\n *\n * @category instances\n * @since 1.0.0\n */\nexport const booleanAll = {\n  combine: (self, that) => self && that,\n  combineMany: (self, collection) => {\n    if (self === false) {\n      return false;\n    }\n    for (const b of collection) {\n      if (b === false) {\n        return false;\n      }\n    }\n    return true;\n  }\n};\n/**\n * `boolean` semigroup under disjunction.\n *\n * @category instances\n * @since 1.0.0\n */\nexport const booleanAny = {\n  combine: (self, that) => self || that,\n  combineMany: (self, collection) => {\n    if (self === true) {\n      return true;\n    }\n    for (const b of collection) {\n      if (b === true) {\n        return true;\n      }\n    }\n    return false;\n  }\n};\n/**\n * This function creates and returns a new `Semigroup` for a tuple of values based on the given `Semigroup`s for each element in the tuple.\n * The returned `Semigroup` combines two tuples of the same type by applying the corresponding `Semigroup` passed as arguments to each element in the tuple.\n * It is useful when you need to combine two tuples of the same type and you have a specific way of combining each element of the tuple.\n *\n * @category combinators\n * @since 1.0.0\n */\nexport const tuple = (...semigroups) => fromCombine((self, that) => semigroups.map((S, i) => S.combine(self[i], that[i])));\n/**\n * Given a type `A`, this function creates and returns a `Semigroup` for `Array<A>`.\n * The returned `Semigroup` combines two arrays by concatenating them.\n *\n * @category combinators\n * @since 1.0.0\n */\nexport const array = () => fromCombine((self, that) => self.concat(that));\n/**\n * Given a type `A`, this function creates and returns a `Semigroup` for `ReadonlyArray<A>`.\n * The returned `Semigroup` combines two arrays by concatenating them.\n *\n * @category combinators\n * @since 1.0.0\n */\nexport const readonlyArray = array;\n/**\n * This function creates and returns a new `Semigroup` for a struct of values based on the given `Semigroup`s for each property in the struct.\n * The returned `Semigroup` combines two structs of the same type by applying the corresponding `Semigroup` passed as arguments to each property in the struct.\n * It is useful when you need to combine two structs of the same type and you have a specific way of combining each property of the struct.\n *\n * @category combinators\n * @since 1.0.0\n */\nexport const struct = semigroups => fromCombine((self, that) => {\n  const r = {};\n  for (const k in semigroups) {\n    if (Object.prototype.hasOwnProperty.call(semigroups, k)) {\n      r[k] = semigroups[k].combine(self[k], that[k]);\n    }\n  }\n  return r;\n});\n/**\n * `Semigroup` that returns last minimum of elements.\n *\n * @category constructors\n * @since 1.0.0\n */\nexport const min = O => fromCombine((self, that) => O.compare(self, that) === -1 ? self : that);\n/**\n * `Semigroup` that returns last maximum of elements.\n *\n * @category constructors\n * @since 1.0.0\n */\nexport const max = O => fromCombine((self, that) => O.compare(self, that) === 1 ? self : that);\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const constant = a => ({\n  combine: () => a,\n  combineMany: () => a\n});\n/**\n * The dual of a `Semigroup`, obtained by flipping the arguments of `combine`.\n *\n * @since 1.0.0\n */\nexport const reverse = S => ({\n  combine: (self, that) => S.combine(that, self),\n  combineMany: (self, collection) => {\n    const reversed = Array.from(collection).reverse();\n    return reversed.length > 0 ? S.combine(S.combineMany(reversed[0], reversed.slice(1)), self) : self;\n  }\n});\n/**\n * @since 1.0.0\n */\nexport const intercalate = separator => S => fromCombine((self, that) => S.combineMany(self, [separator, that]));\n/**\n * Always return the first argument.\n *\n * @category instances\n * @since 1.0.0\n */\nexport const first = () => ({\n  combine: a => a,\n  combineMany: a => a\n});\n/**\n * Always return the last argument.\n *\n * @category instances\n * @since 1.0.0\n */\nexport const last = () => ({\n  combine: (_, second) => second,\n  combineMany: (self, collection) => {\n    let a = self;\n    // eslint-disable-next-line no-empty\n    for (a of collection) {}\n    return a;\n  }\n});\n/**\n * @since 1.0.0\n */\nexport const imap = (to, from) => S => ({\n  combine: (self, that) => to(S.combine(from(self), from(that))),\n  combineMany: (self, collection) => to(S.combineMany(from(self), fromIterable(collection).map(from)))\n});\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Invariant = {\n  imap\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const SemiProduct = {\n  ...Invariant,\n  product: tuple,\n  productMany: (self, collection) => tuple(self, ...collection)\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Product = {\n  ...SemiProduct,\n  of: constant,\n  productAll: collection => tuple(...collection)\n};\n//# sourceMappingURL=Semigroup.mjs.map","import * as semigroup from \"@fp-ts/core/typeclass/Semigroup\";\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const fromSemigroup = (S, empty) => ({\n  ...S,\n  empty,\n  combineAll: collection => S.combineMany(empty, collection)\n});\n/**\n * Get a monoid where `combine` will return the minimum, based on the provided bounded order.\n *\n * The `empty` value is the `maxBound` value.\n *\n * @category constructors\n * @since 1.0.0\n */\nexport const min = B => fromSemigroup(semigroup.min(B), B.maxBound);\n/**\n * Get a monoid where `combine` will return the maximum, based on the provided bounded order.\n *\n * The `empty` value is the `minimum` value.\n *\n * @category constructors\n * @since 1.0.0\n */\nexport const max = B => fromSemigroup(semigroup.max(B), B.minBound);\n/**\n * The dual of a `Monoid`, obtained by swapping the arguments of `combine`.\n *\n * @category combinators\n * @since 1.0.0\n */\nexport const reverse = M => fromSemigroup(semigroup.reverse(M), M.empty);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const string = {\n  ...semigroup.string,\n  combineAll: collection => semigroup.string.combineMany(\"\", collection),\n  empty: \"\"\n};\n/**\n * `number` monoid under addition.\n *\n * The `empty` value is `0`.\n *\n * @category instances\n * @since 1.0.0\n */\nexport const numberSum = {\n  ...semigroup.numberSum,\n  combineAll: collection => semigroup.numberSum.combineMany(0, collection),\n  empty: 0\n};\n/**\n * `number` monoid under multiplication.\n *\n * The `empty` value is `1`.\n *\n * @category instances\n * @since 1.0.0\n */\nexport const numberMultiply = {\n  ...semigroup.numberMultiply,\n  combineAll: collection => semigroup.numberMultiply.combineMany(1, collection),\n  empty: 1\n};\n/**\n * `number` monoid under addition.\n *\n * The `bigint` value is `0n`.\n *\n * @category instances\n * @since 1.0.0\n */\nexport const bigintSum = {\n  ...semigroup.bigintSum,\n  combineAll: collection => semigroup.bigintSum.combineMany(0n, collection),\n  empty: 0n\n};\n/**\n * `bigint` monoid under multiplication.\n *\n * The `empty` value is `1n`.\n *\n * @category instances\n * @since 1.0.0\n */\nexport const bigintMultiply = {\n  ...semigroup.bigintMultiply,\n  combineAll: collection => semigroup.bigintMultiply.combineMany(1n, collection),\n  empty: 1n\n};\n/**\n * `boolean` monoid under conjunction.\n *\n * The `empty` value is `true`.\n *\n * @category instances\n * @since 1.0.0\n */\nexport const booleanAll = {\n  ...semigroup.booleanAll,\n  combineAll: collection => semigroup.booleanAll.combineMany(true, collection),\n  empty: true\n};\n/**\n * `boolean` monoid under disjunction.\n *\n * The `empty` value is `false`.\n *\n * @category instances\n * @since 1.0.0\n */\nexport const booleanAny = {\n  ...semigroup.booleanAny,\n  combineAll: collection => semigroup.booleanAny.combineMany(false, collection),\n  empty: false\n};\n/**\n * Given a tuple of `Monoid`s returns a `Monoid` for the tuple.\n *\n * @category combinators\n * @since 1.0.0\n */\nexport const tuple = (...monoids) => {\n  const empty = monoids.map(m => m.empty);\n  return fromSemigroup(semigroup.tuple(...monoids), empty);\n};\n/**\n * Given a type `A`, this function creates and returns a `Monoid` for `Array<A>`.\n * The returned `Monoid`'s empty value is the empty array.\n *\n * @category combinators\n * @since 1.0.0\n */\nexport const array = () => {\n  const S = semigroup.array();\n  return {\n    combine: S.combine,\n    combineMany: S.combineMany,\n    combineAll: collection => S.combineMany([], collection),\n    empty: []\n  };\n};\n/**\n * Given a type `A`, this function creates and returns a `Semigroup` for `ReadonlyArray<A>`.\n * The returned `Monoid`'s empty value is the empty array.\n *\n * @category combinators\n * @since 1.0.0\n */\nexport const readonlyArray = array;\n/**\n * Given a struct of `Monoid`s returns a `Monoid` for the struct.\n *\n * @category combinators\n * @since 1.0.0\n */\nexport const struct = monoids => {\n  const empty = {};\n  for (const k in monoids) {\n    if (Object.prototype.hasOwnProperty.call(monoids, k)) {\n      empty[k] = monoids[k].empty;\n    }\n  }\n  return fromSemigroup(semigroup.struct(monoids), empty);\n};\n//# sourceMappingURL=Monoid.mjs.map","import * as contravariant from \"@fp-ts/core/typeclass/Contravariant\";\nimport * as monoid from \"@fp-ts/core/typeclass/Monoid\";\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const string = {\n  compare: (self, that) => self < that ? -1 : self > that ? 1 : 0\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const number = {\n  compare: (self, that) => self < that ? -1 : self > that ? 1 : 0\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const boolean = {\n  compare: (self, that) => self < that ? -1 : self > that ? 1 : 0\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const bigint = {\n  compare: (self, that) => self < that ? -1 : self > that ? 1 : 0\n};\n/**\n * Main constructor.\n *\n * @category constructors\n * @since 1.0.0\n */\nexport const fromCompare = compare => ({\n  compare: (self, that) => self === that ? 0 : compare(self, that)\n});\n/**\n * This function creates and returns a new `Order` for a tuple of values based on the given `Order`s for each element in the tuple.\n * The returned `Order` compares two tuples of the same type by applying the corresponding `Order` to each element in the tuple.\n * It is useful when you need to compare two tuples of the same type and you have a specific way of comparing each element\n * of the tuple.\n *\n * @category combinators\n * @since 1.0.0\n */\nexport const tuple = (...orders) => fromCompare((self, that) => {\n  let i = 0;\n  for (; i < orders.length - 1; i++) {\n    const r = orders[i].compare(self[i], that[i]);\n    if (r !== 0) {\n      return r;\n    }\n  }\n  return orders[i].compare(self[i], that[i]);\n});\n/**\n * This function creates and returns a new `Order` for an array of values based on a given `Order` for the elements of the array.\n * The returned `Order` compares two arrays by applying the given `Order` to each element in the arrays.\n * If all elements are equal, the arrays are then compared based on their length.\n * It is useful when you need to compare two arrays of the same type and you have a specific way of comparing each element of the array.\n *\n * @category combinators\n * @since 1.0.0\n */\nexport const array = O => fromCompare((self, that) => {\n  const aLen = self.length;\n  const bLen = that.length;\n  const len = Math.min(aLen, bLen);\n  for (let i = 0; i < len; i++) {\n    const o = O.compare(self[i], that[i]);\n    if (o !== 0) {\n      return o;\n    }\n  }\n  return number.compare(aLen, bLen);\n});\n/**\n * This function creates and returns a new `Order` for a struct of values based on the given `Order`s\n * for each property in the struct.\n *\n * @category combinators\n * @since 1.0.0\n */\nexport const struct = orders => ({\n  compare: (self, that) => {\n    for (const key of Object.keys(orders)) {\n      const o = orders[key].compare(self[key], that[key]);\n      if (o !== 0) {\n        return o;\n      }\n    }\n    return 0;\n  }\n});\n/**\n * @since 1.0.0\n */\nexport const reverse = O => fromCompare((self, that) => O.compare(that, self));\n/**\n * @since 1.0.0\n */\nexport const contramap = f => self => fromCompare((b1, b2) => self.compare(f(b1), f(b2)));\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const getSemigroup = () => ({\n  combine: (O1, O2) => fromCompare((self, that) => {\n    const out = O1.compare(self, that);\n    if (out !== 0) {\n      return out;\n    }\n    return O2.compare(self, that);\n  }),\n  combineMany: (self, collection) => fromCompare((a1, a2) => {\n    let out = self.compare(a1, a2);\n    if (out !== 0) {\n      return out;\n    }\n    for (const O of collection) {\n      out = O.compare(a1, a2);\n      if (out !== 0) {\n        return out;\n      }\n    }\n    return out;\n  })\n});\nconst empty = /*#__PURE__*/fromCompare(() => 0);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const getMonoid = () => monoid.fromSemigroup(getSemigroup(), empty);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Contravariant = /*#__PURE__*/contravariant.make(contramap);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Invariant = {\n  imap: Contravariant.imap\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const SemiProduct = {\n  imap: Contravariant.imap,\n  product: tuple,\n  productMany: (self, collection) => tuple(self, ...collection)\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Product = {\n  ...SemiProduct,\n  of: () => empty,\n  productAll: collection => tuple(...collection)\n};\n/**\n * Test whether one value is _strictly less than_ another.\n *\n * @since 1.0.0\n */\nexport const lessThan = O => that => self => O.compare(self, that) === -1;\n/**\n * Test whether one value is _strictly greater than_ another.\n *\n * @since 1.0.0\n */\nexport const greaterThan = O => that => self => O.compare(self, that) === 1;\n/**\n * Test whether one value is _non-strictly less than_ another.\n *\n * @since 1.0.0\n */\nexport const lessThanOrEqualTo = O => that => self => O.compare(self, that) !== 1;\n/**\n * Test whether one value is _non-strictly greater than_ another.\n *\n * @since 1.0.0\n */\nexport const greaterThanOrEqualTo = O => that => self => O.compare(self, that) !== -1;\n/**\n * Take the minimum of two values. If they are considered equal, the first argument is chosen.\n *\n * @since 1.0.0\n */\nexport const min = O => that => self => self === that || O.compare(self, that) < 1 ? self : that;\n/**\n * Take the maximum of two values. If they are considered equal, the first argument is chosen.\n *\n * @since 1.0.0\n */\nexport const max = O => that => self => self === that || O.compare(self, that) > -1 ? self : that;\n/**\n * Clamp a value between a minimum and a maximum.\n *\n * @since 1.0.0\n */\nexport const clamp = O => (minimum, maximum) => a => min(O)(max(O)(a)(minimum))(maximum);\n/**\n * Test whether a value is between a minimum and a maximum (inclusive).\n *\n * @since 1.0.0\n */\nexport const between = O => (minimum, maximum) => a => !lessThan(O)(minimum)(a) && !greaterThan(O)(maximum)(a);\n//# sourceMappingURL=Order.mjs.map","/**\n * This module provides utility functions and type class instances for working with the `string` type in TypeScript.\n * It includes functions for basic string manipulation, as well as type class instances for\n * `Equivalence`, `Order`, `Semigroup`, and `Monoid`.\n *\n * @since 1.0.0\n */\nimport * as readonlyArray from \"@fp-ts/core/internal/ReadonlyArray\";\nimport * as predicate from \"@fp-ts/core/Predicate\";\nimport * as equivalence from \"@fp-ts/core/typeclass/Equivalence\";\nimport * as monoid from \"@fp-ts/core/typeclass/Monoid\";\nimport * as order from \"@fp-ts/core/typeclass/Order\";\nimport * as semigroup from \"@fp-ts/core/typeclass/Semigroup\";\n/**\n * @category guards\n * @since 1.0.0\n */\nexport const isString = predicate.isString;\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Equivalence = equivalence.string;\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Order = order.string;\n/**\n * `string` semigroup under concatenation.\n *\n * @category instances\n * @since 1.0.0\n */\nexport const Semigroup = semigroup.string;\n/**\n * `string` monoid under concatenation.\n *\n * The `empty` value is `''`.\n *\n * @category instances\n * @since 1.0.0\n */\nexport const Monoid = monoid.string;\n/**\n * @since 1.0.0\n */\nexport const empty = \"\";\n/**\n * @since 1.0.0\n */\nexport const concat = that => self => Semigroup.combine(self, that);\n/**\n * @example\n * import * as S from '@fp-ts/core/String'\n * import { pipe } from '@fp-ts/core/Function'\n *\n * assert.deepStrictEqual(pipe('a', S.toUpperCase), 'A')\n *\n * @since 1.0.0\n */\nexport const toUpperCase = s => s.toUpperCase();\n/**\n * @example\n * import * as S from '@fp-ts/core/String'\n * import { pipe } from '@fp-ts/core/Function'\n *\n * assert.deepStrictEqual(pipe('A', S.toLowerCase), 'a')\n *\n * @since 1.0.0\n */\nexport const toLowerCase = s => s.toLowerCase();\n/**\n * @example\n * import * as S from '@fp-ts/core/String'\n * import { pipe } from '@fp-ts/core/Function'\n *\n * assert.deepStrictEqual(pipe('abc', S.replace('b', 'd')), 'adc')\n *\n * @since 1.0.0\n */\nexport const replace = (searchValue, replaceValue) => s => s.replace(searchValue, replaceValue);\n/**\n * @example\n * import * as S from '@fp-ts/core/String'\n * import { pipe } from '@fp-ts/core/Function'\n *\n * assert.deepStrictEqual(pipe(' a ', S.trim), 'a')\n *\n * @since 1.0.0\n */\nexport const trim = s => s.trim();\n/**\n * @example\n * import * as S from '@fp-ts/core/String'\n * import { pipe } from '@fp-ts/core/Function'\n *\n * assert.deepStrictEqual(pipe(' a ', S.trimStart), 'a ')\n *\n * @since 1.0.0\n */\nexport const trimStart = s => s.trimStart();\n/**\n * @example\n * import * as S from '@fp-ts/core/String'\n * import { pipe } from '@fp-ts/core/Function'\n *\n * assert.deepStrictEqual(pipe(' a ', S.trimEnd), ' a')\n *\n * @since 1.0.0\n */\nexport const trimEnd = s => s.trimEnd();\n/**\n * @example\n * import * as S from '@fp-ts/core/String'\n * import { pipe } from '@fp-ts/core/Function'\n *\n * assert.deepStrictEqual(pipe('abcd', S.slice(1, 3)), 'bc')\n *\n * @since 1.0.0\n */\nexport const slice = (start, end) => s => s.slice(start, end);\n/**\n * Test whether a `string` is empty.\n *\n * @example\n * import * as S from '@fp-ts/core/String'\n * import { pipe } from '@fp-ts/core/Function'\n *\n * assert.deepStrictEqual(pipe('', S.isEmpty), true)\n * assert.deepStrictEqual(pipe('a', S.isEmpty), false)\n *\n * @since 1.0.0\n */\nexport const isEmpty = s => s.length === 0;\n/**\n * Test whether a `string` is non empty.\n *\n * @since 1.0.0\n */\nexport const isNonEmpty = s => s.length > 0;\n/**\n * Calculate the number of characters in a `string`.\n *\n * @example\n * import * as S from '@fp-ts/core/String'\n * import { pipe } from '@fp-ts/core/Function'\n *\n * assert.deepStrictEqual(pipe('abc', S.length), 3)\n *\n * @since 1.0.0\n */\nexport const length = s => s.length;\n/**\n * @example\n * import * as S from '@fp-ts/core/String'\n * import { pipe } from '@fp-ts/core/Function'\n *\n * assert.deepStrictEqual(pipe('abc', S.split('')), ['a', 'b', 'c'])\n * assert.deepStrictEqual(pipe('', S.split('')), [''])\n *\n * @since 1.0.0\n */\nexport const split = separator => s => {\n  const out = s.split(separator);\n  return readonlyArray.isNonEmpty(out) ? out : [s];\n};\n/**\n * @example\n * import * as S from '@fp-ts/core/String'\n * import { pipe } from '@fp-ts/core/Function'\n *\n * assert.deepStrictEqual(pipe('abc', S.includes('b')), true)\n * assert.deepStrictEqual(pipe('abc', S.includes('d')), false)\n *\n * @since 1.0.0\n */\nexport const includes = (searchString, position) => s => s.includes(searchString, position);\n/**\n * @example\n * import * as S from '@fp-ts/core/String'\n * import { pipe } from '@fp-ts/core/Function'\n *\n * assert.deepStrictEqual(pipe('abc', S.startsWith('a')), true)\n * assert.deepStrictEqual(pipe('bc', S.startsWith('a')), false)\n *\n * @since 1.0.0\n */\nexport const startsWith = (searchString, position) => s => s.startsWith(searchString, position);\n/**\n * @example\n * import * as S from '@fp-ts/core/String'\n * import { pipe } from '@fp-ts/core/Function'\n *\n * assert.deepStrictEqual(pipe('abc', S.endsWith('c')), true)\n * assert.deepStrictEqual(pipe('ab', S.endsWith('c')), false)\n *\n * @since 1.0.0\n */\nexport const endsWith = (searchString, position) => s => s.endsWith(searchString, position);\n/**\n * Keep the specified number of characters from the start of a string.\n *\n * If `n` is larger than the available number of characters, the string will\n * be returned whole.\n *\n * If `n` is not a positive number, an empty string will be returned.\n *\n * If `n` is a float, it will be rounded down to the nearest integer.\n *\n * @since 1.0.0\n */\nexport const takeLeft = n => self => self.slice(0, Math.max(n, 0));\n/**\n * Keep the specified number of characters from the end of a string.\n *\n * If `n` is larger than the available number of characters, the string will\n * be returned whole.\n *\n * If `n` is not a positive number, an empty string will be returned.\n *\n * If `n` is a float, it will be rounded down to the nearest integer.\n *\n * @since 1.0.0\n */\nexport const takeRight = n => s => s.slice(Math.max(0, s.length - Math.floor(n)), Infinity);\n/*\n\n  Missing:\n\n  - charCodeAt\n  - substring\n  - at\n  - charAt\n  - codePointAt\n  - indexOf\n  - lastIndexOf\n  - localeCompare\n  - match\n  - matchAll\n  - normalize\n  - padEnd\n  - padStart\n  - repeat\n  - replaceAll\n  - search\n  - toLocaleLowerCase\n  - toLocaleUpperCase\n*/\n// TODO: 100% coverage tests (ask Max)\n// const CR = 0x0d\n// const LF = 0x0a\n// /**\n//  * Returns an `IterableIterator` which yields each line contained within the\n//  * string, trimming off the trailing newline character.\n//  *\n//  * @since 1.0.0\n//  */\n// // export const linesIterator = (self: string): LinesIterator => linesSeparated(self, true)\n// /**\n//  * Returns an `IterableIterator` which yields each line contained within the\n//  * string as well as the trailing newline character.\n//  *\n//  * @since 1.0.0\n//  */\n// export const linesWithSeparators = (s: string): LinesIterator => linesSeparated(s, false)\n// /**\n//  * For every line in this string, strip a leading prefix consisting of blanks\n//  * or control characters followed by the character specified by `marginChar`\n//  * from the line.\n//  *\n//  * @since 1.0.0\n//  */\n// export const stripMarginWith = (marginChar: string) =>\n//   (self: string): string => {\n//     let out = \"\"\n//     for (const line of linesWithSeparators(self)) {\n//       let index = 0\n//       while (index < line.length && line.charAt(index) <= \" \") {\n//         index = index + 1\n//       }\n//       const stripped = index < line.length && line.charAt(index) === marginChar\n//         ? line.substring(index + 1)\n//         : line\n//       out = out + stripped\n//     }\n//     return out\n//   }\n// /**\n//  * For every line in this string, strip a leading prefix consisting of blanks\n//  * or control characters followed by the `\"|\"` character from the line.\n//  *\n//  * @since 1.0.0\n//  */\n// export const stripMargin = (self: string): string => stripMarginWith(\"|\")(self)\n// class LinesIterator implements IterableIterator<string> {\n//   private index: number\n//   private readonly length: number\n//   constructor(readonly s: string, readonly stripped: boolean = false) {\n//     this.index = 0\n//     this.length = s.length\n//   }\n//   next(): IteratorResult<string> {\n//     if (this.done) {\n//       return { done: true, value: undefined }\n//     }\n//     const start = this.index\n//     while (!this.done && !isLineBreak(this.s[this.index]!)) {\n//       this.index = this.index + 1\n//     }\n//     let end = this.index\n//     if (!this.done) {\n//       const char = this.s[this.index]!\n//       this.index = this.index + 1\n//       if (!this.done && isLineBreak2(char, this.s[this.index]!)) {\n//         this.index = this.index + 1\n//       }\n//       if (!this.stripped) {\n//         end = this.index\n//       }\n//     }\n//     return { done: false, value: this.s.substring(start, end) }\n//   }\n//   [Symbol.iterator](): IterableIterator<string> {\n//     return new LinesIterator(this.s, this.stripped)\n//   }\n//   private get done(): boolean {\n//     return this.index >= this.length\n//   }\n// }\n// /**\n//  * Test if the provided character is a line break character (i.e. either `\"\\r\"`\n//  * or `\"\\n\"`).\n//  */\n// const isLineBreak = (char: string): boolean => {\n//   const code = char.charCodeAt(0)\n//   return code === CR || code === LF\n// }\n// /**\n//  * Test if the provided characters combine to form a carriage return/line-feed\n//  * (i.e. `\"\\r\\n\"`).\n//  */\n// const isLineBreak2 = (char0: string, char1: string): boolean =>\n//   char0.charCodeAt(0) === CR && char1.charCodeAt(0) === LF\n// const linesSeparated = (self: string, stripped: boolean): LinesIterator =>\n//   new LinesIterator(self, stripped)\n//# sourceMappingURL=String.mjs.map","/**\n * @since 1.0.0\n */\nimport { pipe } from \"@fp-ts/core/Function\";\n/**\n * Returns a default `product` composition.\n *\n * @since 1.0.0\n */\nexport const productComposition = (F, G) => (self, that) => pipe(F.product(self, that), F.map(([ga, gb]) => G.product(ga, gb)));\n/**\n * Returns a default `productMany` composition.\n *\n * @since 1.0.0\n */\nexport const productManyComposition = (F, G) => (self, collection) => pipe(F.productMany(self, collection), F.map(([ga, ...gas]) => G.productMany(ga, gas)));\n/**\n * Returns a default `productMany` implementation (useful for tests).\n *\n * @category constructors\n * @since 1.0.0\n */\nexport const productMany = (Covariant, product) => (self, collection) => {\n  let out = pipe(self, Covariant.map(a => [a]));\n  for (const fa of collection) {\n    out = pipe(product(out, fa), Covariant.map(([[head, ...tail], a]) => [head, ...tail, a]));\n  }\n  return out;\n};\n/**\n * @since 1.0.0\n */\nexport const andThenBind = F => (name, that) => self => pipe(F.product(self, that), F.imap(([a, b]) => Object.assign({}, a, {\n  [name]: b\n}), ({\n  [name]: b,\n  ...rest\n}) => [rest, b]));\n/**\n * Adds an element to the end of a tuple.\n *\n * @since 1.0.0\n */\nexport const element = F => that => self => pipe(F.product(self, that), F.imap(([a, b]) => [...a, b], ab => [ab.slice(0, -1), ab[ab.length - 1]]));\n/**\n * @since 1.0.0\n */\nexport const nonEmptyTuple = F => (...components) => F.productMany(components[0], components.slice(1));\n/**\n * @since 1.0.0\n */\nexport const nonEmptyStruct = F => fields => {\n  const keys = Object.keys(fields);\n  return pipe(F.productMany(fields[keys[0]], keys.slice(1).map(k => fields[k])), F.imap(([value, ...values]) => {\n    const out = {\n      [keys[0]]: value\n    };\n    for (let i = 0; i < values.length; i++) {\n      out[keys[i + 1]] = values[i];\n    }\n    return out;\n  }, r => keys.map(k => r[k])));\n};\n//# sourceMappingURL=SemiProduct.mjs.map","import * as E from \"@fp-ts/core/Either\";\nimport { pipe } from \"@fp-ts/core/Function\";\nimport * as O from \"@fp-ts/core/Option\";\nimport * as compactable from \"@fp-ts/core/typeclass/Compactable\";\n/**\n * Returns a default `traversePartitionMap` implementation.\n *\n * @since 1.0.0\n */\nexport const traversePartitionMap = T => F => f => ta => pipe(ta, T.traverse(F)(f), F.map(compactable.separate(T)));\n/**\n * Returns a default `traverseFilterMap` implementation.\n *\n * @since 1.0.0\n */\nexport const traverseFilterMap = T => F => f => ta => pipe(ta, T.traverse(F)(f), F.map(T.compact));\n/**\n * @since 1.0.0\n */\nexport const traverseFilter = T => F => predicate => T.traverseFilterMap(F)(b => pipe(predicate(b), F.map(keep => keep ? O.some(b) : O.none())));\n/**\n * @since 1.0.0\n */\nexport const traversePartition = T => F => predicate => T.traversePartitionMap(F)(b => pipe(predicate(b), F.map(keep => keep ? E.right(b) : E.left(b))));\n//# sourceMappingURL=TraversableFilterable.mjs.map","import { identity, pipe } from \"@fp-ts/core/Function\";\nimport * as either from \"@fp-ts/core/internal/Either\";\nimport * as option from \"@fp-ts/core/internal/Option\";\nimport * as readonlyArray from \"@fp-ts/core/internal/ReadonlyArray\";\nimport * as O from \"@fp-ts/core/Option\";\nimport * as string from \"@fp-ts/core/String\";\nimport * as applicative from \"@fp-ts/core/typeclass/Applicative\";\nimport * as chainable from \"@fp-ts/core/typeclass/Chainable\";\nimport * as covariant from \"@fp-ts/core/typeclass/Covariant\";\nimport * as filterable from \"@fp-ts/core/typeclass/Filterable\";\nimport * as flatMap_ from \"@fp-ts/core/typeclass/FlatMap\";\nimport * as foldable from \"@fp-ts/core/typeclass/Foldable\";\nimport * as invariant from \"@fp-ts/core/typeclass/Invariant\";\nimport * as monoid from \"@fp-ts/core/typeclass/Monoid\";\nimport * as of_ from \"@fp-ts/core/typeclass/Of\";\nimport * as order from \"@fp-ts/core/typeclass/Order\";\nimport * as semiApplicative from \"@fp-ts/core/typeclass/SemiApplicative\";\nimport * as semigroup from \"@fp-ts/core/typeclass/Semigroup\";\nimport { fromCombine } from \"@fp-ts/core/typeclass/Semigroup\";\nimport * as semiProduct from \"@fp-ts/core/typeclass/SemiProduct\";\nimport * as traversable from \"@fp-ts/core/typeclass/Traversable\";\nimport * as traversableFilterable from \"@fp-ts/core/typeclass/TraversableFilterable\";\n/**\n * Builds a `NonEmptyArray` from an non-empty collection of elements.\n *\n * @category constructors\n * @since 1.0.0\n */\nexport const make = (...elements) => elements;\n/**\n * Return a `NonEmptyArray` of length `n` with element `i` initialized with `f(i)`.\n *\n * **Note**. `n` is normalized to an integer >= 1.\n *\n * @category constructors\n * @since 1.0.0\n */\nexport const makeBy = f => n => {\n  const max = Math.max(1, Math.floor(n));\n  const out = [f(0)];\n  for (let i = 1; i < max; i++) {\n    out.push(f(i));\n  }\n  return out;\n};\n/**\n * Return a `NonEmptyArray` containing a range of integers, including both endpoints.\n *\n * @category constructors\n * @since 1.0.0\n */\nexport const range = (start, end) => start <= end ? makeBy(i => start + i)(end - start + 1) : [start];\n/**\n * Return a `NonEmptyArray` containing a value repeated the specified number of times.\n *\n * **Note**. `n` is normalized to an integer >= 1.\n *\n * @category constructors\n * @since 1.0.0\n */\nexport const replicate = a => makeBy(() => a);\n/**\n * @category conversions\n * @since 1.0.0\n */\nexport const fromIterable = readonlyArray.fromIterable;\n/**\n * @category conversions\n * @since 1.0.0\n */\nexport const fromOption = self => option.isNone(self) ? [] : [self.value];\n/**\n * @category conversions\n * @since 1.0.0\n */\nexport const fromEither = self => either.isLeft(self) ? [] : [self.right];\n/**\n * @category pattern matching\n * @since 1.0.0\n */\nexport const match = (onEmpty, onNonEmpty) => self => isNonEmpty(self) ? onNonEmpty(headNonEmpty(self), tailNonEmpty(self)) : onEmpty();\n/**\n * @category pattern matching\n * @since 1.0.0\n */\nexport const matchRight = (onEmpty, onNonEmpty) => self => isNonEmpty(self) ? onNonEmpty(initNonEmpty(self), lastNonEmpty(self)) : onEmpty();\n/**\n * Prepend an element to the front of an `Iterable`, creating a new `NonEmptyArray`.\n *\n * @since 1.0.0\n */\nexport const prepend = head => self => [head, ...self];\n/**\n * @since 1.0.0\n */\nexport const prependAll = that => self => fromIterable(that).concat(fromIterable(self));\nexport function prependAllNonEmpty(that) {\n  return prependAll(that);\n}\n/**\n * Append an element to the end of an `Iterable`, creating a new `NonEmptyArray`.\n *\n * @since 1.0.0\n */\nexport const append = last => self => [...self, last];\n/**\n * @since 1.0.0\n */\nexport const appendAll = that => self => fromIterable(self).concat(fromIterable(that));\nexport function appendAllNonEmpty(that) {\n  return appendAll(that);\n}\n/**\n * Fold an `Iterable` from the left, keeping all intermediate results instead of only the final result.\n *\n * @category folding\n * @since 1.0.0\n */\nexport const scan = (b, f) => self => {\n  const out = [b];\n  let i = 0;\n  for (const a of self) {\n    out[i + 1] = f(out[i], a);\n    i++;\n  }\n  return out;\n};\n/**\n * Fold an `Iterable` from the right, keeping all intermediate results instead of only the final result.\n *\n * @category folding\n * @since 1.0.0\n */\nexport const scanRight = (b, f) => self => {\n  const input = fromIterable(self);\n  const out = new Array(input.length + 1);\n  out[input.length] = b;\n  for (let i = input.length - 1; i >= 0; i--) {\n    out[i] = f(out[i + 1], input[i]);\n  }\n  return out;\n};\n/**\n * Test whether a `ReadonlyArray` is empty narrowing down the type to `[]`.\n *\n * @category predicates\n * @since 1.0.0\n */\nexport const isEmpty = self => self.length === 0;\n/**\n * Test whether a `ReadonlyArray` is non empty narrowing down the type to `NonEmptyReadonlyArray<A>`.\n *\n * @category predicates\n * @since 1.0.0\n */\nexport const isNonEmpty = readonlyArray.isNonEmpty;\n/**\n * Return the number of elements in a `ReadonlyArray`.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const length = self => self.length;\nconst isOutOfBound = (i, as) => i < 0 || i >= as.length;\nconst clamp = (i, as) => Math.floor(Math.min(Math.max(0, i), as.length));\n/**\n * This function provides a safe way to read a value at a particular index from a `ReadonlyArray`.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const get = index => self => {\n  const i = Math.floor(index);\n  return isOutOfBound(i, self) ? option.none : option.some(self[i]);\n};\n/**\n * Return a tuple containing the first element, and a new `Array` of the remaining elements, if any.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const unprepend = self => [headNonEmpty(self), tailNonEmpty(self)];\n/**\n * Return a tuple containing a copy of the `NonEmptyReadonlyArray` without its last element, and that last element.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const unappend = self => [initNonEmpty(self), lastNonEmpty(self)];\n/**\n * Get the first element of a `ReadonlyArray`, or `None` if the `ReadonlyArray` is empty.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const head = /*#__PURE__*/get(0);\n/**\n * Gets an element unsafely, will throw on out of bounds.\n *\n * @since 1.0.0\n * @category unsafe\n */\nexport const unsafeGet = index => self => {\n  const i = Math.floor(index);\n  if (isOutOfBound(i, self)) {\n    throw new Error(`Index ${i} out of bounds`);\n  }\n  return self[i];\n};\n/**\n * @category getters\n * @since 1.0.0\n */\nexport const headNonEmpty = /*#__PURE__*/unsafeGet(0);\n/**\n * Get the last element in a `ReadonlyArray`, or `None` if the `ReadonlyArray` is empty.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const last = self => isNonEmpty(self) ? option.some(lastNonEmpty(self)) : option.none;\n/**\n * @category getters\n * @since 1.0.0\n */\nexport const lastNonEmpty = as => as[as.length - 1];\n/**\n * Get all but the first element of an `Iterable`, creating a new `Array`, or `None` if the `Iterable` is empty.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const tail = self => {\n  const input = fromIterable(self);\n  return isNonEmpty(input) ? option.some(tailNonEmpty(input)) : option.none;\n};\n/**\n * @category getters\n * @since 1.0.0\n */\nexport const tailNonEmpty = self => self.slice(1);\n/**\n * Get all but the last element of an `Iterable`, creating a new `Array`, or `None` if the `Iterable` is empty.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const init = self => {\n  const input = fromIterable(self);\n  return isNonEmpty(input) ? option.some(initNonEmpty(input)) : option.none;\n};\n/**\n * Get all but the last element of a non empty array, creating a new array.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const initNonEmpty = self => self.slice(0, -1);\n/**\n * Keep only a max number of elements from the start of an `Iterable`, creating a new `Array`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const take = n => self => {\n  const input = fromIterable(self);\n  return input.slice(0, clamp(n, input));\n};\n/**\n * Keep only a max number of elements from the end of an `Iterable`, creating a new `Array`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const takeRight = n => self => {\n  const input = fromIterable(self);\n  const i = clamp(n, input);\n  return i === 0 ? [] : input.slice(-i);\n};\nexport function takeWhile(predicate) {\n  return self => {\n    const out = [];\n    for (const a of self) {\n      if (!predicate(a)) {\n        break;\n      }\n      out.push(a);\n    }\n    return out;\n  };\n}\nconst spanIndex = (self, predicate) => {\n  let i = 0;\n  for (const a of self) {\n    if (!predicate(a)) {\n      break;\n    }\n    i++;\n  }\n  return i;\n};\nexport function span(predicate) {\n  return self => splitAt(spanIndex(self, predicate))(self);\n}\n/**\n * Drop a max number of elements from the start of an `Iterable`, creating a new `Array`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const drop = n => self => {\n  const input = fromIterable(self);\n  return input.slice(clamp(n, input), input.length);\n};\n/**\n * Drop a max number of elements from the end of an `Iterable`, creating a new `Array`.\n *\n * **Note**. `n` is normalized to a non negative integer.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const dropRight = n => self => {\n  const input = fromIterable(self);\n  return input.slice(0, input.length - clamp(n, input));\n};\nexport function dropWhile(predicate) {\n  return self => fromIterable(self).slice(spanIndex(self, predicate));\n}\n/**\n * Return the first index for which a predicate holds.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const findFirstIndex = predicate => self => {\n  let i = 0;\n  for (const a of self) {\n    if (predicate(a)) {\n      return option.some(i);\n    }\n    i++;\n  }\n  return option.none;\n};\n/**\n * Return the last index for which a predicate holds.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const findLastIndex = predicate => self => {\n  const input = fromIterable(self);\n  for (let i = input.length - 1; i >= 0; i--) {\n    if (predicate(input[i])) {\n      return option.some(i);\n    }\n  }\n  return option.none;\n};\nexport function findFirst(predicate) {\n  return self => {\n    const input = fromIterable(self);\n    for (let i = 0; i < input.length; i++) {\n      if (predicate(input[i])) {\n        return option.some(input[i]);\n      }\n    }\n    return option.none;\n  };\n}\nexport function findLast(predicate) {\n  return self => {\n    const input = fromIterable(self);\n    for (let i = input.length - 1; i >= 0; i--) {\n      if (predicate(input[i])) {\n        return option.some(input[i]);\n      }\n    }\n    return option.none;\n  };\n}\n/**\n * Insert an element at the specified index, creating a new `NonEmptyArray`,\n * or return `None` if the index is out of bounds.\n *\n * @since 1.0.0\n */\nexport const insertAt = (i, b) => self => {\n  const out = Array.from(self);\n  //             v--- `= self.length` ok, it means inserting in last position\n  if (i < 0 || i > out.length) {\n    return option.none;\n  }\n  out.splice(i, 0, b);\n  return option.some(out);\n};\n/**\n * Change the element at the specified index, creating a new `Array`,\n * or return a copy of the input if the index is out of bounds.\n *\n * @since 1.0.0\n */\nexport const replace = (i, b) => modify(i, () => b);\n/**\n * @since 1.0.0\n */\nexport const replaceOption = (i, b) => modifyOption(i, () => b);\n/**\n * Apply a function to the element at the specified index, creating a new `Array`,\n * or return a copy of the input if the index is out of bounds.\n *\n * @since 1.0.0\n */\nexport const modify = (i, f) => self => pipe(modifyOption(i, f)(self), O.getOrElse(() => Array.from(self)));\n/**\n * Apply a function to the element at the specified index, creating a new `Array`,\n * or return `None` if the index is out of bounds.\n *\n * @since 1.0.0\n */\nexport const modifyOption = (i, f) => self => {\n  const out = Array.from(self);\n  if (isOutOfBound(i, out)) {\n    return O.none();\n  }\n  const next = f(out[i]);\n  // @ts-expect-error\n  out[i] = next;\n  return O.some(out);\n};\n/**\n * Delete the element at the specified index, creating a new `Array`,\n * or return a copy of the input if the index is out of bounds.\n *\n * @since 1.0.0\n */\nexport const remove = i => self => {\n  const out = Array.from(self);\n  if (isOutOfBound(i, out)) {\n    return out;\n  }\n  out.splice(i, 1);\n  return out;\n};\n/**\n * Reverse an `Iterable`, creating a new `Array`.\n *\n * @since 1.0.0\n */\nexport const reverse = self => Array.from(self).reverse();\n/**\n * @since 1.0.0\n */\nexport const reverseNonEmpty = self => [lastNonEmpty(self), ...self.slice(0, -1).reverse()];\n/**\n * Return all the `Right` elements from an `Interable` of `Either`s.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const rights = self => {\n  const out = [];\n  for (const a of self) {\n    if (either.isRight(a)) {\n      out.push(a.right);\n    }\n  }\n  return out;\n};\n/**\n * Return all the `Left` elements from an `Interable` of `Either`s.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const lefts = self => {\n  const out = [];\n  for (const a of self) {\n    if (either.isLeft(a)) {\n      out.push(a.left);\n    }\n  }\n  return out;\n};\n/**\n * Sort the elements of an `Iterable` in increasing order, creating a new `Array`.\n *\n * @category sorting\n * @since 1.0.0\n */\nexport const sort = O => self => {\n  const out = Array.from(self);\n  out.sort(O.compare);\n  return out;\n};\n/**\n * Sort the elements of a `NonEmptyReadonlyArray` in increasing order, creating a new `NonEmptyArray`.\n *\n * @category sorting\n * @since 1.0.0\n */\nexport const sortNonEmpty = O => self => sort(O)(self);\n/**\n * Sort the elements of an `Iterable` in increasing order, where elements are compared\n * using first `orders[0]`, then `orders[1]`, etc...\n *\n * @category sorting\n * @since 1.0.0\n */\nexport const sortBy = (...orders) => self => {\n  const input = fromIterable(self);\n  return isNonEmpty(input) ? sortByNonEmpty(...orders)(input) : [];\n};\n/**\n * @category sorting\n * @since 1.0.0\n */\nexport const sortByNonEmpty = (...orders) => sortNonEmpty(order.getMonoid().combineAll(orders));\n/**\n * Takes two `Iterable`s and returns an `Array` of corresponding pairs.\n * If one input `Iterable` is short, excess elements of the\n * longer `Iterable` are discarded.\n *\n * @since 1.0.0\n */\nexport const zip = that => zipWith(that, (a, b) => [a, b]);\n/**\n * Apply a function to pairs of elements at the same index in two `Iterable`s, collecting the results in a new `Array`. If one\n * input `Iterable` is short, excess elements of the longer `Iterable` are discarded.\n *\n * @since 1.0.0\n */\nexport const zipWith = (that, f) => self => {\n  const as = fromIterable(self);\n  const bs = fromIterable(that);\n  return isNonEmpty(as) && isNonEmpty(bs) ? zipNonEmptyWith(bs, f)(as) : [];\n};\n/**\n * @since 1.0.0\n */\nexport const zipNonEmpty = that => self => pipe(self, zipNonEmptyWith(that, (a, b) => [a, b]));\n/**\n * @since 1.0.0\n */\nexport const zipNonEmptyWith = (that, f) => self => {\n  const cs = [f(headNonEmpty(self), headNonEmpty(that))];\n  const len = Math.min(self.length, that.length);\n  for (let i = 1; i < len; i++) {\n    cs[i] = f(self[i], that[i]);\n  }\n  return cs;\n};\n/**\n * This function is the inverse of `zip`. Takes an `Iterable` of pairs and return two corresponding `Array`s.\n *\n * @since 1.0.0\n */\nexport const unzip = self => {\n  const input = fromIterable(self);\n  return isNonEmpty(input) ? unzipNonEmpty(input) : [[], []];\n};\n/**\n * @since 1.0.0\n */\nexport const unzipNonEmpty = self => {\n  const fa = [self[0][0]];\n  const fb = [self[0][1]];\n  for (let i = 1; i < self.length; i++) {\n    fa[i] = self[i][0];\n    fb[i] = self[i][1];\n  }\n  return [fa, fb];\n};\n/**\n * Places an element in between members of an `Iterable`\n *\n * @since 1.0.0\n */\nexport const intersperse = middle => self => {\n  const input = fromIterable(self);\n  return isNonEmpty(input) ? intersperseNonEmpty(middle)(input) : [];\n};\n/**\n * Places an element in between members of a `NonEmptyReadonlyArray`\n *\n * @since 1.0.0\n */\nexport const intersperseNonEmpty = middle => self => {\n  const out = [headNonEmpty(self)];\n  const tail = tailNonEmpty(self);\n  for (let i = 0; i < tail.length; i++) {\n    if (i < tail.length) {\n      out.push(middle);\n    }\n    out.push(tail[i]);\n  }\n  return out;\n};\n/**\n * Apply a function to the head, creating a new `NonEmptyReadonlyArray`.\n *\n * @since 1.0.0\n */\nexport const modifyNonEmptyHead = f => self => [f(headNonEmpty(self)), ...tailNonEmpty(self)];\n/**\n * Change the head, creating a new `NonEmptyReadonlyArray`.\n *\n * @since 1.0.0\n */\nexport const setNonEmptyHead = b => modifyNonEmptyHead(() => b);\n/**\n * Apply a function to the last element, creating a new `NonEmptyReadonlyArray`.\n *\n * @since 1.0.0\n */\nexport const modifyNonEmptyLast = f => self => pipe(initNonEmpty(self), append(f(lastNonEmpty(self))));\n/**\n * Change the last element, creating a new `NonEmptyReadonlyArray`.\n *\n * @since 1.0.0\n */\nexport const setNonEmptyLast = b => modifyNonEmptyLast(() => b);\n/**\n * Rotate an `Iterable` by `n` steps.\n *\n * @since 1.0.0\n */\nexport const rotate = n => self => {\n  const input = fromIterable(self);\n  return isNonEmpty(input) ? rotateNonEmpty(n)(input) : [];\n};\n/**\n * Rotate a `NonEmptyReadonlyArray` by `n` steps.\n *\n * @since 1.0.0\n */\nexport const rotateNonEmpty = n => self => {\n  const len = self.length;\n  const m = Math.round(n) % len;\n  if (isOutOfBound(Math.abs(m), self) || m === 0) {\n    return copy(self);\n  }\n  if (m < 0) {\n    const [f, s] = splitNonEmptyAt(-m)(self);\n    return appendAllNonEmpty(f)(s);\n  } else {\n    return rotateNonEmpty(m - len)(self);\n  }\n};\n/**\n * Returns a function that checks if a `ReadonlyArray` contains a given value using a provided `equivalence` function.\n *\n * @category predicates\n * @since 1.0.0\n */\nexport const contains = equivalence => a => self => {\n  for (const i of self) {\n    if (equivalence(a, i)) {\n      return true;\n    }\n  }\n  return false;\n};\n/**\n * Remove duplicates from am `Iterable`, keeping the first occurrence of an element.\n *\n * @since 1.0.0\n */\nexport const uniq = equivalence => self => {\n  const input = fromIterable(self);\n  return isNonEmpty(input) ? uniqNonEmpty(equivalence)(input) : [];\n};\n/**\n * Remove duplicates from a `NonEmptyReadonlyArray`, keeping the first occurrence of an element.\n *\n * @since 1.0.0\n */\nexport const uniqNonEmpty = equivalence => self => {\n  const out = [headNonEmpty(self)];\n  const rest = tailNonEmpty(self);\n  for (const a of rest) {\n    if (out.every(o => !equivalence(a, o))) {\n      out.push(a);\n    }\n  }\n  return out;\n};\n/**\n * A useful recursion pattern for processing an `Iterable` to produce a new `Array`, often used for \"chopping\" up the input\n * `Iterable`. Typically chop is called with some function that will consume an initial prefix of the `Iterable` and produce a\n * value and the rest of the `Array`.\n *\n * @since 1.0.0\n */\nexport const chop = f => self => {\n  const input = fromIterable(self);\n  return isNonEmpty(input) ? chopNonEmpty(f)(input) : [];\n};\n/**\n * A useful recursion pattern for processing a `NonEmptyReadonlyArray` to produce a new `NonEmptyReadonlyArray`, often used for \"chopping\" up the input\n * `NonEmptyReadonlyArray`. Typically `chop` is called with some function that will consume an initial prefix of the `NonEmptyReadonlyArray` and produce a\n * value and the tail of the `NonEmptyReadonlyArray`.\n *\n * @since 1.0.0\n */\nexport const chopNonEmpty = f => self => {\n  const [b, rest] = f(self);\n  const out = [b];\n  let next = rest;\n  while (readonlyArray.isNonEmpty(next)) {\n    const [b, rest] = f(next);\n    out.push(b);\n    next = rest;\n  }\n  return out;\n};\n/**\n * Splits an `Iterable` into two pieces, the first piece has max `n` elements.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const splitAt = n => self => {\n  const input = Array.from(self);\n  return n >= 1 && isNonEmpty(input) ? splitNonEmptyAt(n)(input) : isEmpty(input) ? [input, []] : [[], input];\n};\nexport function copy(self) {\n  return self.slice();\n}\n/**\n * Splits a `NonEmptyReadonlyArray` into two pieces, the first piece has max `n` elements.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const splitNonEmptyAt = n => self => {\n  const m = Math.max(1, n);\n  return m >= self.length ? [copy(self), []] : [pipe(self.slice(1, m), prepend(headNonEmpty(self))), self.slice(m)];\n};\n/**\n * Splits an `Iterable` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `Iterable`. Note that `chunksOf(n)([])` is `[]`, not `[[]]`. This is intentional, and is consistent with a recursive\n * definition of `chunksOf`; it satisfies the property that\n *\n * ```ts\n * chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))\n * ```\n *\n * whenever `n` evenly divides the length of `self`.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const chunksOf = n => self => {\n  const input = fromIterable(self);\n  return isNonEmpty(input) ? chunksOfNonEmpty(n)(input) : [];\n};\n/**\n * Splits a `NonEmptyReadonlyArray` into length-`n` pieces. The last piece will be shorter if `n` does not evenly divide the length of\n * the `NonEmptyReadonlyArray`.\n *\n * @category getters\n * @since 1.0.0\n */\nexport const chunksOfNonEmpty = n => chopNonEmpty(splitNonEmptyAt(n));\n/**\n * Group equal, consecutive elements of a `NonEmptyReadonlyArray` into `NonEmptyArray`s.\n *\n * @category grouping\n * @since 1.0.0\n */\nexport const group = equivalence => self => pipe(self, chopNonEmpty(as => {\n  const h = headNonEmpty(as);\n  const out = [h];\n  let i = 1;\n  for (; i < as.length; i++) {\n    const a = as[i];\n    if (equivalence(a, h)) {\n      out.push(a);\n    } else {\n      break;\n    }\n  }\n  return [out, as.slice(i)];\n}));\n/**\n * Splits an `Iterable` into sub-non-empty-arrays stored in an object, based on the result of calling a `string`-returning\n * function on each element, and grouping the results according to values returned\n *\n * @category grouping\n * @since 1.0.0\n */\nexport const groupBy = f => self => {\n  const out = {};\n  for (const a of self) {\n    const k = f(a);\n    if (Object.prototype.hasOwnProperty.call(out, k)) {\n      out[k].push(a);\n    } else {\n      out[k] = [a];\n    }\n  }\n  return out;\n};\n/**\n * @since 1.0.0\n */\nexport const union = equivalence => that => self => {\n  const a = Array.from(self);\n  const b = Array.from(that);\n  return isNonEmpty(a) && isNonEmpty(b) ? unionNonEmpty(equivalence)(b)(a) : isNonEmpty(a) ? a : b;\n};\n/**\n * @since 1.0.0\n */\nexport const unionNonEmpty = equivalence =>\n// @ts-expect-error\nthat => self => uniqNonEmpty(equivalence)(appendAllNonEmpty(that)(self));\n/**\n * Creates an `Array` of unique values that are included in all given `Iterable`s.\n * The order and references of result values are determined by the first `Iterable`.\n *\n * @since 1.0.0\n */\nexport const intersection = equivalence => that => self => fromIterable(self).filter(a => contains(equivalence)(a)(that));\n/**\n * Creates a `Array` of values not included in the other given `Iterable`.\n * The order and references of result values are determined by the first `Iterable`.\n *\n * @since 1.0.0\n */\nexport const difference = equivalence => that => self => fromIterable(self).filter(a => !contains(equivalence)(a)(that));\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const of = a => [a];\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const empty = () => [];\n/**\n * @category mapping\n * @since 1.0.0\n */\nexport const map = f => mapWithIndex(a => f(a));\n/**\n * @category mapping\n * @since 1.0.0\n */\nexport const mapNonEmpty = f => mapNonEmptyWithIndex(f);\n/**\n * @category mapping\n * @since 1.0.0\n */\nexport const mapWithIndex = f => self => self.map((a, i) => f(a, i));\n/**\n * @category mapping\n * @since 1.0.0\n */\nexport const mapNonEmptyWithIndex = f => self => {\n  const out = [f(headNonEmpty(self), 0)];\n  for (let i = 1; i < self.length; i++) {\n    out.push(f(self[i], i));\n  }\n  return out;\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Of = {\n  of\n};\n/**\n * @category do notation\n * @since 1.0.0\n */\nexport const Do = /*#__PURE__*/of_.Do(Of);\n/**\n * @category mapping\n * @since 1.0.0\n */\nexport const imap = /*#__PURE__*/covariant.imap(map);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Invariant = {\n  imap\n};\n/**\n * @category mapping\n * @since 1.0.0\n */\nexport const tupled = /*#__PURE__*/invariant.tupled(Invariant);\n/**\n * @category do notation\n * @since 1.0.0\n */\nexport const bindTo = /*#__PURE__*/invariant.bindTo(Invariant);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Covariant = /*#__PURE__*/covariant.make(map);\nconst let_ = /*#__PURE__*/covariant.let(Covariant);\nexport {\n/**\n * @category do notation\n * @since 1.0.0\n */\nlet_ as let };\n/**\n * @category mapping\n * @since 1.0.0\n */\nexport const flap = /*#__PURE__*/covariant.flap(Covariant);\n/**\n * Maps the success value of this effect to the specified constant value.\n *\n * @category mapping\n * @since 1.0.0\n */\nexport const as = /*#__PURE__*/covariant.as(Covariant);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Pointed = {\n  ...Of,\n  ...Covariant\n};\n/**\n * @category sequencing\n * @since 1.0.0\n */\nexport const flatMapWithIndex = f => self => {\n  if (isEmpty(self)) {\n    return [];\n  }\n  const out = [];\n  for (let i = 0; i < self.length; i++) {\n    out.push(...f(self[i], i));\n  }\n  return out;\n};\n/**\n * @category sequencing\n * @since 1.0.0\n */\nexport const flatMap = f => flatMapWithIndex(f);\n/**\n * @category sequencing\n * @since 1.0.0\n */\nexport const flatMapNonEmptyWithIndex = f => self => {\n  const out = copy(f(headNonEmpty(self), 0));\n  for (let i = 1; i < self.length; i++) {\n    out.push(...f(self[i], i));\n  }\n  return out;\n};\n/**\n * @category sequencing\n * @since 1.0.0\n */\nexport const flatMapNonEmpty = f => flatMapNonEmptyWithIndex(f);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const FlatMap = {\n  flatMap\n};\n/**\n * @category sequencing\n * @since 1.0.0\n */\nexport const flatten = /*#__PURE__*/flatMap_.flatten(FlatMap);\n/**\n * @category sequencing\n * @since 1.0.0\n */\nexport const flattenNonEmpty = /*#__PURE__*/flatMapNonEmpty(identity);\n/**\n * @since 1.0.0\n */\nexport const composeKleisliArrow = /*#__PURE__*/flatMap_.composeKleisliArrow(FlatMap);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Chainable = {\n  ...FlatMap,\n  ...Covariant\n};\n/**\n * @category do notation\n * @since 1.0.0\n */\nexport const bind = /*#__PURE__*/chainable.bind(Chainable);\n/**\n * @category filtering\n * @since 1.0.0\n */\nexport const filterMapWithIndex = f => self => {\n  const as = fromIterable(self);\n  const out = [];\n  for (let i = 0; i < as.length; i++) {\n    const o = f(as[i], i);\n    if (option.isSome(o)) {\n      out.push(o.value);\n    }\n  }\n  return out;\n};\n/**\n * @category filtering\n * @since 1.0.0\n */\nexport const filterMap = f => filterMapWithIndex(f);\n/**\n * @category filtering\n * @since 1.0.0\n */\nexport const compact = /*#__PURE__*/filterMap(identity);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Compactable = {\n  compact\n};\n/**\n * @category filtering\n * @since 1.0.0\n */\nexport const separate = self => {\n  const left = [];\n  const right = [];\n  for (const e of self) {\n    if (either.isLeft(e)) {\n      left.push(e.left);\n    } else {\n      right.push(e.right);\n    }\n  }\n  return [left, right];\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Filterable = {\n  filterMap\n};\n/**\n * @category filtering\n * @since 1.0.0\n */\nexport const filter = /*#__PURE__*/filterable.filter(Filterable);\n/**\n * @category filtering\n * @since 1.0.0\n */\nexport const filterWithIndex = predicate => filterMapWithIndex((b, i) => predicate(b, i) ? option.some(b) : option.none);\n/**\n * @category filtering\n * @since 1.0.0\n */\nexport const partition = /*#__PURE__*/filterable.partition(Filterable);\n/**\n * @category filtering\n * @since 1.0.0\n */\nexport const partitionWithIndex = predicate => partitionMapWithIndex((b, i) => predicate(b, i) ? either.right(b) : either.left(b));\n/**\n * @category filtering\n * @since 1.0.0\n */\nexport const partitionMap = f => partitionMapWithIndex(f);\n/**\n * @category filtering\n * @since 1.0.0\n */\nexport const partitionMapWithIndex = f => self => {\n  const left = [];\n  const right = [];\n  for (let i = 0; i < self.length; i++) {\n    const e = f(self[i], i);\n    if (either.isLeft(e)) {\n      left.push(e.left);\n    } else {\n      right.push(e.right);\n    }\n  }\n  return [left, right];\n};\n/**\n * @category traversing\n * @since 1.0.0\n */\nexport const traverse = F => f => traverseWithIndex(F)(f);\n/**\n * @category traversing\n * @since 1.0.0\n */\nexport const traverseWithIndex = F => f => self => F.productAll(self.map(f));\n/**\n * @category traversing\n * @since 1.0.0\n */\nexport const traverseNonEmpty = F => f => traverseNonEmptyWithIndex(F)(f);\n/**\n * @category traversing\n * @since 1.0.0\n */\nexport const traverseNonEmptyWithIndex = F => f => self => {\n  const [head, ...tail] = pipe(self, mapNonEmptyWithIndex(f));\n  return F.productMany(head, tail);\n};\n/**\n * @category traversing\n * @since 1.0.0\n */\nexport const sequence = /*#__PURE__*/traversable.sequence(traverse);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Traversable = {\n  // @ts-expect-error\n  traverse,\n  // @ts-expect-error\n  sequence\n};\n/**\n * @category traversing\n * @since 1.0.0\n */\nexport const traverseTap = /*#__PURE__*/traversable.traverseTap(Traversable);\n/**\n * @category traversing\n * @since 1.0.0\n */\nexport const sequenceNonEmpty = F => traverseNonEmpty(F)(identity);\nconst product = (self, that) => {\n  if (isEmpty(self) || isEmpty(that)) {\n    return empty();\n  }\n  const out = [];\n  for (let i = 0; i < self.length; i++) {\n    for (let j = 0; j < that.length; j++) {\n      out.push([self[i], that[j]]);\n    }\n  }\n  return out;\n};\nconst productMany = /*#__PURE__*/semiProduct.productMany(Covariant, product);\nconst productAll = collection => {\n  const arrays = fromIterable(collection);\n  return isEmpty(arrays) ? empty() : productMany(arrays[0], arrays.slice(1));\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const SemiProduct = {\n  ...Invariant,\n  product,\n  productMany\n};\n/**\n * A variant of `bind` that sequentially ignores the scope.\n *\n * @category do notation\n * @since 1.0.0\n */\nexport const andThenBind = /*#__PURE__*/semiProduct.andThenBind(SemiProduct);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const SemiApplicative = {\n  ...SemiProduct,\n  ...Covariant\n};\n/**\n * @since 1.0.0\n */\nexport const ap = /*#__PURE__*/semiApplicative.ap(SemiApplicative);\n/**\n * Lifts a binary function into `ReadonlyArray`.\n *\n * @category lifting\n * @since 1.0.0\n */\nexport const lift2 = /*#__PURE__*/semiApplicative.lift2(SemiApplicative);\n/**\n * Lifts a ternary function into `ReadonlyArray`.\n *\n * @category lifting\n * @since 1.0.0\n */\nexport const lift3 = /*#__PURE__*/semiApplicative.lift3(SemiApplicative);\n/**\n * @category lifting\n * @since 1.0.0\n */\nexport const liftSemigroup = /*#__PURE__*/semiApplicative.liftSemigroup(SemiApplicative);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Product = {\n  ...Of,\n  ...SemiProduct,\n  productAll\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Applicative = {\n  ...SemiApplicative,\n  ...Product\n};\n/**\n * @category lifting\n * @since 1.0.0\n */\nexport const liftMonoid = /*#__PURE__*/applicative.liftMonoid(Applicative);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Monad = {\n  ...Pointed,\n  ...FlatMap\n};\n/**\n * @category folding\n * @since 1.0.0\n */\nexport const reduce = (b, f) => self => self.reduce((b, a) => f(b, a), b);\n/**\n * @category folding\n * @since 1.0.0\n */\nexport const reduceWithIndex = (b, f) => self => self.reduce((b, a, i) => f(b, a, i), b);\n/**\n * @category folding\n * @since 1.0.0\n */\nexport const reduceRight = (b, f) => self => self.reduceRight((b, a) => f(b, a), b);\n/**\n * @category folding\n * @since 1.0.0\n */\nexport const reduceRightWithIndex = (b, f) => self => self.reduceRight((b, a, i) => f(b, a, i), b);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Foldable = {\n  reduce\n};\n/**\n * @category folding\n * @since 1.0.0\n */\nexport const foldMap = /*#__PURE__*/foldable.foldMap(Foldable);\n/**\n * @category folding\n * @since 1.0.0\n */\nexport const foldMapWithIndex = Monoid => f => self => self.reduce((m, a, i) => Monoid.combine(m, f(a, i)), Monoid.empty);\n/**\n * @category folding\n * @since 1.0.0\n */\nexport const foldMapNonEmpty = S => f => foldMapNonEmptyWithIndex(S)(f);\n/**\n * @category folding\n * @since 1.0.0\n */\nexport const foldMapNonEmptyWithIndex = S => f => self => tailNonEmpty(self).reduce((s, a, i) => S.combine(s, f(a, i + 1)), f(headNonEmpty(self), 0));\n/**\n * @category folding\n * @since 1.0.0\n */\nexport const reduceKind = /*#__PURE__*/foldable.reduceKind(Foldable);\n/**\n * @category folding\n * @since 1.0.0\n */\nexport const reduceRightKind = /*#__PURE__*/foldable.reduceRightKind(Foldable);\n/**\n * @category folding\n * @since 1.0.0\n */\nexport const foldMapKind = /*#__PURE__*/foldable.foldMapKind(Foldable);\n/**\n * @category filtering\n * @since 1.0.0\n */\nexport const traverseFilterMap = /*#__PURE__*/traversableFilterable.traverseFilterMap({\n  ...Traversable,\n  ...Compactable\n});\n/**\n * @category filtering\n * @since 1.0.0\n */\nexport const traversePartitionMap = /*#__PURE__*/traversableFilterable.traversePartitionMap({\n  ...Traversable,\n  ...Covariant,\n  ...Compactable\n});\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const TraversableFilterable = {\n  // @ts-expect-error\n  traverseFilterMap,\n  // @ts-expect-error\n  traversePartitionMap\n};\n/**\n * Filter values inside a context.\n *\n * @since 1.0.0\n */\nexport const traverseFilter = /*#__PURE__*/traversableFilterable.traverseFilter(TraversableFilterable);\n/**\n * @since 1.0.0\n */\nexport const traversePartition = /*#__PURE__*/traversableFilterable.traversePartition(TraversableFilterable);\n/**\n * @category lifting\n * @since 1.0.0\n */\nexport const liftPredicate = predicate => b => predicate(b) ? [b] : [];\n/**\n * @category lifting\n * @since 1.0.0\n */\nexport const liftOption = f => (...a) => fromOption(f(...a));\n/**\n * @category conversions\n * @since 1.0.0\n */\nexport const fromNullable = a => a == null ? empty() : [a];\n/**\n * @category lifting\n * @since 1.0.0\n */\nexport const liftNullable = f => (...a) => fromNullable(f(...a));\n/**\n * @category sequencing\n * @since 1.0.0\n */\nexport const flatMapNullable = f => self => isNonEmpty(self) ? fromNullable(f(headNonEmpty(self))) : empty();\n/**\n * @category lifting\n * @since 1.0.0\n */\nexport const liftEither = f => (...a) => {\n  const e = f(...a);\n  return either.isLeft(e) ? [] : [e.right];\n};\nexport function every(predicate) {\n  return self => self.every(predicate);\n}\n/**\n * Check if a predicate holds true for any `ReadonlyArray` member.\n *\n * @category predicates\n * @since 1.0.0\n */\nexport const some = predicate => self => self.some(predicate);\n/**\n * Fold a data structure, accumulating values in some `Monoid`, combining adjacent elements\n * using the specified separator.\n *\n * @since 1.0.0\n */\nexport const intercalate = M => middle => self => isNonEmpty(self) ? intercalateNonEmpty(M)(middle)(self) : M.empty;\n/**\n * Places an element in between members of a `NonEmptyReadonlyArray`, then folds the results using the provided `Semigroup`.\n *\n * @since 1.0.0\n */\nexport const intercalateNonEmpty = S => middle => self => semigroup.intercalate(middle)(S).combineMany(headNonEmpty(self), tailNonEmpty(self));\n/**\n * @since 1.0.0\n */\nexport const join = /*#__PURE__*/intercalate(string.Monoid);\n/**\n * @since 1.0.0\n */\nexport const extend = f => self => self.map((_, i, as) => f(as.slice(i)));\n/**\n * @since 1.0.0\n */\nexport const min = O => {\n  const S = semigroup.min(O);\n  return self => self.reduce(S.combine);\n};\n/**\n * @since 1.0.0\n */\nexport const max = O => {\n  const S = semigroup.max(O);\n  return self => self.reduce(S.combine);\n};\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport const unfold = (b, f) => {\n  const out = [];\n  let next = b;\n  let o;\n  while (option.isSome(o = f(next))) {\n    const [a, b] = o.value;\n    out.push(a);\n    next = b;\n  }\n  return out;\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const getUnionSemigroup = equivalence => fromCombine((self, that) => pipe(self, union(equivalence)(that)));\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const getUnionMonoid = equivalence => {\n  const S = getUnionSemigroup(equivalence);\n  return {\n    combine: S.combine,\n    combineMany: S.combineMany,\n    combineAll: collection => S.combineMany([], collection),\n    empty: []\n  };\n};\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const getIntersectionSemigroup = equivalence => fromCombine((self, that) => pipe(self, intersection(equivalence)(that)));\n/**\n * Returns a `Semigroup` for `ReadonlyArray<A>`.\n *\n * @category instances\n * @since 1.0.0\n */\nexport const getSemigroup = semigroup.readonlyArray;\n/**\n * Returns a `Monoid` for `ReadonlyArray<A>`.\n *\n * @category instances\n * @since 1.0.0\n */\nexport const getMonoid = monoid.readonlyArray;\n/**\n * This function creates and returns a new `Order` for an array of values based on a given `Order` for the elements of the array.\n * The returned `Order` compares two arrays by applying the given `Order` to each element in the arrays.\n * If all elements are equal, the arrays are then compared based on their length.\n * It is useful when you need to compare two arrays of the same type and you have a specific way of comparing each element of the array.\n *\n * @category lifting\n * @since 1.0.0\n */\nexport const liftOrder = order.array;\n//# sourceMappingURL=ReadonlyArray.mjs.map","/**\n * @since 1.0.0\n */\nexport const dual = (dfLen, body) => {\n  // @ts-expect-error\n  return function () {\n    if (arguments.length === dfLen) {\n      // @ts-expect-error\n      return body.apply(this, arguments);\n    }\n    return self => body(self, ...arguments);\n  };\n};\n//# sourceMappingURL=Dual.mjs.map","/** @internal */\nexport const structural = /*#__PURE__*/Symbol.for(\"@effect/data/Equal/structural\");\n//# sourceMappingURL=Equal.mjs.map","/*\n * Copyright 2014 Thom Chiovoloni, released under the MIT license.\n *\n * A random number generator based on the basic implementation of the PCG algorithm,\n * as described here: http://www.pcg-random.org/\n *\n * Adapted for TypeScript from Thom's original code at https://github.com/thomcc/pcg-random\n *\n * forked from https://github.com/frptools\n *\n * @since 1.0.0\n */\n/** @internal */\nexport function isNothing(value) {\n  return value === void 0 || value === null;\n}\nconst defaultIncHi = 0x14057b7e;\nconst defaultIncLo = 0xf767814f;\nconst MUL_HI = 0x5851f42d >>> 0;\nconst MUL_LO = 0x4c957f2d >>> 0;\nconst BIT_53 = 9007199254740992.0;\nconst BIT_27 = 134217728.0;\n/**\n * PCG is a family of simple fast space-efficient statistically good algorithms\n * for random number generation. Unlike many general-purpose RNGs, they are also\n * hard to predict.\n *\n * @category model\n * @since 1.0.0\n */\nexport class PCGRandom {\n  constructor(seedHi, seedLo, incHi, incLo) {\n    if (isNothing(seedLo) && isNothing(seedHi)) {\n      seedLo = Math.random() * 0xffffffff >>> 0;\n      seedHi = 0;\n    } else if (isNothing(seedLo)) {\n      seedLo = seedHi;\n      seedHi = 0;\n    }\n    if (isNothing(incLo) && isNothing(incHi)) {\n      // @ts-expect-error\n      incLo = this._state ? this._state[3] : defaultIncLo;\n      // @ts-expect-error\n      incHi = this._state ? this._state[2] : defaultIncHi;\n    } else if (isNothing(incLo)) {\n      incLo = incHi;\n      incHi = 0;\n    }\n    this._state = new Int32Array([0, 0, incHi >>> 0, ((incLo || 0) | 1) >>> 0]);\n    this._next();\n    add64(this._state, this._state[0], this._state[1], seedHi >>> 0, seedLo >>> 0);\n    this._next();\n    return this;\n  }\n  /**\n   * Returns a copy of the internal state of this random number generator as a\n   * JavaScript Array.\n   *\n   * @category getters\n   * @since 1.0.0\n   */\n  getState() {\n    return [this._state[0], this._state[1], this._state[2], this._state[3]];\n  }\n  /**\n   * Restore state previously retrieved using `getState()`.\n   *\n   * @category mutations\n   * @since 1.0.0\n   */\n  setState(state) {\n    this._state[0] = state[0];\n    this._state[1] = state[1];\n    this._state[2] = state[2];\n    this._state[3] = state[3] | 1;\n  }\n  /**\n   * Get a uniformly distributed 32 bit integer between [0, max).\n   *\n   * @category getter\n   * @since 1.0.0\n   */\n  integer(max) {\n    if (!max) {\n      return this._next();\n    }\n    max = max >>> 0;\n    if ((max & max - 1) === 0) {\n      return this._next() & max - 1; // fast path for power of 2\n    }\n\n    let num = 0;\n    const skew = (-max >>> 0) % max >>> 0;\n    for (num = this._next(); num < skew; num = this._next()) {\n      // this loop will rarely execute more than twice,\n      // and is intentionally empty\n    }\n    return num % max;\n  }\n  /**\n   * Get a uniformly distributed IEEE-754 double between 0.0 and 1.0, with\n   * 53 bits of precision (every bit of the mantissa is randomized).\n   *\n   * @category getters\n   * @since 1.0.0\n   */\n  number() {\n    const hi = (this._next() & 0x03ffffff) * 1.0;\n    const lo = (this._next() & 0x07ffffff) * 1.0;\n    return (hi * BIT_27 + lo) / BIT_53;\n  }\n  /** @internal */\n  _next() {\n    // save current state (what we'll use for this number)\n    const oldHi = this._state[0] >>> 0;\n    const oldLo = this._state[1] >>> 0;\n    // churn LCG.\n    mul64(this._state, oldHi, oldLo, MUL_HI, MUL_LO);\n    add64(this._state, this._state[0], this._state[1], this._state[2], this._state[3]);\n    // get least sig. 32 bits of ((oldstate >> 18) ^ oldstate) >> 27\n    let xsHi = oldHi >>> 18;\n    let xsLo = (oldLo >>> 18 | oldHi << 14) >>> 0;\n    xsHi = (xsHi ^ oldHi) >>> 0;\n    xsLo = (xsLo ^ oldLo) >>> 0;\n    const xorshifted = (xsLo >>> 27 | xsHi << 5) >>> 0;\n    // rotate xorshifted right a random amount, based on the most sig. 5 bits\n    // bits of the old state.\n    const rot = oldHi >>> 27;\n    const rot2 = (-rot >>> 0 & 31) >>> 0;\n    return (xorshifted >>> rot | xorshifted << rot2) >>> 0;\n  }\n}\nfunction mul64(out, aHi, aLo, bHi, bLo) {\n  let c1 = (aLo >>> 16) * (bLo & 0xffff) >>> 0;\n  let c0 = (aLo & 0xffff) * (bLo >>> 16) >>> 0;\n  let lo = (aLo & 0xffff) * (bLo & 0xffff) >>> 0;\n  let hi = (aLo >>> 16) * (bLo >>> 16) + ((c0 >>> 16) + (c1 >>> 16)) >>> 0;\n  c0 = c0 << 16 >>> 0;\n  lo = lo + c0 >>> 0;\n  if (lo >>> 0 < c0 >>> 0) {\n    hi = hi + 1 >>> 0;\n  }\n  c1 = c1 << 16 >>> 0;\n  lo = lo + c1 >>> 0;\n  if (lo >>> 0 < c1 >>> 0) {\n    hi = hi + 1 >>> 0;\n  }\n  hi = hi + Math.imul(aLo, bHi) >>> 0;\n  hi = hi + Math.imul(aHi, bLo) >>> 0;\n  out[0] = hi;\n  out[1] = lo;\n}\n// add two 64 bit numbers (given in parts), and store the result in `out`.\nfunction add64(out, aHi, aLo, bHi, bLo) {\n  let hi = aHi + bHi >>> 0;\n  const lo = aLo + bLo >>> 0;\n  if (lo >>> 0 < aLo >>> 0) {\n    hi = hi + 1 | 0;\n  }\n  out[0] = hi;\n  out[1] = lo;\n}\n//# sourceMappingURL=Random.mjs.map","/**\n * @since 1.0.0\n */\nimport { pipe } from \"@fp-ts/core/Function\";\nimport { structural } from \"@fp-ts/data/internal/Equal\";\nimport { PCGRandom } from \"@fp-ts/data/Random\";\n/** @internal */\nconst randomHashCache = /*#__PURE__*/new WeakMap();\n/** @internal */\nconst pcgr = /*#__PURE__*/new PCGRandom();\n/**\n * @since 1.0.0\n * @category symbols\n */\nexport const symbol = /*#__PURE__*/Symbol.for(\"@fp-ts/data/Hash\");\n/**\n * @since 1.0.0\n * @category hashing\n */\nexport const hash = self => {\n  switch (typeof self) {\n    case \"number\":\n      {\n        return number(self);\n      }\n    case \"bigint\":\n      {\n        return string(self.toString(10));\n      }\n    case \"boolean\":\n      {\n        return string(String(self));\n      }\n    case \"symbol\":\n      {\n        return string(String(self));\n      }\n    case \"string\":\n      {\n        return string(self);\n      }\n    case \"undefined\":\n      {\n        return string(\"undefined\");\n      }\n    case \"function\":\n    case \"object\":\n      {\n        if (self === null) {\n          return string(\"null\");\n        }\n        if (isHash(self)) {\n          return self[symbol]();\n        } else {\n          if (structural in self) {\n            return structure(self);\n          }\n          return random(self);\n        }\n      }\n    default:\n      {\n        throw new Error(\"Bug in Equal.hashGeneric\");\n      }\n  }\n};\n/**\n * @since 1.0.0\n * @category hashing\n */\nexport const random = self => {\n  if (!randomHashCache.has(self)) {\n    randomHashCache.set(self, number(pcgr.integer(Number.MAX_SAFE_INTEGER)));\n  }\n  return randomHashCache.get(self);\n};\n/**\n * @since 1.0.0\n * @category hashing\n */\nexport const combine = b => self => self * 53 ^ b;\n/**\n * @since 1.0.0\n * @category hashing\n */\nexport const optimize = n => n & 0xbfffffff | n >>> 1 & 0x40000000;\n/**\n * @since 1.0.0\n * @category guards\n */\nexport const isHash = u => typeof u === \"object\" && u !== null && symbol in u;\n/**\n * @since 1.0.0\n * @category hashing\n */\nexport const number = n => {\n  if (n !== n || n === Infinity) {\n    return 0;\n  }\n  let h = n | 0;\n  if (h !== n) {\n    h ^= n * 0xffffffff;\n  }\n  while (n > 0xffffffff) {\n    h ^= n /= 0xffffffff;\n  }\n  return optimize(n);\n};\n/**\n * @since 1.0.0\n * @category hashing\n */\nexport const string = str => {\n  let h = 5381,\n    i = str.length;\n  while (i) {\n    h = h * 33 ^ str.charCodeAt(--i);\n  }\n  return optimize(h);\n};\n/**\n * @since 1.0.0\n * @category hashing\n */\nexport const structure = o => {\n  const keys = Object.keys(o);\n  let h = 12289;\n  for (let i = 0; i < keys.length; i++) {\n    h ^= pipe(string(keys[i]), combine(hash(o[keys[i]])));\n  }\n  return optimize(h);\n};\n/**\n * @since 1.0.0\n * @category hashing\n */\nexport const array = arr => {\n  let h = 6151;\n  for (let i = 0; i < arr.length; i++) {\n    h = pipe(h, combine(hash(arr[i])));\n  }\n  return optimize(h);\n};\n//# sourceMappingURL=Hash.mjs.map","import * as Hash from \"@fp-ts/data/Hash\";\nimport { structural } from \"@fp-ts/data/internal/Equal\";\n/**\n * @since 1.0.0\n * @category symbols\n */\nexport const symbol = /*#__PURE__*/Symbol.for(\"@fp-ts/data/Equal\");\nexport function equals() {\n  if (arguments.length === 1) {\n    return self => compareBoth(self, arguments[0]);\n  }\n  return compareBoth(arguments[0], arguments[1]);\n}\nfunction compareBoth(self, that) {\n  if (self === that) {\n    return true;\n  }\n  const selfType = typeof self;\n  if (selfType !== typeof that) {\n    return false;\n  }\n  if ((selfType === \"object\" || selfType === \"function\") && self !== null && that !== null) {\n    if (isEqual(self) && isEqual(that)) {\n      return Hash.hash(self) === Hash.hash(that) && self[symbol](that);\n    }\n    if (structural in self && structural in that) {\n      const selfKeys = Object.keys(self);\n      const thatKeys = Object.keys(that);\n      if (selfKeys.length !== thatKeys.length) {\n        return false;\n      }\n      for (const key of selfKeys) {\n        if (!(key in that) || !equals(self[key], that[key])) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }\n  return false;\n}\n/**\n * @since 1.0.0\n * @category guards\n */\nexport const isEqual = u => typeof u === \"object\" && u !== null && symbol in u;\n/**\n * @since 1.0.0\n * @category instances\n */\nexport const equivalence = () => (self, that) => Hash.hash(self) === Hash.hash(that) && equals(self, that);\n//# sourceMappingURL=Equal.mjs.map","import { identity, pipe } from \"@fp-ts/core/Function\";\nimport * as O from \"@fp-ts/core/Option\";\nimport * as RA from \"@fp-ts/core/ReadonlyArray\";\nimport * as Dual from \"@fp-ts/data/Dual\";\nimport * as Equal from \"@fp-ts/data/Equal\";\nimport * as Hash from \"@fp-ts/data/Hash\";\nconst TypeId = /*#__PURE__*/Symbol.for(\"@fp-ts/data/Chunk\");\n/** @internal */\nconst emptyArray = [];\n/** @internal */\nfunction copy(src, srcPos, dest, destPos, len) {\n  for (let i = srcPos; i < Math.min(src.length, srcPos + len); i++) {\n    dest[destPos + i - srcPos] = src[i];\n  }\n  return dest;\n}\n/** @internal */\nclass ChunkImpl {\n  constructor(backing) {\n    this.backing = backing;\n    this._id = TypeId;\n    switch (backing._tag) {\n      case \"IEmpty\":\n        {\n          this.length = 0;\n          this.depth = 0;\n          this.left = this;\n          this.right = this;\n          break;\n        }\n      case \"IConcat\":\n        {\n          this.length = backing.left.length + backing.right.length;\n          this.depth = 1 + Math.max(backing.left.depth, backing.right.depth);\n          this.left = backing.left;\n          this.right = backing.right;\n          break;\n        }\n      case \"IArray\":\n        {\n          this.length = backing.array.length;\n          this.depth = 0;\n          this.left = _empty;\n          this.right = _empty;\n          break;\n        }\n      case \"ISingleton\":\n        {\n          this.length = 1;\n          this.depth = 0;\n          this.left = _empty;\n          this.right = _empty;\n          break;\n        }\n    }\n  }\n  get array() {\n    return this.toReadonlyArray();\n  }\n  toReadonlyArray() {\n    switch (this.backing._tag) {\n      case \"IEmpty\":\n        {\n          return emptyArray;\n        }\n      case \"IArray\":\n        {\n          return this.backing.array;\n        }\n      default:\n        {\n          const arr = new Array(this.length);\n          copyToArray(this, arr, 0);\n          this.backing = {\n            _tag: \"IArray\",\n            array: arr\n          };\n          this.left = _empty;\n          this.right = _empty;\n          this.depth = 0;\n          return arr;\n        }\n    }\n  }\n  toString() {\n    return `Chunk(${this.toReadonlyArray().map(String).join(\", \")})`;\n  }\n  toJSON() {\n    return {\n      _tag: \"Chunk\",\n      values: this.toReadonlyArray()\n    };\n  }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return this.toJSON();\n  }\n  isNonEmpty() {\n    return this.length > 0;\n  }\n  isEmpty() {\n    return !this.isNonEmpty();\n  }\n  map(f) {\n    return this.backing._tag === \"ISingleton\" ? of(f(this.backing.a)) : unsafeFromArray(RA.map(f)(toReadonlyArray(this)));\n  }\n  flatMap(f) {\n    if (this.backing._tag === \"ISingleton\") {\n      return f(this.backing.a);\n    }\n    let r = _empty;\n    for (const k of this) {\n      r = concat(f(k))(r);\n    }\n    return r;\n  }\n  forEach(f) {\n    return this.backing._tag === \"ISingleton\" ? f(this.backing.a) : toReadonlyArray(this).forEach(f);\n  }\n  append(b) {\n    return this.concat(of(b));\n  }\n  prepend(b) {\n    return of(b).concat(this);\n  }\n  concat(that) {\n    if (this.backing._tag === \"IEmpty\") {\n      return that;\n    }\n    if (that.backing._tag === \"IEmpty\") {\n      return this;\n    }\n    const diff = that.depth - this.depth;\n    if (Math.abs(diff) <= 1) {\n      return new ChunkImpl({\n        _tag: \"IConcat\",\n        left: this,\n        right: that\n      });\n    } else if (diff < -1) {\n      if (this.left.depth >= this.right.depth) {\n        const nr = concat(that)(this.right);\n        return new ChunkImpl({\n          _tag: \"IConcat\",\n          left: this.left,\n          right: nr\n        });\n      } else {\n        const nrr = concat(that)(this.right.right);\n        if (nrr.depth === this.depth - 3) {\n          const nr = new ChunkImpl({\n            _tag: \"IConcat\",\n            left: this.right.left,\n            right: nrr\n          });\n          return new ChunkImpl({\n            _tag: \"IConcat\",\n            left: this.left,\n            right: nr\n          });\n        } else {\n          const nl = new ChunkImpl({\n            _tag: \"IConcat\",\n            left: this.left,\n            right: this.right.left\n          });\n          return new ChunkImpl({\n            _tag: \"IConcat\",\n            left: nl,\n            right: nrr\n          });\n        }\n      }\n    } else {\n      if (this.right.depth >= that.left.depth) {\n        const nl = concat(that.left)(this);\n        return new ChunkImpl({\n          _tag: \"IConcat\",\n          left: nl,\n          right: that.right\n        });\n      } else {\n        const nll = concat(that.left.left)(this);\n        if (nll.depth === that.depth - 3) {\n          const nl = new ChunkImpl({\n            _tag: \"IConcat\",\n            left: nll,\n            right: that.left.right\n          });\n          return new ChunkImpl({\n            _tag: \"IConcat\",\n            left: nl,\n            right: that.right\n          });\n        } else {\n          const nr = new ChunkImpl({\n            _tag: \"IConcat\",\n            left: that.left.right,\n            right: that.right\n          });\n          return new ChunkImpl({\n            _tag: \"IConcat\",\n            left: nll,\n            right: nr\n          });\n        }\n      }\n    }\n  }\n  get(index) {\n    return index < 0 || index >= this.length ? O.none() : O.some(this.unsafeGet(index));\n  }\n  unsafeGet(index) {\n    switch (this.backing._tag) {\n      case \"IEmpty\":\n        {\n          throw new Error(`Index out of bounds`);\n        }\n      case \"ISingleton\":\n        {\n          if (index !== 0) {\n            throw new Error(`Index out of bounds`);\n          }\n          return this.backing.a;\n        }\n      case \"IArray\":\n        {\n          if (index >= this.length || index < 0) {\n            throw new Error(`Index out of bounds`);\n          }\n          return this.backing.array[index];\n        }\n      case \"IConcat\":\n        {\n          return index < this.left.length ? this.left.unsafeGet(index) : this.right.unsafeGet(index - this.left.length);\n        }\n    }\n  }\n  [Equal.symbol](that) {\n    if (isChunk(that) && this.length === that.length) {\n      return toReadonlyArray(this).every((value, i) => Equal.equals(value, that.unsafeGet(i)));\n    }\n    return false;\n  }\n  [Hash.symbol]() {\n    return Hash.array(toReadonlyArray(this));\n  }\n  [Symbol.iterator]() {\n    switch (this.backing._tag) {\n      case \"IArray\":\n        {\n          return this.backing.array[Symbol.iterator]();\n        }\n      case \"IEmpty\":\n        {\n          return emptyArray[Symbol.iterator]();\n        }\n      default:\n        {\n          return toReadonlyArray(this)[Symbol.iterator]();\n        }\n    }\n  }\n}\n/** @internal */\nconst copyToArray = (self, array, n) => {\n  switch (self.backing._tag) {\n    case \"IArray\":\n      {\n        copy(self.backing.array, 0, array, n, self.length);\n        break;\n      }\n    case \"IConcat\":\n      {\n        copyToArray(self.left, array, n);\n        copyToArray(self.right, array, n + self.left.length);\n        break;\n      }\n    case \"ISingleton\":\n      {\n        array[n] = self.backing.a;\n        break;\n      }\n  }\n};\n/**\n * Checks if `u` is a `Chunk<unknown>`\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const isChunk = u => typeof u === \"object\" && u != null && \"_id\" in u && u[\"_id\"] === TypeId;\nconst _empty = /*#__PURE__*/new ChunkImpl({\n  _tag: \"IEmpty\"\n});\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const empty = () => _empty;\n/**\n * Converts from an `Iterable<A>`\n *\n * @since 1.0.0\n * @category conversions\n */\nexport const fromIterable = self => isChunk(self) ? self : new ChunkImpl({\n  _tag: \"IArray\",\n  array: Array.from(self)\n});\n/**\n * Converts to a `ReadonlyArray<A>`\n *\n * @since 1.0.0\n * @category conversions\n */\nexport const toReadonlyArray = self => self.toReadonlyArray();\n/**\n * This function provides a safe way to read a value at a particular index from a `Chunk`.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const get = /*#__PURE__*/Dual.dual(2, (self, index) => self.get(index));\n/**\n * Wraps an array into a chunk without copying, unsafe on mutable arrays\n *\n * @since 1.0.0\n * @category unsafe\n */\nexport const unsafeFromArray = self => new ChunkImpl({\n  _tag: \"IArray\",\n  array: self\n});\n/**\n * Gets an element unsafely, will throw on out of bounds\n *\n * @since 1.0.0\n * @category unsafe\n */\nexport const unsafeGet = /*#__PURE__*/Dual.dual(2, (self, index) => self.unsafeGet(index));\n/**\n * Appends the value to the chunk\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const append = /*#__PURE__*/Dual.dual(2, (self, a) => self.append(a));\n/**\n * Prepends the value to the chunk\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const prepend = /*#__PURE__*/Dual.dual(2, (self, elem) => self.prepend(elem));\n/**\n * Takes the first up to `n` elements from the chunk\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const take = /*#__PURE__*/Dual.dual(2, (self, n) => {\n  if (n <= 0) {\n    return _empty;\n  } else if (n >= self.length) {\n    return self;\n  } else {\n    return unsafeFromArray(RA.take(n)(self.toReadonlyArray()));\n  }\n});\n/**\n * Drops the first up to `n` elements from the chunk\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const drop = /*#__PURE__*/Dual.dual(2, (self, n) => {\n  if (n <= 0) {\n    return self;\n  } else if (n >= self.length) {\n    return _empty;\n  } else {\n    return unsafeFromArray(RA.drop(n)(self.toReadonlyArray()));\n  }\n});\n/**\n * Drops the last `n` elements.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const dropRight = /*#__PURE__*/Dual.dual(2, (self, n) => take(self, Math.max(0, self.length - n)));\n/**\n * Drops all elements so long as the predicate returns true.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const dropWhile = /*#__PURE__*/Dual.dual(2, (self, f) => {\n  const arr = toReadonlyArray(self);\n  const len = arr.length;\n  let i = 0;\n  while (i < len && f(arr[i])) {\n    i++;\n  }\n  return pipe(self, drop(i));\n});\n/**\n * @category mutations\n * @since 1.0.0\n */\nexport const prependAllNonEmpty = /*#__PURE__*/Dual.dual(2, (self, that) => that.concat(self));\n/**\n * Concatenates the two chunks\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const concat = /*#__PURE__*/Dual.dual(2, (self, that) => self.concat(that));\n/**\n * Compares the two chunks of equal length using the specified function\n *\n * @since 1.0.0\n * @category elements\n */\nexport const correspondsTo = /*#__PURE__*/Dual.dual(3, (self, that, f) => {\n  if (self.length !== that.length) {\n    return false;\n  }\n  const selfArray = toReadonlyArray(self);\n  const thatArray = toReadonlyArray(that);\n  return selfArray.every((v, i) => f(v, thatArray[i]));\n});\n/**\n * Returns a filtered and mapped subset of the elements.\n *\n * @since 1.0.0\n * @category filtering\n */\nexport const filterMap = /*#__PURE__*/Dual.dual(2, (self, f) => unsafeFromArray(RA.filterMap(f)(self)));\n/**\n * Returns a filtered and mapped subset of the elements.\n *\n * @since 1.0.0\n * @category filtering\n */\nexport const filter = /*#__PURE__*/Dual.dual(2, (self, predicate) => unsafeFromArray(RA.filterMap(O.liftPredicate(predicate))(self)));\n/**\n * Returns a filtered and mapped subset of the elements.\n *\n * @since 1.0.0\n * @category filtering\n */\nexport const filterMapWithIndex = /*#__PURE__*/Dual.dual(2, (self, f) => unsafeFromArray(RA.filterMapWithIndex(f)(self)));\n/**\n * Transforms all elements of the chunk for as long as the specified function returns some value\n *\n * @since 1.0.0\n * @category filtering\n */\nexport const filterMapWhile = /*#__PURE__*/Dual.dual(2, (self, f) => {\n  const res = [];\n  for (const a of self) {\n    const b = f(a);\n    if (O.isSome(b)) {\n      res.push(b.value);\n    } else {\n      break;\n    }\n  }\n  return unsafeFromArray(res);\n});\n/**\n * Tests whether a value is a member of a `Chunk<A>`.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const elem = /*#__PURE__*/Dual.dual(2, (self, b) => pipe(toReadonlyArray(self), RA.contains(Equal.equivalence())(b)));\n/**\n * Filter out optional values\n *\n * @since 1.0.0\n * @category filtering\n */\nexport const compact = self => filterMap(self, identity);\n/**\n * Deduplicates adjacent elements that are identical.\n *\n * @since 1.0.0\n * @category filtering\n */\nexport const dedupeAdjacent = self => {\n  const builder = [];\n  let lastA = O.none();\n  for (const a of self) {\n    if (O.isNone(lastA) || !Equal.equals(a, lastA.value)) {\n      builder.push(a);\n      lastA = O.some(a);\n    }\n  }\n  return unsafeFromArray(builder);\n};\n/**\n * Check if a predicate holds true for any `Chunk` member.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const some = /*#__PURE__*/Dual.dual(2, (self, f) => toReadonlyArray(self).findIndex(v => f(v)) !== -1);\n/**\n * Check if a predicate holds true for every `Chunk` member.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const every = /*#__PURE__*/Dual.dual(2, (self, f) => toReadonlyArray(self).every(v => f(v)));\n/**\n * Find the first element which satisfies a predicate (or a refinement) function.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const findFirst = /*#__PURE__*/Dual.dual(2, (self, predicate) => RA.findFirst(predicate)(toReadonlyArray(self)));\n/**\n * Find the first index for which a predicate holds\n *\n * @since 1.0.0\n * @category elements\n */\nexport const findFirstIndex = /*#__PURE__*/Dual.dual(2, (self, f) => RA.findFirstIndex(f)(toReadonlyArray(self)));\n/**\n * Find the first index for which a predicate holds\n *\n * @since 1.0.0\n * @category elements\n */\nexport const findLastIndex = /*#__PURE__*/Dual.dual(2, (self, f) => RA.findLastIndex(f)(toReadonlyArray(self)));\n/**\n * Find the last element which satisfies a predicate function\n *\n * @since 1.0.0\n * @category elements\n */\nexport const findLast = /*#__PURE__*/Dual.dual(2, (self, f) => RA.findLast(f)(toReadonlyArray(self)));\n/**\n * Returns a chunk with the elements mapped by the specified function.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexport const flatMap = /*#__PURE__*/Dual.dual(2, (self, f) => {\n  if (self.backing._tag === \"ISingleton\") {\n    return f(self.backing.a);\n  }\n  let r = _empty;\n  for (const k of self) {\n    r = concat(f(k))(r);\n  }\n  return r;\n});\n/**\n * Flattens a chunk of chunks into a single chunk by concatenating all chunks.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexport const flatten = /*#__PURE__*/flatMap(identity);\n/**\n * Iterate over the chunk applying `f`.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const forEach = /*#__PURE__*/Dual.dual(2, (self, f) => self.forEach(f));\n/**\n * Groups elements in chunks of up to `n` elements.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const chunksOf = /*#__PURE__*/Dual.dual(2, (self, n) => {\n  const gr = [];\n  let current = [];\n  toReadonlyArray(self).forEach(a => {\n    current.push(a);\n    if (current.length >= n) {\n      gr.push(unsafeFromArray(current));\n      current = [];\n    }\n  });\n  if (current.length > 0) {\n    gr.push(unsafeFromArray(current));\n  }\n  return unsafeFromArray(gr);\n});\n/**\n * Returns the first element of this chunk if it exists.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const head = /*#__PURE__*/get(0);\n/**\n * Creates a Chunk of unique values that are included in all given Chunks.\n *\n * The order and references of result values are determined by the Chunk.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const intersection = /*#__PURE__*/Dual.dual(2, (self, that) => pipe(toReadonlyArray(self), RA.intersection(Equal.equivalence())(toReadonlyArray(that)), unsafeFromArray));\n/**\n * Determines if the chunk is empty.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const isEmpty = self => self.isEmpty();\n/**\n * Determines if the chunk is not empty.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const isNonEmpty = self => self.isNonEmpty();\n/**\n * Folds over the elements in this chunk from the left.\n *\n * @since 1.0.0\n * @category folding\n */\nexport const reduce = /*#__PURE__*/Dual.dual(3, (self, b, f) => pipe(toReadonlyArray(self), RA.reduce(b, f)));\n/**\n * Folds over the elements in this chunk from the left.\n *\n * @since 1.0.0\n * @category folding\n */\nexport const reduceWithIndex = /*#__PURE__*/Dual.dual(3, (self, b, f) => pipe(toReadonlyArray(self), RA.reduceWithIndex(b, f)));\n/**\n * Folds over the elements in this chunk from the right.\n *\n * @since 1.0.0\n * @category folding\n */\nexport const reduceRight = /*#__PURE__*/Dual.dual(3, (self, b, f) => pipe(toReadonlyArray(self), RA.reduceRight(b, (b, a) => f(b, a))));\n/**\n * Folds over the elements in this chunk from the right.\n *\n * @since 1.0.0\n * @category folding\n */\nexport const reduceRightWithIndex = /*#__PURE__*/Dual.dual(3, (self, b, f) => pipe(toReadonlyArray(self), RA.reduceRightWithIndex(b, f)));\n/**\n * Joins the elements together with \"sep\" in the middle.\n *\n * @since 1.0.0\n * @category folding\n */\nexport const join = /*#__PURE__*/Dual.dual(2, (self, sep) => reduce(self, \"\", (s, a) => s.length > 0 ? `${s}${sep}${a}` : a));\n/**\n * Returns the last element of this chunk if it exists.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const last = self => get(self, self.length - 1);\n/**\n * Builds a `NonEmptyChunk` from an non-empty collection of elements.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const make = (...as) => unsafeFromArray(as);\n/**\n * Builds a `NonEmptyChunk` from a single element.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const of = a => new ChunkImpl({\n  _tag: \"ISingleton\",\n  a\n});\n/**\n * Return a Chunk of length n with element i initialized with f(i).\n *\n * **Note**. `n` is normalized to an integer >= 1.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const makeBy = /*#__PURE__*/Dual.dual(2, (n, f) => make(...RA.makeBy(f)(n)));\n/**\n * Returns an effect whose success is mapped by the specified f function.\n *\n * @since 1.0.0\n * @category mapping\n */\nexport const map = /*#__PURE__*/Dual.dual(2, (self, f) => self.map(f));\n/**\n * Returns an effect whose success is mapped by the specified f function.\n *\n * @since 1.0.0\n * @category mapping\n */\nexport const mapWithIndex = /*#__PURE__*/Dual.dual(2, (self, f) => self.backing._tag === \"ISingleton\" ? of(f(self.backing.a, 0)) : unsafeFromArray(pipe(toReadonlyArray(self), RA.mapWithIndex(f))));\n/**\n * Statefully maps over the chunk, producing new elements of type `B`.\n *\n * @since 1.0.0\n * @category folding\n */\nexport const mapAccum = /*#__PURE__*/Dual.dual(3, (self, s, f) => {\n  let s1 = s;\n  const res = [];\n  for (const a of toReadonlyArray(self)) {\n    const r = f(s1, a);\n    s1 = r[0];\n    res.push(r[1]);\n  }\n  return [s1, unsafeFromArray(res)];\n});\n/**\n * Separate elements based on a predicate that also exposes the index of the element.\n *\n * @category filtering\n * @since 1.0.0\n */\nexport const partitionWithIndex = /*#__PURE__*/Dual.dual(2, (self, f) => pipe(toReadonlyArray(self), RA.partitionWithIndex(f), ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]));\n/**\n * Separate elements based on a predicate.\n *\n * @category filtering\n * @since 1.0.0\n */\nexport const partition = /*#__PURE__*/Dual.dual(2, (self, predicate) => pipe(toReadonlyArray(self), RA.partition(predicate), ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]));\n/**\n * Partitions the elements of this chunk into two chunks using f.\n *\n * @category filtering\n * @since 1.0.0\n */\nexport const partitionMap = /*#__PURE__*/Dual.dual(2, (self, f) => pipe(self, toReadonlyArray, RA.partitionMap(f), ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]));\n/**\n * Partitions the elements of this chunk into two chunks.\n *\n * @category filtering\n * @since 1.0.0\n */\nexport const separate = self => pipe(self, toReadonlyArray, RA.separate, ([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)]);\n/**\n * Create a non empty `Chunk` containing a range of integers, including both endpoints.\n *\n * @category constructors\n * @since 1.0.0\n */\nexport const range = (start, end) => start <= end ? makeBy(end - start + 1, i => start + i) : of(start);\n/**\n * Reverse a Chunk, creating a new Chunk.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const reverse = self => unsafeFromArray(RA.reverse(toReadonlyArray(self)));\n/**\n * Retireves the size of the chunk\n *\n * @since 1.0.0\n * @category elements\n */\nexport const size = self => self.length;\n/**\n * Sort the elements of a Chunk in increasing order, creating a new Chunk.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const sort = /*#__PURE__*/Dual.dual(2, (self, O) => pipe(toReadonlyArray(self), RA.sort(O), unsafeFromArray));\n/**\n *  Returns two splits of this chunk at the specified index.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const splitAt = /*#__PURE__*/Dual.dual(2, (self, n) => [take(n)(self), drop(n)(self)]);\n/**\n * Splits this chunk into `n` equally sized chunks.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const split = /*#__PURE__*/Dual.dual(2, (self, n) => {\n  const length = self.length;\n  const k = Math.floor(n);\n  const quotient = Math.floor(length / k);\n  const remainder = length % k;\n  const chunks = [];\n  let i = 0;\n  let chunk = [];\n  toReadonlyArray(self).forEach(a => {\n    chunk.push(a);\n    if (i <= remainder && chunk.length > quotient || i > remainder && chunk.length >= quotient) {\n      chunks.push(unsafeFromArray(chunk));\n      chunk = [];\n    }\n    i++;\n  });\n  if (chunk.length > 0) {\n    chunks.push(unsafeFromArray(chunk));\n  }\n  return unsafeFromArray(chunks);\n});\n/**\n * Splits this chunk on the first element that matches this predicate.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const splitWhere = /*#__PURE__*/Dual.dual(2, (self, f) => {\n  let i = 0;\n  for (const a of toReadonlyArray(self)) {\n    if (f(a)) {\n      break;\n    } else {\n      i++;\n    }\n  }\n  return splitAt(i)(self);\n});\n/**\n * Returns every elements after the first.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const tail = self => self.length > 0 ? O.some(drop(1)(self)) : O.none();\n/**\n * Takes the last `n` elements.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const takeRight = /*#__PURE__*/Dual.dual(2, (self, n) => drop(self, self.length - n));\n/**\n * Takes all elements so long as the predicate returns true.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const takeWhile = /*#__PURE__*/Dual.dual(2, (self, f) => {\n  const res = [];\n  for (const a of toReadonlyArray(self)) {\n    if (f(a)) {\n      res.push(a);\n    } else {\n      break;\n    }\n  }\n  return unsafeFromArray(res);\n});\n/**\n * Constructs a `Chunk` by repeatedly applying the function `f` as long as it * returns `Some`.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const unfold = (s, f) => {\n  const builder = [];\n  let cont = true;\n  let s1 = s;\n  while (cont) {\n    const x = f(s1);\n    if (O.isSome(x)) {\n      s1 = x.value[1];\n      builder.push(x.value[0]);\n    } else {\n      cont = false;\n    }\n  }\n  return unsafeFromArray(builder);\n};\n/**\n * Creates a Chunks of unique values, in order, from all given Chunks.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const union = /*#__PURE__*/Dual.dual(2, (self, that) => unsafeFromArray(RA.union(Equal.equivalence())(toReadonlyArray(that))(toReadonlyArray(self))));\n/**\n * Remove duplicates from an array, keeping the first occurrence of an element.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const dedupe = self => unsafeFromArray(RA.uniq(Equal.equivalence())(toReadonlyArray(self)));\n/**\n * Returns the first element of this chunk.\n *\n * @since 1.0.0\n * @category unsafe\n */\nexport const unsafeHead = self => unsafeGet(0)(self);\n/**\n * Returns the last element of this chunk.\n *\n * @since 1.0.0\n * @category unsafe\n */\nexport const unsafeLast = self => unsafeGet(self.length - 1)(self);\n/**\n * Takes an array of pairs and return two corresponding arrays.\n *\n * Note: The function is reverse of `zip`.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const unzip = as => {\n  const fa = [];\n  const fb = [];\n  toReadonlyArray(as).forEach(([a, b]) => {\n    fa.push(a);\n    fb.push(b);\n  });\n  return [unsafeFromArray(fa), unsafeFromArray(fb)];\n};\n/**\n * Zips this chunk pointwise with the specified chunk.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const zip = /*#__PURE__*/Dual.dual(2, (self, that) => zipWith(self, that, (a, b) => [a, b]));\n/**\n * Zips this chunk pointwise with the specified chunk using the specified combiner.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const zipWith = /*#__PURE__*/Dual.dual(3, (self, that, f) => {\n  const selfA = toReadonlyArray(self);\n  const thatA = toReadonlyArray(that);\n  return pipe(selfA, RA.zipWith(thatA, f), unsafeFromArray);\n});\n/**\n * Zips this chunk pointwise with the specified chunk to produce a new chunk with\n * pairs of elements from each chunk, filling in missing values from the\n * shorter chunk with `None`. The returned chunk will have the length of the\n * longer chunk.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const zipAll = /*#__PURE__*/Dual.dual(2, (self, that) => zipAllWith(self, that, (a, b) => [O.some(a), O.some(b)], a => [O.some(a), O.none()], b => [O.none(), O.some(b)]));\n/**\n * Zips with chunk with the specified chunk to produce a new chunk with\n * pairs of elements from each chunk combined using the specified function\n * `both`. If one chunk is shorter than the other uses the specified\n * function `left` or `right` to map the element that does exist to the\n * result type.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const zipAllWith = /*#__PURE__*/Dual.dual(5, (self, that, f, left, right) => {\n  const length = Math.max(self.length, that.length);\n  if (length === 0) {\n    return _empty;\n  }\n  const leftarr = toReadonlyArray(self);\n  const rightArr = toReadonlyArray(that);\n  let i = 0;\n  let j = 0;\n  let k = 0;\n  const leftLength = leftarr.length;\n  const rightLength = rightArr.length;\n  const builder = new Array(length);\n  while (i < length) {\n    if (j < leftLength && k < rightLength) {\n      builder[i] = f(leftarr[j], rightArr[k]);\n      i++;\n      j++;\n      k++;\n    } else if (j < leftLength) {\n      builder[i] = left(leftarr[j]);\n      i++;\n      j++;\n    } else if (k < rightLength) {\n      builder[i] = right(rightArr[k]);\n      i++;\n      k++;\n    }\n  }\n  return unsafeFromArray(builder);\n});\n/**\n * Zips this chunk crosswise with the specified chunk using the specified combiner.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const crossWith = /*#__PURE__*/Dual.dual(3, (self, that, f) => flatMap(self, a => pipe(that, map(b => f(a, b)))));\n/**\n * Zips this chunk crosswise with the specified chunk.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const cross = /*#__PURE__*/Dual.dual(2, (self, that) => crossWith(self, that, (a, b) => [a, b]));\n/**\n * Zips this chunk with the index of every element, starting from the initial\n * index value.\n *\n * @category elements\n * @since 1.0.0\n */\nexport const zipWithIndex = self => zipWithIndexOffset(0)(self);\n/**\n * Zips this chunk with the index of every element, starting from the initial\n * index value.\n *\n * @category elements\n * @since 1.0.0\n */\nexport const zipWithIndexOffset = /*#__PURE__*/Dual.dual(2, (self, offset) => {\n  const iterator = self[Symbol.iterator]();\n  let next;\n  let i = offset;\n  const builder = [];\n  while (!(next = iterator.next()).done) {\n    builder.push([next.value, i]);\n    i = i + 1;\n  }\n  return unsafeFromArray(builder);\n});\n/**\n * Delete the element at the specified index, creating a new `Chunk`,\n * or returning the input if the index is out of bounds.\n *\n * @category mutations\n * @since 1.0.0\n */\nexport const remove = /*#__PURE__*/Dual.dual(2, (self, i) => pipe(self, toReadonlyArray, RA.remove(i), unsafeFromArray));\n/**\n * Change the element at the specified index, creating a new `Chunk`,\n * or returning the input if the index is out of bounds.\n *\n * @category mutations\n * @since 1.0.0\n */\nexport const replace = /*#__PURE__*/Dual.dual(3, (self, i, b) => modify(self, i, () => b));\n/**\n * @category mutations\n * @since 1.0.0\n */\nexport const replaceOption = /*#__PURE__*/Dual.dual(3, (self, i, b) => modifyOption(self, i, () => b));\n/**\n * Apply a function to the element at the specified index, creating a new `Chunk`,\n * or returning the input if the index is out of bounds.\n *\n * @category mutations\n * @since 1.0.0\n */\nexport const modify = /*#__PURE__*/Dual.dual(3, (self, i, f) => pipe(modifyOption(self, i, f), O.getOrElse(() => self)));\n/**\n * @category mutations\n * @since 1.0.0\n */\nexport const modifyOption = /*#__PURE__*/Dual.dual(3, (self, i, f) => pipe(self, toReadonlyArray, RA.modifyOption(i, f), O.map(unsafeFromArray)));\n/**\n * Returns the first element of this non empty chunk.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const headNonEmpty = unsafeHead;\n/**\n * Returns every elements after the first.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const tailNonEmpty = self => drop(self, 1);\n//# sourceMappingURL=Chunk.mjs.map","import * as Debug from \"@effect/io/Debug\";\nimport * as OpCodes from \"@effect/io/internal_effect_untraced/opCodes/configError\";\nimport * as Either from \"@fp-ts/core/Either\";\nimport { constFalse, constTrue } from \"@fp-ts/core/Function\";\nimport * as Chunk from \"@fp-ts/data/Chunk\";\n/** @internal */\nconst ConfigErrorSymbolKey = \"@effect/io/Config/Error\";\n/** @internal */\nexport const ConfigErrorTypeId = /*#__PURE__*/Symbol.for(ConfigErrorSymbolKey);\n/** @internal */\nexport const proto = {\n  [ConfigErrorTypeId]: ConfigErrorTypeId\n};\n/** @internal */\nexport const And = (self, that) => {\n  const error = Object.create(proto);\n  error._tag = OpCodes.OP_AND;\n  error.left = self;\n  error.right = that;\n  Object.defineProperty(error, \"toString\", {\n    enumerable: false,\n    value() {\n      return `${this.left} and ${this.right}`;\n    }\n  });\n  return error;\n};\n/** @internal */\nexport const Or = (self, that) => {\n  const error = Object.create(proto);\n  error._tag = OpCodes.OP_OR;\n  error.left = self;\n  error.right = that;\n  Object.defineProperty(error, \"toString\", {\n    enumerable: false,\n    value() {\n      return `${this.left} or ${this.right}`;\n    }\n  });\n  return error;\n};\n/** @internal */\nexport const InvalidData = (path, message) => {\n  const error = Object.create(proto);\n  error._tag = OpCodes.OP_INVALID_DATA;\n  error.path = path;\n  error.message = message;\n  Object.defineProperty(error, \"toString\", {\n    enumerable: false,\n    value() {\n      const path = Chunk.join(\".\")(this.path);\n      return `(Invalid data at ${path}: \"${this.message}\")`;\n    }\n  });\n  return error;\n};\n/** @internal */\nexport const MissingData = (path, message) => {\n  const error = Object.create(proto);\n  error._tag = OpCodes.OP_MISSING_DATA;\n  error.path = path;\n  error.message = message;\n  Object.defineProperty(error, \"toString\", {\n    enumerable: false,\n    value() {\n      const path = Chunk.join(\".\")(this.path);\n      return `(Missing data at ${path}: \"${this.message}\")`;\n    }\n  });\n  return error;\n};\n/** @internal */\nexport const SourceUnavailable = (path, message, cause) => {\n  const error = Object.create(proto);\n  error._tag = OpCodes.OP_SOURCE_UNAVAILABLE;\n  error.path = path;\n  error.message = message;\n  error.cause = cause;\n  Object.defineProperty(error, \"toString\", {\n    enumerable: false,\n    value() {\n      const path = Chunk.join(\".\")(this.path);\n      return `(Source unavailable at ${path}: \"${this.message}\")`;\n    }\n  });\n  return error;\n};\n/** @internal */\nexport const Unsupported = (path, message) => {\n  const error = Object.create(proto);\n  error._tag = OpCodes.OP_UNSUPPORTED;\n  error.path = path;\n  error.message = message;\n  Object.defineProperty(error, \"toString\", {\n    enumerable: false,\n    value() {\n      const path = Chunk.join(\".\")(this.path);\n      return `(Unsupported operation at ${path}: \"${this.message}\")`;\n    }\n  });\n  return error;\n};\n/** @internal */\nexport const isConfigError = u => typeof u === \"object\" && u != null && ConfigErrorTypeId in u;\n/** @internal */\nexport const isAnd = self => self._tag === OpCodes.OP_AND;\n/** @internal */\nexport const isOr = self => self._tag === OpCodes.OP_OR;\n/** @internal */\nexport const isInvalidData = self => self._tag === OpCodes.OP_INVALID_DATA;\n/** @internal */\nexport const isMissingData = self => self._tag === OpCodes.OP_MISSING_DATA;\n/** @internal */\nexport const isSourceUnavailable = self => self._tag === OpCodes.OP_SOURCE_UNAVAILABLE;\n/** @internal */\nexport const isUnsupported = self => self._tag === OpCodes.OP_UNSUPPORTED;\n/** @internal */\nexport const prefixed = /*#__PURE__*/Debug.dual(2, (self, prefix) => {\n  switch (self._tag) {\n    case OpCodes.OP_AND:\n      {\n        return And(prefixed(prefix)(self.left), prefixed(prefix)(self.right));\n      }\n    case OpCodes.OP_OR:\n      {\n        return Or(prefixed(prefix)(self.left), prefixed(prefix)(self.right));\n      }\n    case OpCodes.OP_INVALID_DATA:\n      {\n        return InvalidData(Chunk.concat(self.path)(prefix), self.message);\n      }\n    case OpCodes.OP_MISSING_DATA:\n      {\n        return MissingData(Chunk.concat(self.path)(prefix), self.message);\n      }\n    case OpCodes.OP_SOURCE_UNAVAILABLE:\n      {\n        return SourceUnavailable(Chunk.concat(self.path)(prefix), self.message, self.cause);\n      }\n    case OpCodes.OP_UNSUPPORTED:\n      {\n        return Unsupported(Chunk.concat(self.path)(prefix), self.message);\n      }\n  }\n});\n/** @internal */\nconst IsMissingDataOnlyReducer = {\n  andCase: (_, left, right) => left && right,\n  orCase: (_, left, right) => left || right,\n  invalidDataCase: constFalse,\n  missingDataCase: constTrue,\n  sourceUnavailableCase: constFalse,\n  unsupportedCase: constFalse\n};\n/** @internal */\nexport const reduceWithContext = /*#__PURE__*/Debug.dual(3, (self, context, reducer) => {\n  const input = [self];\n  const output = [];\n  while (input.length > 0) {\n    const error = input.pop();\n    switch (error._tag) {\n      case OpCodes.OP_AND:\n        {\n          input.push(error.right);\n          input.push(error.left);\n          output.push(Either.left({\n            _tag: \"AndCase\"\n          }));\n          break;\n        }\n      case OpCodes.OP_OR:\n        {\n          input.push(error.right);\n          input.push(error.left);\n          output.push(Either.left({\n            _tag: \"OrCase\"\n          }));\n          break;\n        }\n      case OpCodes.OP_INVALID_DATA:\n        {\n          output.push(Either.right(reducer.invalidDataCase(context, error.path, error.message)));\n          break;\n        }\n      case OpCodes.OP_MISSING_DATA:\n        {\n          output.push(Either.right(reducer.missingDataCase(context, error.path, error.message)));\n          break;\n        }\n      case OpCodes.OP_SOURCE_UNAVAILABLE:\n        {\n          output.push(Either.right(reducer.sourceUnavailableCase(context, error.path, error.message, error.cause)));\n          break;\n        }\n      case OpCodes.OP_UNSUPPORTED:\n        {\n          output.push(Either.right(reducer.unsupportedCase(context, error.path, error.message)));\n          break;\n        }\n    }\n  }\n  const accumulator = [];\n  while (output.length > 0) {\n    const either = output.pop();\n    switch (either._tag) {\n      case \"Left\":\n        {\n          switch (either.left._tag) {\n            case \"AndCase\":\n              {\n                const left = accumulator.pop();\n                const right = accumulator.pop();\n                const value = reducer.andCase(context, left, right);\n                accumulator.push(value);\n                break;\n              }\n            case \"OrCase\":\n              {\n                const left = accumulator.pop();\n                const right = accumulator.pop();\n                const value = reducer.orCase(context, left, right);\n                accumulator.push(value);\n                break;\n              }\n          }\n          break;\n        }\n      case \"Right\":\n        {\n          accumulator.push(either.right);\n          break;\n        }\n    }\n  }\n  if (accumulator.length === 0) {\n    throw new Error(\"BUG: ConfigError.reduceWithContext - please report an issue at https://github.com/Effect-TS/io/issues\");\n  }\n  return accumulator.pop();\n});\n/** @internal */\nexport const isMissingDataOnly = self => reduceWithContext(self, void 0, IsMissingDataOnlyReducer);\n//# sourceMappingURL=configError.mjs.map","import * as internal from \"@effect/io/internal_effect_untraced/configError\";\n/**\n * @since 1.0.0\n * @category symbols\n */\nexport const ConfigErrorTypeId = internal.ConfigErrorTypeId;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const And = internal.And;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const Or = internal.Or;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const MissingData = internal.MissingData;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const InvalidData = internal.InvalidData;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const SourceUnavailable = internal.SourceUnavailable;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const Unsupported = internal.Unsupported;\n/**\n * Returns `true` if the specified value is a `ConfigError`, `false` otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexport const isConfigError = internal.isConfigError;\n/**\n * Returns `true` if the specified `ConfigError` is an `And`, `false` otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexport const isAnd = internal.isAnd;\n/**\n * Returns `true` if the specified `ConfigError` is an `Or`, `false` otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexport const isOr = internal.isOr;\n/**\n * Returns `true` if the specified `ConfigError` is an `InvalidData`, `false`\n * otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexport const isInvalidData = internal.isInvalidData;\n/**\n * Returns `true` if the specified `ConfigError` is an `MissingData`, `false`\n * otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexport const isMissingData = internal.isMissingData;\n/**\n * Returns `true` if the specified `ConfigError` contains only `MissingData` errors, `false` otherwise.\n *\n * @since 1.0.0\n * @categer getters\n */\nexport const isMissingDataOnly = internal.isMissingDataOnly;\n/**\n * Returns `true` if the specified `ConfigError` is a `SourceUnavailable`,\n * `false` otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexport const isSourceUnavailable = internal.isSourceUnavailable;\n/**\n * Returns `true` if the specified `ConfigError` is an `Unsupported`, `false`\n * otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexport const isUnsupported = internal.isUnsupported;\n/**\n * @since 1.0.0\n * @category mutations\n */\nexport const prefixed = internal.prefixed;\n/**\n * @since 1.0.0\n * @category folding\n */\nexport const reduceWithContext = internal.reduceWithContext;\n//# sourceMappingURL=Error.mjs.map","import * as Chunk from \"@fp-ts/data/Chunk\";\nimport * as Equal from \"@fp-ts/data/Equal\";\nimport * as Hash from \"@fp-ts/data/Hash\";\n/** @internal */\nconst ConfigSecretSymbolKey = \"@effect/io/Config/Secret\";\n/** @internal */\nexport const ConfigSecretTypeId = /*#__PURE__*/Symbol.for(ConfigSecretSymbolKey);\n/** @internal */\nexport const proto = {\n  [ConfigSecretTypeId]: ConfigSecretTypeId,\n  [Hash.symbol]() {\n    return Hash.combine(Hash.array(this.raw))(Hash.hash(ConfigSecretSymbolKey));\n  },\n  [Equal.symbol](that) {\n    return isConfigSecret(that) && this.raw.length === that.raw.length && this.raw.every((v, i) => Equal.equals(v, that.raw[i]));\n  }\n};\n/** @internal */\nexport const isConfigSecret = u => {\n  return typeof u === \"object\" && u != null && ConfigSecretTypeId in u;\n};\n/** @internal */\nexport const make = bytes => {\n  const secret = Object.create(proto);\n  Object.defineProperty(secret, \"toString\", {\n    enumerable: false,\n    value() {\n      return \"ConfigSecret(<redacted>)\";\n    }\n  });\n  Object.defineProperty(secret, \"raw\", {\n    enumerable: false,\n    value: bytes\n  });\n  return secret;\n};\n/** @internal */\nexport const fromChunk = chunk => {\n  return make(Chunk.toReadonlyArray(chunk).map(char => char.charCodeAt(0)));\n};\n/** @internal */\nexport const fromString = text => {\n  return make(text.split(\"\").map(char => char.charCodeAt(0)));\n};\n/** @internal */\nexport const value = self => {\n  return self.raw.map(byte => String.fromCharCode(byte)).join(\"\");\n};\n/** @internal */\nexport const unsafeWipe = self => {\n  for (let i = 0; i < self.raw.length; i++) {\n    self.raw[i] = 0;\n  }\n};\n//# sourceMappingURL=configSecret.mjs.map","/** @internal */\nexport const OP_CONSTANT = \"Constant\";\n/** @internal */\nexport const OP_FAIL = \"Fail\";\n/** @internal */\nexport const OP_FALLBACK = \"Fallback\";\n/** @internal */\nexport const OP_DESCRIBED = \"Described\";\n/** @internal */\nexport const OP_LAZY = \"Lazy\";\n/** @internal */\nexport const OP_MAP_OR_FAIL = \"MapOrFail\";\n/** @internal */\nexport const OP_NESTED = \"Nested\";\n/** @internal */\nexport const OP_PRIMITIVE = \"Primitive\";\n/** @internal */\nexport const OP_SEQUENCE = \"Sequence\";\n/** @internal */\nexport const OP_TABLE = \"Table\";\n/** @internal */\nexport const OP_ZIP_WITH = \"ZipWith\";\n//# sourceMappingURL=config.mjs.map","/** @internal */\nexport const SIZE = 5;\n/** @internal */\nexport const BUCKET_SIZE = /*#__PURE__*/Math.pow(2, SIZE);\n/** @internal */\nexport const MASK = BUCKET_SIZE - 1;\n/** @internal */\nexport const MAX_INDEX_NODE = BUCKET_SIZE / 2;\n/** @internal */\nexport const MIN_ARRAY_NODE = BUCKET_SIZE / 4;\n//# sourceMappingURL=config.mjs.map","import { MASK } from \"@fp-ts/data/internal/HashMap/config\";\n/**\n * Hamming weight.\n *\n * Taken from: http://jsperf.com/hamming-weight\n *\n * @internal\n */\nexport function popcount(x) {\n  x -= x >> 1 & 0x55555555;\n  x = (x & 0x33333333) + (x >> 2 & 0x33333333);\n  x = x + (x >> 4) & 0x0f0f0f0f;\n  x += x >> 8;\n  x += x >> 16;\n  return x & 0x7f;\n}\n/** @internal */\nexport function hashFragment(shift, h) {\n  return h >>> shift & MASK;\n}\n/** @internal */\nexport function toBitmap(x) {\n  return 1 << x;\n}\n/** @internal */\nexport function fromBitmap(bitmap, bit) {\n  return popcount(bitmap & bit - 1);\n}\n//# sourceMappingURL=bitwise.mjs.map","/** @internal */\nexport function arrayUpdate(mutate, at, v, arr) {\n  let out = arr;\n  if (!mutate) {\n    const len = arr.length;\n    out = new Array(len);\n    for (let i = 0; i < len; ++i) out[i] = arr[i];\n  }\n  out[at] = v;\n  return out;\n}\n/** @internal */\nexport function arraySpliceOut(mutate, at, arr) {\n  const newLen = arr.length - 1;\n  let i = 0;\n  let g = 0;\n  let out = arr;\n  if (mutate) {\n    i = g = at;\n  } else {\n    out = new Array(newLen);\n    while (i < at) out[g++] = arr[i++];\n  }\n  ;\n  ++i;\n  while (i <= newLen) out[g++] = arr[i++];\n  if (mutate) {\n    out.length = newLen;\n  }\n  return out;\n}\n/** @internal */\nexport function arraySpliceIn(mutate, at, v, arr) {\n  const len = arr.length;\n  if (mutate) {\n    let i = len;\n    while (i >= at) arr[i--] = arr[i];\n    arr[at] = v;\n    return arr;\n  }\n  let i = 0,\n    g = 0;\n  const out = new Array(len + 1);\n  while (i < at) out[g++] = arr[i++];\n  out[at] = v;\n  while (i < len) out[++g] = arr[i++];\n  return out;\n}\n//# sourceMappingURL=array.mjs.map","/** @internal */\nexport class Stack {\n  constructor(value, previous) {\n    this.value = value;\n    this.previous = previous;\n  }\n}\n//# sourceMappingURL=Stack.mjs.map","import * as O from \"@fp-ts/core/Option\";\nimport { equals } from \"@fp-ts/data/Equal\";\nimport { arraySpliceIn, arraySpliceOut, arrayUpdate } from \"@fp-ts/data/internal/HashMap/array\";\nimport { fromBitmap, hashFragment, toBitmap } from \"@fp-ts/data/internal/HashMap/bitwise\";\nimport { MAX_INDEX_NODE, MIN_ARRAY_NODE, SIZE } from \"@fp-ts/data/internal/HashMap/config\";\nimport { Stack } from \"@fp-ts/data/internal/Stack\";\n/** @internal */\nexport class EmptyNode {\n  constructor() {\n    this._tag = \"EmptyNode\";\n  }\n  modify(edit, _shift, f, hash, key, size) {\n    const v = f(O.none());\n    if (O.isNone(v)) return new EmptyNode();\n    ++size.value;\n    return new LeafNode(edit, hash, key, v);\n  }\n}\n/** @internal */\nexport function isEmptyNode(a) {\n  return a instanceof EmptyNode;\n}\n/** @internal */\nexport function isLeafNode(node) {\n  return isEmptyNode(node) || node._tag === \"LeafNode\" || node._tag === \"CollisionNode\";\n}\n/** @internal */\nexport function canEditNode(node, edit) {\n  return isEmptyNode(node) ? false : edit === node.edit;\n}\n/** @internal */\nexport class LeafNode {\n  constructor(edit, hash, key, value) {\n    this.edit = edit;\n    this.hash = hash;\n    this.key = key;\n    this.value = value;\n    this._tag = \"LeafNode\";\n  }\n  modify(edit, shift, f, hash, key, size) {\n    if (equals(key, this.key)) {\n      const v = f(this.value);\n      if (v === this.value) return this;else if (O.isNone(v)) {\n        ;\n        --size.value;\n        return new EmptyNode();\n      }\n      if (canEditNode(this, edit)) {\n        this.value = v;\n        return this;\n      }\n      return new LeafNode(edit, hash, key, v);\n    }\n    const v = f(O.none());\n    if (O.isNone(v)) return this;\n    ++size.value;\n    return mergeLeaves(edit, shift, this.hash, this, hash, new LeafNode(edit, hash, key, v));\n  }\n}\n/** @internal */\nexport class CollisionNode {\n  constructor(edit, hash, children) {\n    this.edit = edit;\n    this.hash = hash;\n    this.children = children;\n    this._tag = \"CollisionNode\";\n  }\n  modify(edit, shift, f, hash, key, size) {\n    if (hash === this.hash) {\n      const canEdit = canEditNode(this, edit);\n      const list = this.updateCollisionList(canEdit, edit, this.hash, this.children, f, key, size);\n      if (list === this.children) return this;\n      return list.length > 1 ? new CollisionNode(edit, this.hash, list) : list[0]; // collapse single element collision list\n    }\n\n    const v = f(O.none());\n    if (O.isNone(v)) return this;\n    ++size.value;\n    return mergeLeaves(edit, shift, this.hash, this, hash, new LeafNode(edit, hash, key, v));\n  }\n  updateCollisionList(mutate, edit, hash, list, f, key, size) {\n    const len = list.length;\n    for (let i = 0; i < len; ++i) {\n      const child = list[i];\n      if (\"key\" in child && equals(key, child.key)) {\n        const value = child.value;\n        const newValue = f(value);\n        if (newValue === value) return list;\n        if (O.isNone(newValue)) {\n          ;\n          --size.value;\n          return arraySpliceOut(mutate, i, list);\n        }\n        return arrayUpdate(mutate, i, new LeafNode(edit, hash, key, newValue), list);\n      }\n    }\n    const newValue = f(O.none());\n    if (O.isNone(newValue)) return list;\n    ++size.value;\n    return arrayUpdate(mutate, len, new LeafNode(edit, hash, key, newValue), list);\n  }\n}\n/** @internal */\nexport class IndexedNode {\n  constructor(edit, mask, children) {\n    this.edit = edit;\n    this.mask = mask;\n    this.children = children;\n    this._tag = \"IndexedNode\";\n  }\n  modify(edit, shift, f, hash, key, size) {\n    const mask = this.mask;\n    const children = this.children;\n    const frag = hashFragment(shift, hash);\n    const bit = toBitmap(frag);\n    const indx = fromBitmap(mask, bit);\n    const exists = mask & bit;\n    const canEdit = canEditNode(this, edit);\n    if (!exists) {\n      const _newChild = new EmptyNode().modify(edit, shift + SIZE, f, hash, key, size);\n      if (!_newChild) return this;\n      return children.length >= MAX_INDEX_NODE ? expand(edit, frag, _newChild, mask, children) : new IndexedNode(edit, mask | bit, arraySpliceIn(canEdit, indx, _newChild, children));\n    }\n    const current = children[indx];\n    const child = current.modify(edit, shift + SIZE, f, hash, key, size);\n    if (current === child) return this;\n    let bitmap = mask;\n    let newChildren;\n    if (isEmptyNode(child)) {\n      // remove\n      bitmap &= ~bit;\n      if (!bitmap) return new EmptyNode();\n      if (children.length <= 2 && isLeafNode(children[indx ^ 1])) {\n        return children[indx ^ 1]; // collapse\n      }\n\n      newChildren = arraySpliceOut(canEdit, indx, children);\n    } else {\n      // modify\n      newChildren = arrayUpdate(canEdit, indx, child, children);\n    }\n    if (canEdit) {\n      this.mask = bitmap;\n      this.children = newChildren;\n      return this;\n    }\n    return new IndexedNode(edit, bitmap, newChildren);\n  }\n}\n/** @internal */\nexport class ArrayNode {\n  constructor(edit, size, children) {\n    this.edit = edit;\n    this.size = size;\n    this.children = children;\n    this._tag = \"ArrayNode\";\n  }\n  modify(edit, shift, f, hash, key, size) {\n    let count = this.size;\n    const children = this.children;\n    const frag = hashFragment(shift, hash);\n    const child = children[frag];\n    const newChild = (child || new EmptyNode()).modify(edit, shift + SIZE, f, hash, key, size);\n    if (child === newChild) return this;\n    const canEdit = canEditNode(this, edit);\n    let newChildren;\n    if (isEmptyNode(child) && !isEmptyNode(newChild)) {\n      // add\n      ;\n      ++count;\n      newChildren = arrayUpdate(canEdit, frag, newChild, children);\n    } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {\n      // remove\n      ;\n      --count;\n      if (count <= MIN_ARRAY_NODE) {\n        return pack(edit, count, frag, children);\n      }\n      newChildren = arrayUpdate(canEdit, frag, new EmptyNode(), children);\n    } else {\n      // modify\n      newChildren = arrayUpdate(canEdit, frag, newChild, children);\n    }\n    if (canEdit) {\n      this.size = count;\n      this.children = newChildren;\n      return this;\n    }\n    return new ArrayNode(edit, count, newChildren);\n  }\n}\nfunction pack(edit, count, removed, elements) {\n  const children = new Array(count - 1);\n  let g = 0;\n  let bitmap = 0;\n  for (let i = 0, len = elements.length; i < len; ++i) {\n    if (i !== removed) {\n      const elem = elements[i];\n      if (elem && !isEmptyNode(elem)) {\n        children[g++] = elem;\n        bitmap |= 1 << i;\n      }\n    }\n  }\n  return new IndexedNode(edit, bitmap, children);\n}\nfunction expand(edit, frag, child, bitmap, subNodes) {\n  const arr = [];\n  let bit = bitmap;\n  let count = 0;\n  for (let i = 0; bit; ++i) {\n    if (bit & 1) arr[i] = subNodes[count++];\n    bit >>>= 1;\n  }\n  arr[frag] = child;\n  return new ArrayNode(edit, count + 1, arr);\n}\nfunction mergeLeavesInner(edit, shift, h1, n1, h2, n2) {\n  if (h1 === h2) return new CollisionNode(edit, h1, [n2, n1]);\n  const subH1 = hashFragment(shift, h1);\n  const subH2 = hashFragment(shift, h2);\n  if (subH1 === subH2) {\n    return child => new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), [child]);\n  } else {\n    const children = subH1 < subH2 ? [n1, n2] : [n2, n1];\n    return new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), children);\n  }\n}\nfunction mergeLeaves(edit, shift, h1, n1, h2, n2) {\n  let stack = undefined;\n  let currentShift = shift;\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const res = mergeLeavesInner(edit, currentShift, h1, n1, h2, n2);\n    if (typeof res === \"function\") {\n      stack = new Stack(res, stack);\n      currentShift = currentShift + SIZE;\n    } else {\n      let final = res;\n      while (stack != null) {\n        final = stack.value(final);\n        stack = stack.previous;\n      }\n      return final;\n    }\n  }\n}\n//# sourceMappingURL=node.mjs.map","import { identity, pipe } from \"@fp-ts/core/Function\";\nimport * as Option from \"@fp-ts/core/Option\";\nimport * as Dual from \"@fp-ts/data/Dual\";\nimport * as Equal from \"@fp-ts/data/Equal\";\nimport * as Hash from \"@fp-ts/data/Hash\";\nimport { fromBitmap, hashFragment, toBitmap } from \"@fp-ts/data/internal/HashMap/bitwise\";\nimport { SIZE } from \"@fp-ts/data/internal/HashMap/config\";\nimport * as Node from \"@fp-ts/data/internal/HashMap/node\";\n/** @internal */\nexport const HashMapTypeId = /*#__PURE__*/Symbol.for(\"@fp-ts/data/HashMap\");\n/** @internal */\nexport class HashMapImpl {\n  constructor(_editable, _edit, _root, _size) {\n    this._editable = _editable;\n    this._edit = _edit;\n    this._root = _root;\n    this._size = _size;\n    this._id = HashMapTypeId;\n  }\n  [Symbol.iterator]() {\n    return new HashMapIterator(this, (k, v) => [k, v]);\n  }\n  [Hash.symbol]() {\n    let hash = Hash.hash(\"HashMap\");\n    for (const item of this) {\n      hash ^= Hash.combine(Hash.hash(item[0]))(Hash.hash(item[1]));\n    }\n    return hash;\n  }\n  [Equal.symbol](that) {\n    if (isHashMap(that)) {\n      if (that._size !== this._size) {\n        return false;\n      }\n      for (const item of this) {\n        const elem = pipe(that, getHash(item[0], Hash.hash(item[0])));\n        if (Option.isNone(elem)) {\n          return false;\n        } else {\n          if (!Equal.equals(item[1], elem.value)) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n  toString() {\n    return `HashMap(${Array.from(this).map(([k, v]) => `[${String(k)}, ${String(v)}]`).join(\", \")})`;\n  }\n  toJSON() {\n    return {\n      _tag: \"HashMap\",\n      values: Array.from(this)\n    };\n  }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return this.toJSON();\n  }\n}\nclass HashMapIterator {\n  constructor(map, f) {\n    this.map = map;\n    this.f = f;\n    this.v = visitLazy(this.map._root, this.f, undefined);\n  }\n  next() {\n    if (Option.isNone(this.v)) {\n      return {\n        done: true,\n        value: undefined\n      };\n    }\n    const v0 = this.v.value;\n    this.v = applyCont(v0.cont);\n    return {\n      done: false,\n      value: v0.value\n    };\n  }\n  [Symbol.iterator]() {\n    return new HashMapIterator(this.map, this.f);\n  }\n}\nconst applyCont = cont => cont ? visitLazyChildren(cont[0], cont[1], cont[2], cont[3], cont[4]) : Option.none();\nconst visitLazy = (node, f, cont = undefined) => {\n  switch (node._tag) {\n    case \"LeafNode\":\n      {\n        if (Option.isSome(node.value)) {\n          return Option.some({\n            value: f(node.key, node.value.value),\n            cont\n          });\n        }\n        return applyCont(cont);\n      }\n    case \"CollisionNode\":\n    case \"ArrayNode\":\n    case \"IndexedNode\":\n      {\n        const children = node.children;\n        return visitLazyChildren(children.length, children, 0, f, cont);\n      }\n    default:\n      {\n        return applyCont(cont);\n      }\n  }\n};\nconst visitLazyChildren = (len, children, i, f, cont) => {\n  while (i < len) {\n    const child = children[i++];\n    if (child && !Node.isEmptyNode(child)) {\n      return visitLazy(child, f, [len, children, i, f, cont]);\n    }\n  }\n  return applyCont(cont);\n};\n/** @internal */\nexport const empty = () => new HashMapImpl(false, 0, new Node.EmptyNode(), 0);\n/** @internal */\nexport const make = (...entries) => fromIterable(entries);\n/** @internal */\nexport const fromIterable = entries => {\n  const map = beginMutation(empty());\n  for (const entry of entries) {\n    set(entry[0], entry[1])(map);\n  }\n  return endMutation(map);\n};\n/** @internal */\nexport const isHashMap = u => typeof u === \"object\" && u != null && \"_id\" in u && u[\"_id\"] === HashMapTypeId;\n/** @internal */\nexport const isEmpty = self => self && Node.isEmptyNode(self._root);\n/** @internal */\nexport const get = /*#__PURE__*/Dual.dual(2, (self, key) => getHash(self, key, Hash.hash(key)));\n/** @internal */\nexport const getHash = /*#__PURE__*/Dual.dual(3, (self, key, hash) => {\n  let node = self._root;\n  let shift = 0;\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    switch (node._tag) {\n      case \"LeafNode\":\n        {\n          return Equal.equals(key, node.key) ? node.value : Option.none();\n        }\n      case \"CollisionNode\":\n        {\n          if (hash === node.hash) {\n            const children = node.children;\n            for (let i = 0, len = children.length; i < len; ++i) {\n              const child = children[i];\n              if (\"key\" in child && Equal.equals(key, child.key)) {\n                return child.value;\n              }\n            }\n          }\n          return Option.none();\n        }\n      case \"IndexedNode\":\n        {\n          const frag = hashFragment(shift, hash);\n          const bit = toBitmap(frag);\n          if (node.mask & bit) {\n            node = node.children[fromBitmap(node.mask, bit)];\n            shift += SIZE;\n            break;\n          }\n          return Option.none();\n        }\n      case \"ArrayNode\":\n        {\n          node = node.children[hashFragment(shift, hash)];\n          if (node) {\n            shift += SIZE;\n            break;\n          }\n          return Option.none();\n        }\n      default:\n        return Option.none();\n    }\n  }\n});\n/** @internal */\nexport const unsafeGet = /*#__PURE__*/Dual.dual(2, (self, key) => {\n  const element = getHash(self, key, Hash.hash(key));\n  if (Option.isNone(element)) {\n    throw new Error(\"Error: Expected map to contain key\");\n  }\n  return element.value;\n});\n/** @internal */\nexport const has = /*#__PURE__*/Dual.dual(2, (self, key) => Option.isSome(getHash(self, key, Hash.hash(key))));\n/** @internal */\nexport const hasHash = /*#__PURE__*/Dual.dual(3, (self, key, hash) => Option.isSome(getHash(self, key, hash)));\n/** @internal */\nexport const set = /*#__PURE__*/Dual.dual(3, (self, key, value) => modifyAt(self, key, () => Option.some(value)));\n/** @internal */\nexport const setTree = /*#__PURE__*/Dual.dual(3, (self, newRoot, newSize) => {\n  if (self._editable) {\n    ;\n    self._root = newRoot;\n    self._size = newSize;\n    return self;\n  }\n  return newRoot === self._root ? self : new HashMapImpl(self._editable, self._edit, newRoot, newSize);\n});\n/** @internal */\nexport const keys = self => new HashMapIterator(self, key => key);\n/** @internal */\nexport const values = self => new HashMapIterator(self, (_, value) => value);\n/** @internal */\nexport const size = self => self._size;\n/** @internal */\nexport const beginMutation = self => new HashMapImpl(true, self._edit + 1, self._root, self._size);\n/** @internal */\nexport const endMutation = self => {\n  ;\n  self._editable = false;\n  return self;\n};\n/** @internal */\nexport const mutate = /*#__PURE__*/Dual.dual(2, (self, f) => {\n  const transient = beginMutation(self);\n  f(transient);\n  return endMutation(transient);\n});\n/** @internal */\nexport const modifyAt = /*#__PURE__*/Dual.dual(3, (self, key, f) => modifyHash(self, key, Hash.hash(key), f));\n/** @internal */\nexport const modifyHash = /*#__PURE__*/Dual.dual(4, (self, key, hash, f) => {\n  const size = {\n    value: self._size\n  };\n  const newRoot = self._root.modify(self._editable ? self._edit : NaN, 0, f, hash, key, size);\n  return pipe(self, setTree(newRoot, size.value));\n});\n/** @internal */\nexport const modify = /*#__PURE__*/Dual.dual(3, (self, key, f) => modifyAt(self, key, Option.map(f)));\n/** @internal */\nexport const union = /*#__PURE__*/Dual.dual(2, (self, that) => {\n  const result = beginMutation(self);\n  forEachWithIndex(that, (v, k) => set(result, k, v));\n  return endMutation(result);\n});\n/** @internal */\nexport const remove = /*#__PURE__*/Dual.dual(2, (self, key) => modifyAt(self, key, Option.none));\n/** @internal */\nexport const removeMany = /*#__PURE__*/Dual.dual(2, (self, keys) => mutate(self, map => {\n  for (const key of keys) {\n    remove(key)(map);\n  }\n}));\n/** @internal */\nexport const map = /*#__PURE__*/Dual.dual(2, (self, f) => mapWithIndex(self, v => f(v)));\n/**\n * Maps over the entries of the `HashMap` using the specified function.\n *\n * @since 1.0.0\n * @category mapping\n */\nexport const mapWithIndex = /*#__PURE__*/Dual.dual(2, (self, f) => reduceWithIndex(self, empty(), (map, value, key) => set(map, key, f(value, key))));\n/** @internal */\nexport const flatMap = /*#__PURE__*/Dual.dual(2, (self, f) => flatMapWithIndex(self, v => f(v)));\n/** @internal */\nexport const flatMapWithIndex = /*#__PURE__*/Dual.dual(2, (self, f) => reduceWithIndex(self, empty(), (zero, value, key) => mutate(zero, map => forEachWithIndex(f(value, key), (value, key) => set(map, key, value)))));\n/** @internal */\nexport const forEach = /*#__PURE__*/Dual.dual(2, (self, f) => forEachWithIndex(self, value => f(value)));\n/** @internal */\nexport const forEachWithIndex = /*#__PURE__*/Dual.dual(2, (self, f) => reduceWithIndex(self, void 0, (_, value, key) => f(value, key)));\n/** @internal */\nexport const reduce = /*#__PURE__*/Dual.dual(3, (self, z, f) => reduceWithIndex(self, z, (acc, v) => f(acc, v)));\n/** @internal */\nexport const reduceWithIndex = /*#__PURE__*/Dual.dual(3, (self, zero, f) => {\n  const root = self._root;\n  if (root._tag === \"LeafNode\") {\n    return Option.isSome(root.value) ? f(zero, root.value.value, root.key) : zero;\n  }\n  if (root._tag === \"EmptyNode\") {\n    return zero;\n  }\n  const toVisit = [root.children];\n  let children;\n  while (children = toVisit.pop()) {\n    for (let i = 0, len = children.length; i < len;) {\n      const child = children[i++];\n      if (child && !Node.isEmptyNode(child)) {\n        if (child._tag === \"LeafNode\") {\n          if (Option.isSome(child.value)) {\n            zero = f(zero, child.value.value, child.key);\n          }\n        } else {\n          toVisit.push(child.children);\n        }\n      }\n    }\n  }\n  return zero;\n});\n/** @internal */\nexport const filter = /*#__PURE__*/Dual.dual(2, (self, f) => filterWithIndex(self, f));\n/** @internal */\nexport const filterWithIndex = /*#__PURE__*/Dual.dual(2, (self, f) => mutate(empty(), map => {\n  for (const [k, a] of self) {\n    if (f(a, k)) {\n      set(map, k, a);\n    }\n  }\n}));\n/** @internal */\nexport const compact = self => filterMap(self, identity);\n/** @internal */\nexport const filterMap = /*#__PURE__*/Dual.dual(2, (self, f) => filterMapWithIndex(self, f));\n/** @internal */\nexport const filterMapWithIndex = /*#__PURE__*/Dual.dual(2, (self, f) => mutate(empty(), map => {\n  for (const [k, a] of self) {\n    const option = f(a, k);\n    if (Option.isSome(option)) {\n      set(map, k, option.value);\n    }\n  }\n}));\n//# sourceMappingURL=HashMap.mjs.map","import * as Dual from \"@fp-ts/data/Dual\";\nimport * as Equal from \"@fp-ts/data/Equal\";\nimport * as Hash from \"@fp-ts/data/Hash\";\nimport * as HM from \"@fp-ts/data/internal/HashMap\";\n/** @internal */\nexport const HashSetTypeId = /*#__PURE__*/Symbol.for(\"@fp-ts/data/HashSet\");\n/** @internal */\nexport class HashSetImpl {\n  constructor(_keyMap) {\n    this._keyMap = _keyMap;\n    this._id = HashSetTypeId;\n  }\n  [Symbol.iterator]() {\n    return HM.keys(this._keyMap);\n  }\n  [Hash.symbol]() {\n    return Hash.combine(Hash.hash(this._keyMap))(Hash.hash(\"HashSet\"));\n  }\n  [Equal.symbol](that) {\n    if (isHashSet(that)) {\n      return HM.size(this._keyMap) === HM.size(that._keyMap) && Equal.equals(this._keyMap, that._keyMap);\n    }\n    return false;\n  }\n  toString() {\n    return `HashSet(${Array.from(this).map(String).join(\", \")})`;\n  }\n  toJSON() {\n    return {\n      _tag: \"HashSet\",\n      values: Array.from(this)\n    };\n  }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return this.toJSON();\n  }\n}\n/** @internal */\nexport const isHashSet = u => typeof u === \"object\" && u != null && \"_id\" in u && u[\"_id\"] === HashSetTypeId;\n/** @internal */\nexport const empty = () => new HashSetImpl(HM.empty());\n/** @internal */\nexport const fromIterable = elements => {\n  const set = beginMutation(empty());\n  for (const value of elements) {\n    add(set, value);\n  }\n  return endMutation(set);\n};\n/** @internal */\nexport const make = (...elements) => {\n  const set = beginMutation(empty());\n  for (const value of elements) {\n    add(set, value);\n  }\n  return endMutation(set);\n};\n/** @internal */\nexport const has = /*#__PURE__*/Dual.dual(2, (self, value) => HM.has(self._keyMap, value));\n/** @internal */\nexport const some = /*#__PURE__*/Dual.dual(2, (self, f) => {\n  let found = false;\n  for (const value of self) {\n    found = f(value);\n    if (found) {\n      break;\n    }\n  }\n  return found;\n});\n/** @internal */\nexport const every = /*#__PURE__*/Dual.dual(2, (self, f) => !some(self, a => !f(a)));\n/** @internal */\nexport const isSubset = /*#__PURE__*/Dual.dual(2, (self, that) => every(self, value => has(that, value)));\n/** @internal */\nexport const values = self => HM.keys(self._keyMap);\n/** @internal */\nexport const size = self => HM.size(self._keyMap);\n/** @internal */\nexport const beginMutation = self => new HashSetImpl(HM.beginMutation(self._keyMap));\n/** @internal */\nexport const endMutation = self => {\n  ;\n  self._keyMap._editable = false;\n  return self;\n};\n/** @internal */\nexport const mutate = /*#__PURE__*/Dual.dual(2, (self, f) => {\n  const transient = beginMutation(self);\n  f(transient);\n  return endMutation(transient);\n});\n/** @internal */\nexport const add = /*#__PURE__*/Dual.dual(2, (self, value) => self._keyMap._editable ? (HM.set(value, true)(self._keyMap), self) : new HashSetImpl(HM.set(value, true)(self._keyMap)));\n/** @internal */\nexport const remove = /*#__PURE__*/Dual.dual(2, (self, value) => self._keyMap._editable ? (HM.remove(value)(self._keyMap), self) : new HashSetImpl(HM.remove(value)(self._keyMap)));\n/** @internal */\nexport const difference = /*#__PURE__*/Dual.dual(2, (self, that) => mutate(self, set => {\n  for (const value of that) {\n    remove(set, value);\n  }\n}));\n/** @internal */\nexport const intersection = /*#__PURE__*/Dual.dual(2, (self, that) => mutate(empty(), set => {\n  for (const value of that) {\n    if (has(value)(self)) {\n      add(value)(set);\n    }\n  }\n}));\n/** @internal */\nexport const union = /*#__PURE__*/Dual.dual(2, (self, that) => mutate(empty(), set => {\n  forEach(self, value => add(set, value));\n  for (const value of that) {\n    add(set, value);\n  }\n}));\n/** @internal */\nexport const toggle = /*#__PURE__*/Dual.dual(2, (self, value) => has(self, value) ? remove(self, value) : add(self, value));\n/** @internal */\nexport const map = /*#__PURE__*/Dual.dual(2, (self, f) => mutate(empty(), set => {\n  forEach(self, a => {\n    const b = f(a);\n    if (!has(set, b)) {\n      add(set, b);\n    }\n  });\n}));\n/** @internal */\nexport const flatMap = /*#__PURE__*/Dual.dual(2, (self, f) => mutate(empty(), set => {\n  forEach(self, a => {\n    for (const b of f(a)) {\n      if (!has(set, b)) {\n        add(set, b);\n      }\n    }\n  });\n}));\n/** @internal */\nexport const forEach = /*#__PURE__*/Dual.dual(2, (self, f) => HM.forEachWithIndex(self._keyMap, (_, k) => f(k)));\n/** @internal */\nexport const reduce = /*#__PURE__*/Dual.dual(3, (self, zero, f) => HM.reduceWithIndex(self._keyMap, zero, (z, _, a) => f(z, a)));\n/** @internal */\nexport const filter = /*#__PURE__*/Dual.dual(2, (self, f) => {\n  return mutate(empty(), set => {\n    const iterator = values(self);\n    let next;\n    while (!(next = iterator.next()).done) {\n      const value = next.value;\n      if (f(value)) {\n        add(set, value);\n      }\n    }\n  });\n});\n/** @internal */\nexport const partition = /*#__PURE__*/Dual.dual(2, (self, f) => {\n  const iterator = values(self);\n  let next;\n  const right = beginMutation(empty());\n  const left = beginMutation(empty());\n  while (!(next = iterator.next()).done) {\n    const value = next.value;\n    if (f(value)) {\n      add(right, value);\n    } else {\n      add(left, value);\n    }\n  }\n  return [endMutation(left), endMutation(right)];\n});\n//# sourceMappingURL=HashSet.mjs.map","/**\n * @since 1.0.0\n */\nimport * as HS from \"@fp-ts/data/internal/HashSet\";\nconst TypeId = HS.HashSetTypeId;\n/**\n * @since 1.0.0\n * @category refinements\n */\nexport const isHashSet = HS.isHashSet;\n/**\n * Creates an empty `HashSet`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const empty = HS.empty;\n/**\n * Construct a new `HashSet` from a `Collection` of values\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const fromIterable = HS.fromIterable;\n/**\n * Construct a new `HashSet` from a variable number of values.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const make = HS.make;\n/**\n * Checks if the specified value exists in the `HashSet`.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const has = HS.has;\n/**\n * Returns `true` if any value in the `HashSet` matches the specified predicate.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const some = HS.some;\n/**\n * Returns `true` only if all values in the `HashSet` match the specified\n * predicate.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const every = HS.every;\n/**\n * Returns `true` if and only if every element in the this `HashSet` is an\n * element of the second set,\n *\n * **NOTE**: the hash and equal of both sets must be the same.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const isSubset = HS.isSubset;\n/**\n * Returns an `IterableIterator` of the values in the `HashSet`.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const values = HS.values;\n/**\n * Calculates the number of values in the `HashSet`.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const size = HS.size;\n/**\n * Marks the `HashSet` as mutable.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const beginMutation = HS.beginMutation;\n/**\n * Marks the `HashSet` as immutable.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const endMutation = HS.endMutation;\n/**\n * Mutates the `HashSet` within the context of the provided function.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const mutate = HS.mutate;\n/**\n * Adds a value to the `HashSet`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const add = HS.add;\n/**\n * Removes a value from the `HashSet`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const remove = HS.remove;\n/**\n * Computes the set difference between this `HashSet` and the specified\n * `Iterable<A>`.\n *\n * **NOTE**: the hash and equal of the values in both the set and the iterable\n * must be the same.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const difference = HS.difference;\n/**\n * Returns a `HashSet` of values which are present in both this set and that\n * `Iterable<A>`.\n *\n * **NOTE**: the hash and equal of the values in both the set and the iterable\n * must be the same.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const intersection = HS.intersection;\n/**\n * Computes the set union `(`self` + `that`)` between this `HashSet` and the\n * specified `Iterable<A>`.\n *\n * **NOTE**: the hash and equal of the values in both the set and the iterable\n * must be the same.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const union = HS.union;\n/**\n * Checks if a value is present in the `HashSet`. If it is present, the value\n * will be removed from the `HashSet`, otherwise the value will be added to the\n * `HashSet`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const toggle = HS.toggle;\n/**\n * Maps over the values of the `HashSet` using the specified function.\n *\n * @since 1.0.0\n * @category mapping\n */\nexport const map = HS.map;\n/**\n * Chains over the values of the `HashSet` using the specified function.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexport const flatMap = HS.flatMap;\n/**\n * Applies the specified function to the values of the `HashSet`.\n *\n * @since 1.0.0\n * @category traversing\n */\nexport const forEach = HS.forEach;\n/**\n * Reduces the specified state over the values of the `HashSet`.\n *\n * @since 1.0.0\n * @category folding\n */\nexport const reduce = HS.reduce;\n/**\n * Filters values out of a `HashSet` using the specified predicate.\n *\n * @since 1.0.0\n * @category filtering\n */\nexport const filter = HS.filter;\n/**\n * Partition the values of a `HashSet` using the specified predicate.\n *\n * If a value matches the predicate, it will be placed into the `HashSet` on the\n * right side of the resulting `Tuple`, otherwise the value will be placed into\n * the left side.\n *\n * @since 1.0.0\n * @category partitioning\n */\nexport const partition = HS.partition;\n//# sourceMappingURL=HashSet.mjs.map","import * as ConfigError from \"@effect/io/Config/Error\";\nimport * as Debug from \"@effect/io/Debug\";\nimport * as configError from \"@effect/io/internal_effect_untraced/configError\";\nimport * as configSecret from \"@effect/io/internal_effect_untraced/configSecret\";\nimport * as OpCodes from \"@effect/io/internal_effect_untraced/opCodes/config\";\nimport * as Either from \"@fp-ts/core/Either\";\nimport { constTrue } from \"@fp-ts/core/Function\";\nimport * as Option from \"@fp-ts/core/Option\";\nimport * as Chunk from \"@fp-ts/data/Chunk\";\nimport * as HashSet from \"@fp-ts/data/HashSet\";\n/** @internal */\nconst ConfigSymbolKey = \"@effect/io/Config\";\n/** @internal */\nexport const ConfigTypeId = /*#__PURE__*/Symbol.for(ConfigSymbolKey);\n/** @internal */\nconst configVariance = {\n  _A: _ => _\n};\n/** @internal */\nconst proto = {\n  [ConfigTypeId]: configVariance\n};\n/** @internal */\nexport const bool = name => {\n  const config = primitive(\"a boolean property\", text => {\n    switch (text) {\n      case \"true\":\n      case \"yes\":\n      case \"on\":\n      case \"1\":\n        {\n          return Either.right(true);\n        }\n      case \"false\":\n      case \"no\":\n      case \"off\":\n      case \"0\":\n        {\n          return Either.right(false);\n        }\n      default:\n        {\n          const error = configError.InvalidData(Chunk.empty(), `Expected a boolean value, but received ${text}`);\n          return Either.left(error);\n        }\n    }\n  });\n  return name === undefined ? config : nested(name)(config);\n};\n/** @internal */\nexport const arrayOf = (config, name) => {\n  return map(Chunk.toReadonlyArray)(chunkOf(config, name));\n};\n/** @internal */\nexport const chunkOf = (config, name) => {\n  return name === undefined ? repeat(config) : nested(name)(repeat(config));\n};\n/** @internal */\nexport const date = name => {\n  const config = primitive(\"a date property\", text => {\n    const result = Date.parse(text);\n    if (Number.isNaN(result)) {\n      return Either.left(configError.InvalidData(Chunk.empty(), `Expected a date value but received ${text}`));\n    }\n    return Either.right(new Date(result));\n  });\n  return name === undefined ? config : nested(name)(config);\n};\n/** @internal */\nexport const defer = config => {\n  const lazy = Object.create(proto);\n  lazy._tag = OpCodes.OP_LAZY;\n  lazy.config = config;\n  return lazy;\n};\n/** @internal */\nexport const fail = message => {\n  const fail = Object.create(proto);\n  fail._tag = OpCodes.OP_FAIL;\n  fail.message = message;\n  fail.parse = () => Either.left(configError.Unsupported(Chunk.empty(), message));\n  return fail;\n};\n/** @internal */\nexport const float = name => {\n  const config = primitive(\"a float property\", text => {\n    const result = Number.parseFloat(text);\n    if (Number.isNaN(result)) {\n      return Either.left(configError.InvalidData(Chunk.empty(), `Expected an float value but received ${text}`));\n    }\n    return Either.right(result);\n  });\n  return name === undefined ? config : nested(name)(config);\n};\n/** @internal */\nexport const integer = name => {\n  const config = primitive(\"an integer property\", text => {\n    const result = Number.parseInt(text, 10);\n    if (Number.isNaN(result)) {\n      return Either.left(configError.InvalidData(Chunk.empty(), `Expected an integer value but received ${text}`));\n    }\n    return Either.right(result);\n  });\n  return name === undefined ? config : nested(name)(config);\n};\n/** @internal */\nexport const map = /*#__PURE__*/Debug.dual(2, (self, f) => mapOrFail(self, a => Either.right(f(a))));\n/** @internal */\nexport const mapAttempt = /*#__PURE__*/Debug.dual(2, (self, f) => mapOrFail(self, a => {\n  try {\n    return Either.right(f(a));\n  } catch (error) {\n    return Either.left(configError.InvalidData(Chunk.empty(), error instanceof Error ? error.message : `${error}`));\n  }\n}));\n/** @internal */\nexport const mapOrFail = /*#__PURE__*/Debug.dual(2, (self, f) => {\n  const mapOrFail = Object.create(proto);\n  mapOrFail._tag = OpCodes.OP_MAP_OR_FAIL;\n  mapOrFail.original = self;\n  mapOrFail.mapOrFail = f;\n  return mapOrFail;\n});\n/** @internal */\nexport const missingError = name => {\n  return self => {\n    return configError.MissingData(Chunk.empty(), `Expected ${self.description} with name ${name}`);\n  };\n};\n/** @internal */\nexport const nested = /*#__PURE__*/Debug.dual(2, (self, name) => {\n  const nested = Object.create(proto);\n  nested._tag = OpCodes.OP_NESTED;\n  nested.name = name;\n  nested.config = self;\n  return nested;\n});\n/** @internal */\nexport const orElse = /*#__PURE__*/Debug.dual(2, (self, that) => {\n  const fallback = Object.create(proto);\n  fallback._tag = OpCodes.OP_FALLBACK;\n  fallback.first = self;\n  fallback.second = defer(that);\n  fallback.condition = constTrue;\n  return fallback;\n});\n/** @internal */\nexport const orElseIf = /*#__PURE__*/Debug.dual(3, (self, that, condition) => {\n  const fallback = Object.create(proto);\n  fallback._tag = OpCodes.OP_FALLBACK;\n  fallback.first = self;\n  fallback.second = defer(that);\n  fallback.condition = condition;\n  return fallback;\n});\n/** @internal */\nexport const optional = self => {\n  return orElseIf(() => succeed(Option.none()), ConfigError.isMissingDataOnly)(map(Option.some)(self));\n};\n/** @internal */\nexport const primitive = (description, parse) => {\n  const primitive = Object.create(proto);\n  primitive._tag = OpCodes.OP_PRIMITIVE;\n  primitive.description = description;\n  primitive.parse = parse;\n  return primitive;\n};\n/** @internal */\nexport const repeat = self => {\n  const repeat = Object.create(proto);\n  repeat._tag = OpCodes.OP_SEQUENCE;\n  repeat.config = self;\n  return repeat;\n};\n/** @internal */\nexport const secret = name => {\n  const config = primitive(\"a secret property\", text => Either.right(configSecret.fromString(text)));\n  return name === undefined ? config : nested(name)(config);\n};\n/** @internal */\nexport const setOf = (config, name) => {\n  const newConfig = map(chunkOf(config), HashSet.fromIterable);\n  return name === undefined ? newConfig : nested(name)(newConfig);\n};\n/** @internal */\nexport const string = name => {\n  const config = primitive(\"a text property\", Either.right);\n  return name === undefined ? config : nested(name)(config);\n};\n/** @internal */\nexport const struct = r => {\n  const entries = Object.entries(r);\n  let result = map(value => ({\n    [entries[0][0]]: value\n  }))(entries[0][1]);\n  if (entries.length === 1) {\n    return result;\n  }\n  const rest = entries.slice(1);\n  for (const [key, config] of rest) {\n    result = zipWith(config, (record, value) => ({\n      ...record,\n      [key]: value\n    }))(result);\n  }\n  return result;\n};\n/** @internal */\nexport const succeed = value => {\n  const constant = Object.create(proto);\n  constant._tag = OpCodes.OP_CONSTANT;\n  constant.value = value;\n  constant.parse = () => Either.right(value);\n  return constant;\n};\n/** @internal */\nexport const sync = value => {\n  return defer(() => succeed(value()));\n};\n/** @internal */\nexport const table = (config, name) => {\n  const table = Object.create(proto);\n  table._tag = OpCodes.OP_TABLE;\n  table.valueConfig = config;\n  return name === undefined ? table : nested(name)(table);\n};\n/** @internal */\nexport const tuple = (...tuple) => {\n  if (tuple.length === 1) {\n    return tuple[0];\n  }\n  let result = tuple[0];\n  const rest = tuple.slice(1);\n  for (const config of rest) {\n    result = zipWith(config, (tuple, value) => [...tuple, value])(result);\n  }\n  return result;\n};\n/**\n * @internal\n */\nexport const unwrap = wrapped => {\n  if (typeof wrapped === \"object\" && wrapped != null && ConfigTypeId in wrapped) {\n    return wrapped;\n  }\n  return struct(Object.fromEntries(Object.entries(wrapped).map(([k, a]) => [k, unwrap(a)])));\n};\n/** @internal */\nexport const validate = /*#__PURE__*/Debug.dual(3, (self, message, f) => mapOrFail(self, a => {\n  if (f(a)) {\n    return Either.right(a);\n  }\n  return Either.left(configError.InvalidData(Chunk.empty(), message));\n}));\n/** @internal */\nexport const withDefault = /*#__PURE__*/Debug.dual(2, (self, def) => orElseIf(self, () => succeed(def), ConfigError.isMissingDataOnly));\n/** @internal */\nexport const withDescription = /*#__PURE__*/Debug.dual(2, (self, description) => {\n  const described = Object.create(proto);\n  described._tag = OpCodes.OP_DESCRIBED;\n  described.config = self;\n  described.description = description;\n  return described;\n});\n/** @internal */\nexport const zip = /*#__PURE__*/Debug.dual(2, (self, that) => zipWith(self, that, (a, b) => [a, b]));\n/** @internal */\nexport const zipWith = /*#__PURE__*/Debug.dual(3, (self, that, f) => {\n  const zipWith = Object.create(proto);\n  zipWith._tag = OpCodes.OP_ZIP_WITH;\n  zipWith.left = self;\n  zipWith.right = that;\n  zipWith.zip = f;\n  return zipWith;\n});\n//# sourceMappingURL=config.mjs.map","import * as internal from \"@effect/io/internal_effect_untraced/config\";\n/**\n * @since 1.0.0\n * @category symbols\n */\nexport const ConfigTypeId = internal.ConfigTypeId;\n/**\n * Constructs a config for an array of values.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const arrayOf = internal.arrayOf;\n/**\n * Constructs a config for a boolean value.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const bool = internal.bool;\n/**\n * Constructs a config for a sequence of values.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const chunkOf = internal.chunkOf;\n/**\n * Constructs a config for a date value.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const date = internal.date;\n/**\n * Lazily constructs a config.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const defer = internal.defer;\n/**\n * Constructs a config that fails with the specified message.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const fail = internal.fail;\n/**\n * Constructs a config for a float value.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const float = internal.float;\n/**\n * Constructs a config for a integer value.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const integer = internal.integer;\n/**\n * Returns a  config whose structure is the same as this one, but which produces\n * a different value, constructed using the specified function.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const map = internal.map;\n/**\n * Returns a config whose structure is the same as this one, but which may\n * produce a different value, constructed using the specified function, which\n * may throw exceptions that will be translated into validation errors.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const mapAttempt = internal.mapAttempt;\n/**\n * Returns a new config whose structure is the samea as this one, but which\n * may produce a different value, constructed using the specified fallible\n * function.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const mapOrFail = internal.mapOrFail;\n/**\n * Returns a config that has this configuration nested as a property of the\n * specified name.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const nested = internal.nested;\n/**\n * Returns a config whose structure is preferentially described by this\n * config, but which falls back to the specified config if there is an issue\n * reading from this config.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const orElse = internal.orElse;\n/**\n * Returns configuration which reads from this configuration, but which falls\n * back to the specified configuration if reading from this configuration\n * fails with an error satisfying the specified predicate.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const orElseIf = internal.orElseIf;\n/**\n * Returns an optional version of this config, which will be `None` if the\n * data is missing from configuration, and `Some` otherwise.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const optional = internal.optional;\n/**\n * Constructs a new primitive config.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const primitive = internal.primitive;\n/**\n * Returns a config that describes a sequence of values, each of which has the\n * structure of this config.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const repeat = internal.repeat;\n/**\n * Constructs a config for a secret value.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const secret = internal.secret;\n/**\n * Constructs a config for a sequence of values.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const setOf = internal.setOf;\n/**\n * Constructs a config for a string value.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const string = internal.string;\n/**\n * Constructs a config from a record of configs.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const struct = internal.struct;\n/**\n * Constructs a config which contains the specified value.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const succeed = internal.succeed;\n/**\n * Constructs a config which contains the specified lazy value.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const sync = internal.sync;\n/**\n * Constructs a config for a sequence of values.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const table = internal.table;\n/**\n * Constructs a config from a tuple of configs.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const tuple = internal.tuple;\n/**\n * Constructs a config from some configuration wrapped with the `Wrap<A>` utility type.\n *\n * For example:\n *\n * ```\n * import { Config, unwrap } from \"@effect/io/Config\"\n *\n * interface Options { key: string }\n *\n * const makeConfig = (config: Config.Wrap<Options>): Config<Options> => unwrap(config)\n * ```\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const unwrap = internal.unwrap;\n/**\n * Returns a config that describes the same structure as this one, but which\n * performs validation during loading.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const validate = internal.validate;\n/**\n * Returns a config that describes the same structure as this one, but has the\n * specified default value in case the information cannot be found.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const withDefault = internal.withDefault;\n/**\n * Adds a description to this configuration, which is intended for humans.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const withDescription = internal.withDescription;\n/**\n * Returns a config that is the composition of this config and the specified\n * config.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const zip = internal.zip;\n/**\n * Returns a config that is the composes this config and the specified config\n * using the provided function.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const zipWith = internal.zipWith;\n//# sourceMappingURL=Config.mjs.map","/**\n * @since 1.0.0\n */\nimport * as Dual from \"@fp-ts/data/Dual\";\nimport * as Equal from \"@fp-ts/data/Equal\";\nconst TypeId = /*#__PURE__*/Symbol.for(\"@fp-ts/data/MutableRef\");\nclass MutableRefImpl {\n  constructor(current) {\n    this.current = current;\n    this._T = _ => _;\n    this._id = TypeId;\n  }\n  get() {\n    return this.current;\n  }\n  set(value) {\n    this.current = value;\n    return this;\n  }\n  setAndGet(value) {\n    this.current = value;\n    return this.current;\n  }\n  getAndSet(value) {\n    const ret = this.current;\n    this.current = value;\n    return ret;\n  }\n  compareAndSet(oldValue, newValue) {\n    if (Equal.equals(oldValue, this.current)) {\n      this.current = newValue;\n      return true;\n    }\n    return false;\n  }\n  pipe(f) {\n    return f(this);\n  }\n  update(f) {\n    return this.set(f(this.get()));\n  }\n  updateAndGet(f) {\n    return this.setAndGet(f(this.get()));\n  }\n  getAndUpdate(f) {\n    return this.getAndSet(f(this.get()));\n  }\n  toString() {\n    return `MutableRef(${String(this.current)})`;\n  }\n  toJSON() {\n    return {\n      _tag: \"MutableRef\",\n      current: this.current\n    };\n  }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return this.toJSON();\n  }\n}\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const make = value => new MutableRefImpl(value);\n/**\n * @since 1.0.0\n * @category general\n */\nexport const compareAndSet = /*#__PURE__*/Dual.dual(3, (self, oldValue, newValue) => self.compareAndSet(oldValue, newValue));\n/**\n * @since 1.0.0\n * @category numeric\n */\nexport const decrement = self => self.update(n => n - 1);\n/**\n * @since 1.0.0\n * @category numeric\n */\nexport const decrementAndGet = self => self.updateAndGet(n => n - 1);\n/**\n * @since 1.0.0\n * @category general\n */\nexport const get = self => self.current;\n/**\n * @since 1.0.0\n * @category numeric\n */\nexport const getAndDecrement = self => self.getAndUpdate(n => n - 1);\n/**\n * @since 1.0.0\n * @category numeric\n */\nexport const getAndIncrement = self => self.getAndUpdate(n => n + 1);\n/**\n * @since 1.0.0\n * @category general\n */\nexport const getAndSet = /*#__PURE__*/Dual.dual(2, (self, value) => self.getAndSet(value));\n/**\n * @since 1.0.0\n * @category general\n */\nexport const getAndUpdate = /*#__PURE__*/Dual.dual(2, (self, f) => self.getAndUpdate(f));\n/**\n * @since 1.0.0\n * @category numeric\n */\nexport const increment = self => self.update(n => n + 1);\n/**\n * @since 1.0.0\n * @category numeric\n */\nexport const incrementAndGet = self => self.updateAndGet(n => n + 1);\n/**\n * @since 1.0.0\n * @category general\n */\nexport const set = /*#__PURE__*/Dual.dual(2, (self, value) => self.set(value));\n/**\n * @since 1.0.0\n * @category general\n */\nexport const setAndGet = /*#__PURE__*/Dual.dual(2, (self, value) => self.setAndGet(value));\n/**\n * @since 1.0.0\n * @category general\n */\nexport const update = /*#__PURE__*/Dual.dual(2, (self, f) => self.update(f));\n/**\n * @since 1.0.0\n * @category general\n */\nexport const updateAndGet = /*#__PURE__*/Dual.dual(2, (self, f) => self.updateAndGet(f));\n/**\n * @since 1.0.0\n * @category boolean\n */\nexport const toggle = self => self.update(_ => !_);\n//# sourceMappingURL=MutableRef.mjs.map","var _a, _b, _c;\nimport * as Debug from \"@effect/io/Debug\";\nimport * as Option from \"@fp-ts/core/Option\";\nimport * as Equal from \"@fp-ts/data/Equal\";\nimport * as Hash from \"@fp-ts/data/Hash\";\nimport * as HashSet from \"@fp-ts/data/HashSet\";\nimport * as MutableRef from \"@fp-ts/data/MutableRef\";\n/** @internal */\nconst FiberIdSymbolKey = \"@effect/io/Fiber/Id\";\n/** @internal */\nexport const FiberIdTypeId = /*#__PURE__*/Symbol.for(FiberIdSymbolKey);\n/** @internal */\nconst OP_NONE = \"None\";\n/** @internal */\nconst OP_RUNTIME = \"Runtime\";\n/** @internal */\nconst OP_COMPOSITE = \"Composite\";\n/** @internal */\nclass None {\n  constructor() {\n    this[_a] = FiberIdTypeId;\n    this._tag = OP_NONE;\n  }\n  [(_a = FiberIdTypeId, Hash.symbol)]() {\n    return Hash.combine(Hash.hash(this._tag))(Hash.hash(FiberIdSymbolKey));\n  }\n  [Equal.symbol](that) {\n    return isFiberId(that) && that._tag === OP_NONE;\n  }\n}\n/** @internal */\nclass Runtime {\n  constructor(id, startTimeMillis) {\n    this.id = id;\n    this.startTimeMillis = startTimeMillis;\n    this[_b] = FiberIdTypeId;\n    this._tag = OP_RUNTIME;\n  }\n  [(_b = FiberIdTypeId, Hash.symbol)]() {\n    return Hash.combine(Hash.hash(this.startTimeMillis))(Hash.combine(Hash.hash(this.id))(Hash.combine(Hash.hash(this._tag))(Hash.hash(FiberIdSymbolKey))));\n  }\n  [Equal.symbol](that) {\n    return isFiberId(that) && that._tag === OP_RUNTIME && this.id === that.id && this.startTimeMillis === that.startTimeMillis;\n  }\n}\n/** @internal */\nclass Composite {\n  constructor(left, right) {\n    this.left = left;\n    this.right = right;\n    this[_c] = FiberIdTypeId;\n    this._tag = OP_COMPOSITE;\n  }\n  [(_c = FiberIdTypeId, Hash.symbol)]() {\n    return Hash.combine(Hash.hash(this.right))(Hash.combine(Hash.hash(this.left))(Hash.combine(Hash.hash(this._tag))(Hash.hash(FiberIdSymbolKey))));\n  }\n  [Equal.symbol](that) {\n    return isFiberId(that) && that._tag === OP_COMPOSITE && Equal.equals(this.left, that.left) && Equal.equals(this.right, that.right);\n  }\n}\n/** @internal */\nexport const none = /*#__PURE__*/new None();\n/** @internal */\nexport const runtime = (id, startTimeMillis) => {\n  return new Runtime(id, startTimeMillis);\n};\n/** @internal */\nexport const composite = (left, right) => {\n  return new Composite(left, right);\n};\n/** @internal */\nexport const isFiberId = self => {\n  return typeof self === \"object\" && self != null && FiberIdTypeId in self;\n};\n/** @internal */\nexport const isNone = self => {\n  return self._tag === OP_NONE || HashSet.every(id => isNone(id))(toSet(self));\n};\n/** @internal */\nexport const isRuntime = self => {\n  return self._tag === OP_RUNTIME;\n};\n/** @internal */\nexport const isComposite = self => {\n  return self._tag === OP_COMPOSITE;\n};\n/** @internal */\nexport const combine = /*#__PURE__*/Debug.dual(2, (self, that) => {\n  if (self._tag === OP_NONE) {\n    return that;\n  }\n  if (that._tag === OP_NONE) {\n    return self;\n  }\n  return new Composite(self, that);\n});\n/** @internal */\nexport const combineAll = fiberIds => {\n  return HashSet.reduce(none, (a, b) => combine(b)(a))(fiberIds);\n};\n/** @internal */\nexport const getOrElse = /*#__PURE__*/Debug.dual(2, (self, that) => isNone(self) ? that : self);\n/** @internal */\nexport const ids = self => {\n  switch (self._tag) {\n    case OP_NONE:\n      {\n        return HashSet.empty();\n      }\n    case OP_RUNTIME:\n      {\n        return HashSet.make(self.id);\n      }\n    case OP_COMPOSITE:\n      {\n        return HashSet.union(ids(self.right))(ids(self.left));\n      }\n  }\n};\nconst _fiberCounter = /*#__PURE__*/MutableRef.make(0);\n/** @internal */\nexport const make = (id, startTimeSeconds) => {\n  return new Runtime(id, startTimeSeconds);\n};\n/** @internal */\nexport const threadName = self => {\n  const identifiers = Array.from(ids(self)).map(n => `#${n}`).join(\",\");\n  return identifiers;\n};\n/** @internal */\nexport const toOption = self => {\n  const fiberIds = toSet(self);\n  if (HashSet.size(fiberIds) === 0) {\n    return Option.none();\n  }\n  let first = true;\n  let acc;\n  for (const fiberId of fiberIds) {\n    if (first) {\n      acc = fiberId;\n      first = false;\n    } else {\n      // @ts-expect-error\n      acc = combine(fiberId)(acc);\n    }\n  }\n  // @ts-expect-error\n  return Option.some(acc);\n};\n/** @internal */\nexport const toSet = self => {\n  switch (self._tag) {\n    case OP_NONE:\n      {\n        return HashSet.empty();\n      }\n    case OP_RUNTIME:\n      {\n        return HashSet.make(self);\n      }\n    case OP_COMPOSITE:\n      {\n        return HashSet.union(toSet(self.right))(toSet(self.left));\n      }\n  }\n};\n/** @internal */\nexport const unsafeMake = () => {\n  const id = MutableRef.get(_fiberCounter);\n  MutableRef.set(id + 1)(_fiberCounter);\n  return new Runtime(id, new Date().getTime());\n};\n//# sourceMappingURL=fiberId.mjs.map","/**\n * @since 1.0.0\n */\nimport * as internal from \"@effect/io/internal_effect_untraced/fiberId\";\n/**\n * @since 1.0.0\n * @category symbols\n */\nexport const FiberIdTypeId = internal.FiberIdTypeId;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const none = internal.none;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const runtime = internal.runtime;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const composite = internal.composite;\n/**\n * Returns `true` if the specified unknown value is a `FiberId`, `false`\n * otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexport const isFiberId = internal.isFiberId;\n/**\n * Returns `true` if the `FiberId` is a `None`, `false` otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexport const isNone = internal.isNone;\n/**\n * Returns `true` if the `FiberId` is a `Runtime`, `false` otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexport const isRuntime = internal.isRuntime;\n/**\n * Returns `true` if the `FiberId` is a `Composite`, `false` otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexport const isComposite = internal.isComposite;\n/**\n * Combine two `FiberId`s.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const combine = internal.combine;\n/**\n * Combines a set of `FiberId`s into a single `FiberId`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const combineAll = internal.combineAll;\n/**\n * Returns this `FiberId` if it is not `None`, otherwise returns that `FiberId`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const getOrElse = internal.getOrElse;\n/**\n * Get the set of identifiers for this `FiberId`.\n *\n * @since 1.0.0\n * @category destructors\n */\nexport const ids = internal.ids;\n/**\n * Creates a new `FiberId`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const make = internal.make;\n/**\n * Creates a string representing the name of the current thread of execution\n * represented by the specified `FiberId`.\n *\n * @since 1.0.0\n * @category destructors\n */\nexport const threadName = internal.threadName;\n/**\n * Convert a `FiberId` into an `Option<FiberId>`.\n *\n * @since 1.0.0\n * @category destructors\n */\nexport const toOption = internal.toOption;\n/**\n * Convert a `FiberId` into a `HashSet<FiberId>`.\n *\n * @since 1.0.0\n * @category destructors\n */\nexport const toSet = internal.toSet;\n/**\n * Unsafely creates a new `FiberId`.\n *\n * @since 1.0.0\n * @category unsafe\n */\nexport const unsafeMake = internal.unsafeMake;\n//# sourceMappingURL=Id.mjs.map","/** @internal */\nexport const OP_DIE = \"Die\";\n/** @internal */\nexport const OP_EMPTY = \"Empty\";\n/** @internal */\nexport const OP_FAIL = \"Fail\";\n/** @internal */\nexport const OP_INTERRUPT = \"Interrupt\";\n/** @internal */\nexport const OP_ANNOTATED = \"Annotated\";\n/** @internal */\nexport const OP_PARALLEL = \"Parallel\";\n/** @internal */\nexport const OP_SEQUENTIAL = \"Sequential\";\n//# sourceMappingURL=cause.mjs.map","var _a;\nimport * as Debug from \"@effect/io/Debug\";\nimport * as FiberId from \"@effect/io/Fiber/Id\";\nimport * as OpCodes from \"@effect/io/internal_effect_untraced/opCodes/cause\";\nimport * as Either from \"@fp-ts/core/Either\";\nimport { constFalse, constTrue, identity } from \"@fp-ts/core/Function\";\nimport * as Option from \"@fp-ts/core/Option\";\nimport * as Chunk from \"@fp-ts/data/Chunk\";\nimport * as Equal from \"@fp-ts/data/Equal\";\nimport * as Hash from \"@fp-ts/data/Hash\";\nimport * as HashSet from \"@fp-ts/data/HashSet\";\n// -----------------------------------------------------------------------------\n// Models\n// -----------------------------------------------------------------------------\n/** @internal */\nconst CauseSymbolKey = \"@effect/io/Cause\";\n/** @internal */\nexport const CauseTypeId = /*#__PURE__*/Symbol.for(CauseSymbolKey);\n/** @internal */\nconst variance = {\n  _E: _ => _\n};\n/** @internal */\nconst proto = {\n  [CauseTypeId]: variance,\n  [Hash.symbol]() {\n    return Hash.combine(Hash.hash(flattenCause(this)))(Hash.hash(CauseSymbolKey));\n  },\n  [Equal.symbol](that) {\n    return isCause(that) && causeEquals(this, that);\n  }\n};\n// -----------------------------------------------------------------------------\n// Constructors\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const empty = /*#__PURE__*/(() => {\n  const o = /*#__PURE__*/Object.create(proto);\n  o._tag = OpCodes.OP_EMPTY;\n  return o;\n})();\n/** @internal */\nexport const fail = error => {\n  const o = Object.create(proto);\n  o._tag = OpCodes.OP_FAIL;\n  o.error = error;\n  return o;\n};\n/** @internal */\nexport const die = defect => {\n  const o = Object.create(proto);\n  o._tag = OpCodes.OP_DIE;\n  o.defect = defect;\n  return o;\n};\n/** @internal */\nexport const interrupt = fiberId => {\n  const o = Object.create(proto);\n  o._tag = OpCodes.OP_INTERRUPT;\n  o.fiberId = fiberId;\n  return o;\n};\n/** @internal */\nexport const annotated = (cause, annotation) => {\n  const o = Object.create(proto);\n  o._tag = OpCodes.OP_ANNOTATED;\n  o.cause = cause;\n  o.annotation = annotation;\n  return o;\n};\n/** @internal */\nexport const parallel = (left, right) => {\n  const o = Object.create(proto);\n  o._tag = OpCodes.OP_PARALLEL;\n  o.left = left;\n  o.right = right;\n  return o;\n};\n/** @internal */\nexport const sequential = (left, right) => {\n  const o = Object.create(proto);\n  o._tag = OpCodes.OP_SEQUENTIAL;\n  o.left = left;\n  o.right = right;\n  return o;\n};\n// -----------------------------------------------------------------------------\n// Refinements\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const isCause = u => typeof u === \"object\" && u != null && CauseTypeId in u;\n/** @internal */\nexport const isEmptyType = self => self._tag === OpCodes.OP_EMPTY;\n/** @internal */\nexport const isFailType = self => self._tag === OpCodes.OP_FAIL;\n/** @internal */\nexport const isDieType = self => self._tag === OpCodes.OP_DIE;\n/** @internal */\nexport const isInterruptType = self => self._tag === OpCodes.OP_INTERRUPT;\n/** @internal */\nexport const isAnnotatedType = self => self._tag === OpCodes.OP_ANNOTATED;\n/** @internal */\nexport const isSequentialType = self => self._tag === OpCodes.OP_SEQUENTIAL;\n/** @internal */\nexport const isParallelType = self => self._tag === OpCodes.OP_PARALLEL;\n// -----------------------------------------------------------------------------\n// Getters\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const size = self => reduceWithContext(self, void 0, SizeCauseReducer);\n/** @internal */\nexport const isEmpty = self => {\n  if (self._tag === OpCodes.OP_EMPTY) {\n    return true;\n  }\n  return reduce(self, true, (acc, cause) => {\n    switch (cause._tag) {\n      case OpCodes.OP_EMPTY:\n        {\n          return Option.some(acc);\n        }\n      case OpCodes.OP_DIE:\n      case OpCodes.OP_FAIL:\n      case OpCodes.OP_INTERRUPT:\n        {\n          return Option.some(false);\n        }\n      default:\n        {\n          return Option.none();\n        }\n    }\n  });\n};\n/** @internal */\nexport const isFailure = self => Option.isSome(failureOption(self));\n/** @internal */\nexport const isDie = self => Option.isSome(dieOption(self));\n/** @internal */\nexport const isInterrupted = self => Option.isSome(interruptOption(self));\n/** @internal */\nexport const isInterruptedOnly = self => reduceWithContext(undefined, IsInterruptedOnlyCauseReducer)(self);\n/** @internal */\nexport const failures = self => Chunk.reverse(reduce(self, Chunk.empty(), (list, cause) => cause._tag === OpCodes.OP_FAIL ? Option.some(Chunk.prepend(cause.error)(list)) : Option.none()));\n/** @internal */\nexport const defects = self => Chunk.reverse(reduce(self, Chunk.empty(), (list, cause) => cause._tag === OpCodes.OP_DIE ? Option.some(Chunk.prepend(cause.defect)(list)) : Option.none()));\n/** @internal */\nexport const interruptors = self => reduce(self, HashSet.empty(), (set, cause) => cause._tag === OpCodes.OP_INTERRUPT ? Option.some(HashSet.add(cause.fiberId)(set)) : Option.none());\n/** @internal */\nexport const failureOption = self => find(self, cause => cause._tag === OpCodes.OP_FAIL ? Option.some(cause.error) : Option.none());\n/** @internal */\nexport const failureOrCause = self => {\n  const option = failureOption(self);\n  switch (option._tag) {\n    case \"None\":\n      {\n        // no `E` inside this `Cause`, so it can be safely cast to `never`\n        return Either.right(self);\n      }\n    case \"Some\":\n      {\n        return Either.left(option.value);\n      }\n  }\n};\n/** @internal */\nexport const dieOption = self => find(self, cause => cause._tag === OpCodes.OP_DIE ? Option.some(cause.defect) : Option.none());\n/** @internal */\nexport const flipCauseOption = self => match(self, Option.some(empty), failureOption => Option.map(fail)(failureOption), defect => Option.some(die(defect)), fiberId => Option.some(interrupt(fiberId)), (causeOption, annotation) => Option.map(cause => annotated(cause, annotation))(causeOption), (left, right) => {\n  if (Option.isSome(left) && Option.isSome(right)) {\n    return Option.some(sequential(left.value, right.value));\n  }\n  if (Option.isNone(left) && Option.isSome(right)) {\n    return Option.some(right.value);\n  }\n  if (Option.isSome(left) && Option.isNone(right)) {\n    return Option.some(left.value);\n  }\n  return Option.none();\n}, (left, right) => {\n  if (Option.isSome(left) && Option.isSome(right)) {\n    return Option.some(parallel(left.value, right.value));\n  }\n  if (Option.isNone(left) && Option.isSome(right)) {\n    return Option.some(right.value);\n  }\n  if (Option.isSome(left) && Option.isNone(right)) {\n    return Option.some(left.value);\n  }\n  return Option.none();\n});\n/** @internal */\nexport const interruptOption = self => find(self, cause => cause._tag === OpCodes.OP_INTERRUPT ? Option.some(cause.fiberId) : Option.none());\n/** @internal */\nexport const keepDefects = self => match(self, Option.none(), () => Option.none(), defect => Option.some(die(defect)), () => Option.none(), (option, annotation) => Option.map(cause => annotated(cause, annotation))(option), (left, right) => {\n  if (Option.isSome(left) && Option.isSome(right)) {\n    return Option.some(sequential(left.value, right.value));\n  }\n  if (Option.isSome(left) && Option.isNone(right)) {\n    return Option.some(left.value);\n  }\n  if (Option.isNone(left) && Option.isSome(right)) {\n    return Option.some(right.value);\n  }\n  return Option.none();\n}, (left, right) => {\n  if (Option.isSome(left) && Option.isSome(right)) {\n    return Option.some(parallel(left.value, right.value));\n  }\n  if (Option.isSome(left) && Option.isNone(right)) {\n    return Option.some(left.value);\n  }\n  if (Option.isNone(left) && Option.isSome(right)) {\n    return Option.some(right.value);\n  }\n  return Option.none();\n});\n/** @internal */\nexport const linearize = self => match(self, HashSet.empty(), error => HashSet.make(fail(error)), defect => HashSet.make(die(defect)), fiberId => HashSet.make(interrupt(fiberId)), (set, annotation) => HashSet.map(cause => annotated(cause, annotation))(set), (leftSet, rightSet) => HashSet.flatMap(leftCause => HashSet.map(rightCause => sequential(leftCause, rightCause))(rightSet))(leftSet), (leftSet, rightSet) => HashSet.flatMap(leftCause => HashSet.map(rightCause => parallel(leftCause, rightCause))(rightSet))(leftSet));\n/** @internal */\nexport const stripFailures = self => match(self, empty, () => empty, defect => die(defect), fiberId => interrupt(fiberId), (cause, annotation) => isEmptyType(cause) ? cause : annotated(cause, annotation), (left, right) => sequential(left, right), (left, right) => parallel(left, right));\n/** @internal */\nexport const stripSomeDefects = /*#__PURE__*/Debug.dual(2, (self, pf) => {\n  return match(self, Option.some(empty), error => Option.some(fail(error)), defect => {\n    const option = pf(defect);\n    return Option.isSome(option) ? Option.none() : Option.some(die(defect));\n  }, fiberId => Option.some(interrupt(fiberId)), (option, annotation) => Option.map(cause => annotated(cause, annotation))(option), (left, right) => {\n    if (Option.isSome(left) && Option.isSome(right)) {\n      return Option.some(sequential(left.value, right.value));\n    }\n    if (Option.isSome(left) && Option.isNone(right)) {\n      return Option.some(left.value);\n    }\n    if (Option.isNone(left) && Option.isSome(right)) {\n      return Option.some(right.value);\n    }\n    return Option.none();\n  }, (left, right) => {\n    if (Option.isSome(left) && Option.isSome(right)) {\n      return Option.some(parallel(left.value, right.value));\n    }\n    if (Option.isSome(left) && Option.isNone(right)) {\n      return Option.some(left.value);\n    }\n    if (Option.isNone(left) && Option.isSome(right)) {\n      return Option.some(right.value);\n    }\n    return Option.none();\n  });\n});\n// -----------------------------------------------------------------------------\n// Mapping\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const as = /*#__PURE__*/Debug.dual(2, (self, error) => map(self, () => error));\n/** @internal */\nexport const map = /*#__PURE__*/Debug.dual(2, (self, f) => flatMap(self, e => fail(f(e))));\n// -----------------------------------------------------------------------------\n// Sequencing\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const flatMap = /*#__PURE__*/Debug.dual(2, (self, f) => match(self, empty, error => f(error), defect => die(defect), fiberId => interrupt(fiberId), (cause, annotation) => annotated(cause, annotation), (left, right) => sequential(left, right), (left, right) => parallel(left, right)));\n/** @internal */\nexport const flatten = self => flatMap(self, identity);\n// -----------------------------------------------------------------------------\n// Equality\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const contains = /*#__PURE__*/Debug.dual(2, (self, that) => {\n  if (that._tag === OpCodes.OP_EMPTY || self === that) {\n    return true;\n  }\n  return reduce(self, false, (accumulator, cause) => {\n    return Option.some(accumulator || causeEquals(cause, that));\n  });\n});\n/** @internal */\nconst causeEquals = (left, right) => {\n  let leftStack = Chunk.of(left);\n  let rightStack = Chunk.of(right);\n  while (Chunk.isNonEmpty(leftStack) && Chunk.isNonEmpty(rightStack)) {\n    const [leftParallel, leftSequential] = reduce([HashSet.empty(), Chunk.empty()], ([parallel, sequential], cause) => {\n      const [par, seq] = evaluateCause(cause);\n      return Option.some([HashSet.union(par)(parallel), Chunk.concat(seq)(sequential)]);\n    })(Chunk.headNonEmpty(leftStack));\n    const [rightParallel, rightSequential] = reduce([HashSet.empty(), Chunk.empty()], ([parallel, sequential], cause) => {\n      const [par, seq] = evaluateCause(cause);\n      return Option.some([HashSet.union(par)(parallel), Chunk.concat(seq)(sequential)]);\n    })(Chunk.headNonEmpty(rightStack));\n    if (!Equal.equals(leftParallel, rightParallel)) {\n      return false;\n    }\n    leftStack = leftSequential;\n    rightStack = rightSequential;\n  }\n  return true;\n};\n// -----------------------------------------------------------------------------\n// Flattening\n// -----------------------------------------------------------------------------\n/**\n * Flattens a cause to a sequence of sets of causes, where each set represents\n * causes that fail in parallel and sequential sets represent causes that fail\n * after each other.\n *\n * @internal\n */\nconst flattenCause = cause => {\n  return flattenCauseLoop(Chunk.of(cause), Chunk.empty());\n};\n/** @internal */\nconst flattenCauseLoop = (causes, flattened) => {\n  // eslint-disable-next-line no-constant-condition\n  while (1) {\n    const [parallel, sequential] = Chunk.reduce([HashSet.empty(), Chunk.empty()], ([parallel, sequential], cause) => {\n      const [par, seq] = evaluateCause(cause);\n      return [HashSet.union(par)(parallel), Chunk.concat(seq)(sequential)];\n    })(causes);\n    const updated = HashSet.size(parallel) > 0 ? Chunk.prepend(parallel)(flattened) : flattened;\n    if (Chunk.isEmpty(sequential)) {\n      return Chunk.reverse(updated);\n    }\n    causes = sequential;\n    flattened = updated;\n  }\n  throw new Error(\"BUG: Cause.flattenCauseLoop - please report an issue at https://github.com/Effect-TS/io/issues\");\n};\n// -----------------------------------------------------------------------------\n// Squashing\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const squash = self => {\n  return squashWith(identity)(self);\n};\n/** @internal */\nexport const squashWith = /*#__PURE__*/Debug.dual(2, (self, f) => {\n  const option = Option.map(f)(failureOption(self));\n  switch (option._tag) {\n    case \"None\":\n      {\n        return Option.match(() => {\n          const interrupts = Array.from(interruptors(self)).flatMap(fiberId => Array.from(FiberId.ids(fiberId)).map(id => `#${id}`));\n          return InterruptedException(interrupts ? `Interrupted by fibers: ${interrupts.join(\", \")}` : void 0);\n        }, identity)(Chunk.head(defects(self)));\n      }\n    case \"Some\":\n      {\n        return option.value;\n      }\n  }\n});\n// -----------------------------------------------------------------------------\n// Finding\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const find = /*#__PURE__*/Debug.dual(2, (self, pf) => {\n  const stack = [self];\n  while (stack.length > 0) {\n    const item = stack.pop();\n    const option = pf(item);\n    switch (option._tag) {\n      case \"None\":\n        {\n          switch (item._tag) {\n            case OpCodes.OP_SEQUENTIAL:\n            case OpCodes.OP_PARALLEL:\n              {\n                stack.push(item.right);\n                stack.push(item.left);\n                break;\n              }\n            case OpCodes.OP_ANNOTATED:\n              {\n                stack.push(item.cause);\n                break;\n              }\n          }\n          break;\n        }\n      case \"Some\":\n        {\n          return option;\n        }\n    }\n  }\n  return Option.none();\n});\n// -----------------------------------------------------------------------------\n// Filtering\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const filter = /*#__PURE__*/Debug.dual(2, (self, predicate) => reduceWithContext(self, void 0, FilterCauseReducer(predicate)));\n// -----------------------------------------------------------------------------\n// Evaluation\n// -----------------------------------------------------------------------------\n/**\n * Takes one step in evaluating a cause, returning a set of causes that fail\n * in parallel and a list of causes that fail sequentially after those causes.\n *\n * @internal\n */\nconst evaluateCause = self => {\n  let cause = self;\n  const stack = [];\n  let _parallel = HashSet.empty();\n  let _sequential = Chunk.empty();\n  while (cause !== undefined) {\n    switch (cause._tag) {\n      case OpCodes.OP_EMPTY:\n        {\n          if (stack.length === 0) {\n            return [_parallel, _sequential];\n          }\n          cause = stack.pop();\n          break;\n        }\n      case OpCodes.OP_FAIL:\n        {\n          if (stack.length === 0) {\n            return [HashSet.add(cause.error)(_parallel), _sequential];\n          }\n          _parallel = HashSet.add(cause.error)(_parallel);\n          cause = stack.pop();\n          break;\n        }\n      case OpCodes.OP_DIE:\n        {\n          if (stack.length === 0) {\n            return [HashSet.add(cause.defect)(_parallel), _sequential];\n          }\n          _parallel = HashSet.add(cause.defect)(_parallel);\n          cause = stack.pop();\n          break;\n        }\n      case OpCodes.OP_INTERRUPT:\n        {\n          if (stack.length === 0) {\n            return [HashSet.add(cause.fiberId)(_parallel), _sequential];\n          }\n          _parallel = HashSet.add(cause.fiberId)(_parallel);\n          cause = stack.pop();\n          break;\n        }\n      case OpCodes.OP_ANNOTATED:\n        {\n          cause = cause.cause;\n          break;\n        }\n      case OpCodes.OP_SEQUENTIAL:\n        {\n          switch (cause.left._tag) {\n            case OpCodes.OP_EMPTY:\n              {\n                cause = cause.right;\n                break;\n              }\n            case OpCodes.OP_SEQUENTIAL:\n              {\n                cause = sequential(cause.left.left, sequential(cause.left.right, cause.right));\n                break;\n              }\n            case OpCodes.OP_PARALLEL:\n              {\n                cause = parallel(sequential(cause.left.left, cause.right), sequential(cause.left.right, cause.right));\n                break;\n              }\n            case OpCodes.OP_ANNOTATED:\n              {\n                cause = sequential(cause.left.cause, cause.right);\n                break;\n              }\n            default:\n              {\n                _sequential = Chunk.prepend(cause.right)(_sequential);\n                cause = cause.left;\n                break;\n              }\n          }\n          break;\n        }\n      case OpCodes.OP_PARALLEL:\n        {\n          stack.push(cause.right);\n          cause = cause.left;\n          break;\n        }\n    }\n  }\n  throw new Error(\"BUG: Cause.evaluateCauseLoop - please report an issue at https://github.com/Effect-TS/io/issues\");\n};\n// -----------------------------------------------------------------------------\n// Reducing\n// -----------------------------------------------------------------------------\n/** @internal */\nconst SizeCauseReducer = {\n  emptyCase: () => 0,\n  failCase: () => 1,\n  dieCase: () => 1,\n  interruptCase: () => 1,\n  annotatedCase: (_, value) => value,\n  sequentialCase: (_, left, right) => left + right,\n  parallelCase: (_, left, right) => left + right\n};\n/** @internal */\nconst IsInterruptedOnlyCauseReducer = {\n  emptyCase: constTrue,\n  failCase: constFalse,\n  dieCase: constFalse,\n  interruptCase: constTrue,\n  annotatedCase: (_, value) => value,\n  sequentialCase: (_, left, right) => left && right,\n  parallelCase: (_, left, right) => left && right\n};\n/** @internal */\nconst FilterCauseReducer = predicate => ({\n  emptyCase: () => empty,\n  failCase: (_, error) => fail(error),\n  dieCase: (_, defect) => die(defect),\n  interruptCase: (_, fiberId) => interrupt(fiberId),\n  annotatedCase: (_, cause, annotation) => annotated(cause, annotation),\n  sequentialCase: (_, left, right) => {\n    if (predicate(left)) {\n      if (predicate(right)) {\n        return sequential(left, right);\n      }\n      return left;\n    }\n    if (predicate(right)) {\n      return right;\n    }\n    return empty;\n  },\n  parallelCase: (_, left, right) => {\n    if (predicate(left)) {\n      if (predicate(right)) {\n        return parallel(left, right);\n      }\n      return left;\n    }\n    if (predicate(right)) {\n      return right;\n    }\n    return empty;\n  }\n});\nconst OP_SEQUENTIAL_CASE = \"SequentialCase\";\nconst OP_PARALLEL_CASE = \"ParallelCase\";\nconst OP_ANNOTATED_CASE = \"AnnotatedCase\";\n/** @internal */\nexport const match = /*#__PURE__*/Debug.dual(8, (self, emptyCase, failCase, dieCase, interruptCase, annotatedCase, sequentialCase, parallelCase) => {\n  return reduceWithContext(self, void 0, {\n    emptyCase: () => emptyCase,\n    failCase: (_, error) => failCase(error),\n    dieCase: (_, defect) => dieCase(defect),\n    interruptCase: (_, fiberId) => interruptCase(fiberId),\n    annotatedCase: (_, value, annotation) => annotatedCase(value, annotation),\n    sequentialCase: (_, left, right) => sequentialCase(left, right),\n    parallelCase: (_, left, right) => parallelCase(left, right)\n  });\n});\n/** @internal */\nexport const reduce = /*#__PURE__*/Debug.dual(3, (self, zero, pf) => {\n  let accumulator = zero;\n  let cause = self;\n  const causes = [];\n  while (cause !== undefined) {\n    const option = pf(accumulator, cause);\n    accumulator = Option.isSome(option) ? option.value : accumulator;\n    switch (cause._tag) {\n      case OpCodes.OP_SEQUENTIAL:\n        {\n          causes.push(cause.right);\n          cause = cause.left;\n          break;\n        }\n      case OpCodes.OP_PARALLEL:\n        {\n          causes.push(cause.right);\n          cause = cause.left;\n          break;\n        }\n      case OpCodes.OP_ANNOTATED:\n        {\n          cause = cause.cause;\n          break;\n        }\n      default:\n        {\n          cause = undefined;\n          break;\n        }\n    }\n    if (cause === undefined && causes.length > 0) {\n      cause = causes.pop();\n    }\n  }\n  return accumulator;\n});\n/** @internal */\nexport const reduceWithContext = /*#__PURE__*/Debug.dual(3, (self, context, reducer) => {\n  const input = [self];\n  const output = [];\n  while (input.length > 0) {\n    const cause = input.pop();\n    switch (cause._tag) {\n      case OpCodes.OP_EMPTY:\n        {\n          output.push(Either.right(reducer.emptyCase(context)));\n          break;\n        }\n      case OpCodes.OP_FAIL:\n        {\n          output.push(Either.right(reducer.failCase(context, cause.error)));\n          break;\n        }\n      case OpCodes.OP_DIE:\n        {\n          output.push(Either.right(reducer.dieCase(context, cause.defect)));\n          break;\n        }\n      case OpCodes.OP_INTERRUPT:\n        {\n          output.push(Either.right(reducer.interruptCase(context, cause.fiberId)));\n          break;\n        }\n      case OpCodes.OP_ANNOTATED:\n        {\n          input.push(cause.cause);\n          output.push(Either.left({\n            _tag: OP_ANNOTATED_CASE,\n            annotation: cause.annotation\n          }));\n          break;\n        }\n      case OpCodes.OP_SEQUENTIAL:\n        {\n          input.push(cause.right);\n          input.push(cause.left);\n          output.push(Either.left({\n            _tag: OP_SEQUENTIAL_CASE\n          }));\n          break;\n        }\n      case OpCodes.OP_PARALLEL:\n        {\n          input.push(cause.right);\n          input.push(cause.left);\n          output.push(Either.left({\n            _tag: OP_PARALLEL_CASE\n          }));\n          break;\n        }\n    }\n  }\n  const accumulator = [];\n  while (output.length > 0) {\n    const either = output.pop();\n    switch (either._tag) {\n      case \"Left\":\n        {\n          switch (either.left._tag) {\n            case OP_SEQUENTIAL_CASE:\n              {\n                const left = accumulator.pop();\n                const right = accumulator.pop();\n                const value = reducer.sequentialCase(context, left, right);\n                accumulator.push(value);\n                break;\n              }\n            case OP_PARALLEL_CASE:\n              {\n                const left = accumulator.pop();\n                const right = accumulator.pop();\n                const value = reducer.parallelCase(context, left, right);\n                accumulator.push(value);\n                break;\n              }\n            case OP_ANNOTATED_CASE:\n              {\n                const cause = accumulator.pop();\n                const value = reducer.annotatedCase(context, cause, either.left.annotation);\n                accumulator.push(value);\n                break;\n              }\n          }\n          break;\n        }\n      case \"Right\":\n        {\n          accumulator.push(either.right);\n          break;\n        }\n    }\n  }\n  if (accumulator.length === 0) {\n    throw new Error(\"BUG: Cause.reduceWithContext - please report an issue at https://github.com/Effect-TS/io/issues\");\n  }\n  return accumulator.pop();\n});\n// -----------------------------------------------------------------------------\n// Errors\n// -----------------------------------------------------------------------------\nconst makeException = (proto, tag) => {\n  const _tag = {\n    value: tag,\n    enumerable: true\n  };\n  const protoWithToString = {\n    ...proto,\n    toString: {\n      value() {\n        return `${this._tag}: ${this.message}`;\n      },\n      enumerable: false\n    }\n  };\n  return message => Object.create(protoWithToString, {\n    _tag,\n    message: {\n      value: message,\n      enumerable: true\n    }\n  });\n};\n/** @internal */\nexport const RuntimeExceptionTypeId = /*#__PURE__*/Symbol.for(\"@effect/io/Cause/errors/RuntimeException\");\n/** @internal */\nexport const RuntimeException = /*#__PURE__*/makeException({\n  [RuntimeExceptionTypeId]: RuntimeExceptionTypeId\n}, \"RuntimeException\");\n/** @internal */\nexport const isRuntimeException = u => {\n  return typeof u === \"object\" && u != null && RuntimeExceptionTypeId in u;\n};\n/** @internal */\nexport const InterruptedExceptionTypeId = /*#__PURE__*/Symbol.for(\"@effect/io/Cause/errors/InterruptedException\");\n/** @internal */\nexport const InterruptedException = /*#__PURE__*/makeException({\n  [InterruptedExceptionTypeId]: InterruptedExceptionTypeId\n}, \"InterruptedException\");\n/** @internal */\nexport const isInterruptedException = u => {\n  return typeof u === \"object\" && u != null && InterruptedExceptionTypeId in u;\n};\n/** @internal */\nexport const IllegalArgumentExceptionTypeId = /*#__PURE__*/Symbol.for(\"@effect/io/Cause/errors/IllegalArgument\");\n/** @internal */\nexport const IllegalArgumentException = /*#__PURE__*/makeException({\n  [IllegalArgumentExceptionTypeId]: IllegalArgumentExceptionTypeId\n}, \"IllegalArgumentException\");\n/** @internal */\nexport const isIllegalArgumentException = u => {\n  return typeof u === \"object\" && u != null && IllegalArgumentExceptionTypeId in u;\n};\n/** @internal */\nexport const NoSuchElementExceptionTypeId = /*#__PURE__*/Symbol.for(\"@effect/io/Cause/errors/NoSuchElement\");\n/** @internal */\nexport const NoSuchElementException = /*#__PURE__*/makeException({\n  [NoSuchElementExceptionTypeId]: NoSuchElementExceptionTypeId\n}, \"NoSuchElementException\");\n/** @internal */\nexport const isNoSuchElementException = u => {\n  return typeof u === \"object\" && u != null && NoSuchElementExceptionTypeId in u;\n};\n/** @internal */\nexport const InvalidHubCapacityExceptionTypeId = /*#__PURE__*/Symbol.for(\"@effect/io/Cause/errors/InvalidHubCapacityException\");\n/** @internal */\nexport const InvalidHubCapacityException = /*#__PURE__*/makeException({\n  [InvalidHubCapacityExceptionTypeId]: InvalidHubCapacityExceptionTypeId\n}, \"InvalidHubCapacityException\");\n/** @internal */\nexport const isInvalidCapacityError = u => {\n  return typeof u === \"object\" && u != null && InvalidHubCapacityExceptionTypeId in u;\n};\n// -----------------------------------------------------------------------------\n// Stack Annotations\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const StackAnnotationTypeId = /*#__PURE__*/Symbol.for(\"@effect/io/Cause/StackAnnotation\");\n/** @internal */\nexport class StackAnnotation {\n  constructor(stack, seq) {\n    this.stack = stack;\n    this.seq = seq;\n    this[_a] = StackAnnotationTypeId;\n  }\n}\n_a = StackAnnotationTypeId;\n/** @internal */\nexport const isStackAnnotation = u => {\n  return typeof u === \"object\" && u != null && StackAnnotationTypeId in u;\n};\n/** @internal */\nconst UnAnnotateCauseReducer = () => ({\n  emptyCase: () => empty,\n  failCase: (_, error) => fail(error),\n  dieCase: (_, defect) => die(defect),\n  interruptCase: (_, fiberId) => interrupt(fiberId),\n  annotatedCase: (_, cause, __) => cause,\n  sequentialCase: (_, left, right) => sequential(left, right),\n  parallelCase: (_, left, right) => parallel(left, right)\n});\n/** @internal */\nexport const unannotate = self => reduceWithContext(self, void 0, UnAnnotateCauseReducer());\n//# sourceMappingURL=cause.mjs.map","import * as Debug from \"@effect/io/Debug\";\n/** @internal */\nconst BIT_MASK = 0xff;\n/** @internal */\nconst BIT_SHIFT = 0x08;\n/** @internal */\nexport const active = patch => patch & BIT_MASK;\n/** @internal */\nexport const enabled = patch => patch >> BIT_SHIFT & BIT_MASK;\n/** @internal */\nexport const make = (active, enabled) => (active & BIT_MASK) + ((enabled & active & BIT_MASK) << BIT_SHIFT);\n/** @internal */\nexport const empty = /*#__PURE__*/make(0, 0);\n/** @internal */\nexport const enable = flag => make(flag, flag);\n/** @internal */\nexport const disable = flag => make(flag, 0);\n/** @internal */\nexport const isEmpty = patch => patch === 0;\n/** @internal */\nexport const isActive = /*#__PURE__*/Debug.dual(2, (self, flag) => (active(self) & flag) !== 0);\n/** @internal */\nexport const isEnabled = /*#__PURE__*/Debug.dual(2, (self, flag) => (enabled(self) & flag) !== 0);\n/** @internal */\nexport const isDisabled = /*#__PURE__*/Debug.dual(2, (self, flag) => (active(self) & flag) !== 0 && (enabled(self) & flag) === 0);\n/** @internal */\nexport const exclude = /*#__PURE__*/Debug.dual(2, (self, flag) => make(active(self) & ~flag, enabled(self)));\n/** @internal */\nexport const both = /*#__PURE__*/Debug.dual(2, (self, that) => make(active(self) | active(that), enabled(self) & enabled(that)));\n/** @internal */\nexport const either = /*#__PURE__*/Debug.dual(2, (self, that) => make(active(self) | active(that), enabled(self) | enabled(that)));\n/** @internal */\nexport const andThen = /*#__PURE__*/Debug.dual(2, (self, that) => self | that);\n/** @internal */\nexport const inverse = patch => make(enabled(patch), invert(active(patch)));\n/** @internal */\nexport const invert = n => ~n >>> 0 & BIT_MASK;\n//# sourceMappingURL=runtimeFlagsPatch.mjs.map","import { pipe } from \"@fp-ts/core/Function\";\nimport * as Chunk from \"@fp-ts/data/Chunk\";\nimport * as Dual from \"@fp-ts/data/Dual\";\nimport * as Equal from \"@fp-ts/data/Equal\";\nimport * as Hash from \"@fp-ts/data/Hash\";\n/** @internal */\nexport const ChunkPatchTypeId = /*#__PURE__*/Symbol.for(\"@fp-ts/data/Differ/ChunkPatch\");\nfunction variance(a) {\n  return a;\n}\nclass Empty {\n  constructor() {\n    this._tag = \"Empty\";\n    this._Value = variance;\n    this._Patch = variance;\n    this._id = ChunkPatchTypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`ChunkPatch(Empty)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id;\n  }\n}\nclass AndThen {\n  constructor(first, second) {\n    this.first = first;\n    this.second = second;\n    this._tag = \"AndThen\";\n    this._Value = variance;\n    this._Patch = variance;\n    this._id = ChunkPatchTypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`ChunkPatch(AndThen)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id && Equal.equals(this.first, that.first) && Equal.equals(this.second, that.second);\n  }\n}\nclass Append {\n  constructor(values) {\n    this.values = values;\n    this._tag = \"Append\";\n    this._Value = variance;\n    this._Patch = variance;\n    this._id = ChunkPatchTypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`ChunkPatch(Append)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id && Equal.equals(this.values, that.values);\n  }\n}\nclass Slice {\n  constructor(from, until) {\n    this.from = from;\n    this.until = until;\n    this._tag = \"Slice\";\n    this._Value = variance;\n    this._Patch = variance;\n    this._id = ChunkPatchTypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`ChunkPatch(Slice)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id && Equal.equals(this.from, that.from) && Equal.equals(this.until, that.until);\n  }\n}\nclass Update {\n  constructor(index, patch) {\n    this.index = index;\n    this.patch = patch;\n    this._tag = \"Update\";\n    this._Value = variance;\n    this._Patch = variance;\n    this._id = ChunkPatchTypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`ChunkPatch(AndThen)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id && Equal.equals(this.index, that.index) && Equal.equals(this.patch, that.patch);\n  }\n}\n/** @internal */\nexport const empty = () => new Empty();\n/** @internal */\nexport const diff = (oldValue, newValue, differ) => {\n  let i = 0;\n  let patch = empty();\n  while (i < oldValue.length && i < newValue.length) {\n    const oldElement = Chunk.unsafeGet(i)(oldValue);\n    const newElement = Chunk.unsafeGet(i)(newValue);\n    const valuePatch = differ.diff(oldElement, newElement);\n    if (!Equal.equals(valuePatch, differ.empty)) {\n      patch = pipe(patch, combine(new Update(i, valuePatch)));\n    }\n    i = i + 1;\n  }\n  if (i < oldValue.length) {\n    patch = pipe(patch, combine(new Slice(0, i)));\n  }\n  if (i < newValue.length) {\n    patch = pipe(patch, combine(new Append(Chunk.drop(i)(newValue))));\n  }\n  return patch;\n};\n/** @internal */\nexport const combine = /*#__PURE__*/Dual.dual(2, (self, that) => new AndThen(self, that));\n/** @internal */\nexport const patch = /*#__PURE__*/Dual.dual(3, (self, oldValue, differ) => {\n  let chunk = oldValue;\n  let patches = Chunk.of(self);\n  while (Chunk.isNonEmpty(patches)) {\n    const head = Chunk.headNonEmpty(patches);\n    const tail = Chunk.tailNonEmpty(patches);\n    switch (head._tag) {\n      case \"Empty\":\n        {\n          patches = tail;\n          break;\n        }\n      case \"AndThen\":\n        {\n          patches = Chunk.prepend(head.first)(Chunk.prepend(head.second)(tail));\n          break;\n        }\n      case \"Append\":\n        {\n          chunk = Chunk.concat(head.values)(chunk);\n          patches = tail;\n          break;\n        }\n      case \"Slice\":\n        {\n          const array = Chunk.toReadonlyArray(chunk);\n          chunk = Chunk.unsafeFromArray(array.slice(head.from, head.until));\n          patches = tail;\n          break;\n        }\n      case \"Update\":\n        {\n          const array = Chunk.toReadonlyArray(chunk);\n          array[head.index] = differ.patch(head.patch, array[head.index]);\n          chunk = Chunk.unsafeFromArray(array);\n          patches = tail;\n          break;\n        }\n    }\n  }\n  return chunk;\n});\n//# sourceMappingURL=ChunkPatch.mjs.map","/**\n * @since 1.0.0\n */\nimport * as CP from \"@fp-ts/data/internal/Differ/ChunkPatch\";\nconst TypeId = CP.ChunkPatchTypeId;\n/**\n * Constructs an empty chunk patch.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const empty = CP.empty;\n/**\n * Constructs a chunk patch from a new and old chunk of values and a differ\n * for the values.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const diff = CP.diff;\n/**\n * Combines two chunk patches to produce a new chunk patch that describes\n * applying their changes sequentially.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const combine = CP.combine;\n/**\n * Applies a chunk patch to a chunk of values to produce a new chunk of\n * values which represents the original chunk of values updated with the\n * changes described by this patch.\n *\n * @since 1.0.0\n * @category destructors\n */\nexport const patch = CP.patch;\n//# sourceMappingURL=ChunkPatch.mjs.map","import * as option from \"@fp-ts/core/Option\";\nimport * as Dual from \"@fp-ts/data/Dual\";\nimport * as Equal from \"@fp-ts/data/Equal\";\nimport * as Hash from \"@fp-ts/data/Hash\";\n/** @internal */\nexport const TagTypeId = /*#__PURE__*/Symbol.for(\"@fp-ts/data/Context/Tag\");\n/** @internal */\nexport class TagImpl {\n  constructor(key) {\n    this.key = key;\n    this._id = TagTypeId;\n    this._S = _ => _;\n    if (key) {\n      if (!(TagTypeId in globalThis)) {\n        globalThis[TagTypeId] = {};\n      }\n      if (!(key in globalThis[TagTypeId])) {\n        globalThis[TagTypeId][key] = this;\n      }\n      return globalThis[TagTypeId][key];\n    }\n  }\n}\n/** @internal */\nexport const ContextTypeId = /*#__PURE__*/Symbol.for(\"@fp-ts/data/Context\");\n/** @internal */\nexport class ContextImpl {\n  [Equal.symbol](that) {\n    if (isContext(that)) {\n      if (this.unsafeMap.size === that.unsafeMap.size) {\n        for (const k of this.unsafeMap.keys()) {\n          if (!that.unsafeMap.has(k) || !Equal.equals(this.unsafeMap.get(k), that.unsafeMap.get(k))) {\n            return false;\n          }\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n  [Hash.symbol]() {\n    return Hash.number(this.unsafeMap.size);\n  }\n  constructor(unsafeMap) {\n    this.unsafeMap = unsafeMap;\n    this._id = ContextTypeId;\n    this._S = _ => _;\n  }\n}\n/** @internal */\nexport const isContext = u => typeof u === \"object\" && u !== null && \"_id\" in u && u[\"_id\"] === ContextTypeId;\n/** @internal */\nexport const isTag = u => typeof u === \"object\" && u !== null && \"_id\" in u && u[\"_id\"] === TagTypeId;\n/** @internal */\nexport const empty = () => new ContextImpl(new Map());\n/** @internal */\nexport const make = (tag, service) => new ContextImpl(new Map([[tag, service]]));\n/** @internal */\nexport const add = /*#__PURE__*/Dual.dual(3, (self, tag, service) => {\n  const map = new Map(self.unsafeMap);\n  map.set(tag, service);\n  return new ContextImpl(map);\n});\n/** @internal */\nexport const get = /*#__PURE__*/Dual.dual(2, (self, tag) => {\n  if (!self.unsafeMap.has(tag)) {\n    throw new Error(\"Service not found\");\n  }\n  return self.unsafeMap.get(tag);\n});\n/** @internal */\nexport const unsafeGet = /*#__PURE__*/Dual.dual(2, (self, tag) => {\n  if (!self.unsafeMap.has(tag)) {\n    throw new Error(\"Service not found\");\n  }\n  return self.unsafeMap.get(tag);\n});\n/** @internal */\nexport const getOption = /*#__PURE__*/Dual.dual(2, (self, tag) => {\n  if (!self.unsafeMap.has(tag)) {\n    return option.none();\n  }\n  return option.some(self.unsafeMap.get(tag));\n});\n/** @internal */\nexport const merge = /*#__PURE__*/Dual.dual(2, (self, that) => {\n  const map = new Map(self.unsafeMap);\n  for (const [tag, s] of that.unsafeMap) {\n    map.set(tag, s);\n  }\n  return new ContextImpl(map);\n});\n/** @internal */\nexport const prune = (...tags) => self => {\n  const tagSet = new Set(tags);\n  const newEnv = new Map();\n  for (const [tag, s] of self.unsafeMap.entries()) {\n    if (tagSet.has(tag)) {\n      newEnv.set(tag, s);\n    }\n  }\n  return new ContextImpl(newEnv);\n};\n//# sourceMappingURL=Context.mjs.map","import * as Chunk from \"@fp-ts/data/Chunk\";\nimport * as Dual from \"@fp-ts/data/Dual\";\nimport * as Equal from \"@fp-ts/data/Equal\";\nimport * as Hash from \"@fp-ts/data/Hash\";\nimport { ContextImpl } from \"@fp-ts/data/internal/Context\";\n/** @internal */\nexport const ContextPatchTypeId = /*#__PURE__*/Symbol.for(\"@fp-ts/data/Differ/ContextPatch\");\nfunction variance(a) {\n  return a;\n}\n/** @internal */\nexport class Empty {\n  constructor() {\n    this._tag = \"Empty\";\n    this._Input = variance;\n    this._Output = variance;\n    this._id = ContextPatchTypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`ContextPatch(Empty)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id;\n  }\n}\n/** @internal */\nexport class AndThen {\n  constructor(first, second) {\n    this.first = first;\n    this.second = second;\n    this._tag = \"AndThen\";\n    this._id = ContextPatchTypeId;\n    this._Input = variance;\n    this._Output = variance;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`ContextPatch(AndThen)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id && Equal.equals(this.first, that.first) && Equal.equals(this.second, that.second);\n  }\n}\n/** @internal */\nexport class AddService {\n  constructor(tag, service) {\n    this.tag = tag;\n    this.service = service;\n    this._tag = \"AddService\";\n    this._id = ContextPatchTypeId;\n    this._Input = variance;\n    this._Output = variance;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`ContextPatch(AddService)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id && Equal.equals(this.tag, that.tag) && Equal.equals(this.service, that.service);\n  }\n}\n/** @internal */\nexport class RemoveService {\n  constructor(tag) {\n    this.tag = tag;\n    this._tag = \"RemoveService\";\n    this._id = ContextPatchTypeId;\n    this._Input = variance;\n    this._Output = variance;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`ContextPatch(RemoveService)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id && Equal.equals(this.tag, that.tag);\n  }\n}\n/** @internal */\nexport class UpdateService {\n  constructor(tag, update) {\n    this.tag = tag;\n    this.update = update;\n    this._tag = \"UpdateService\";\n    this._id = ContextPatchTypeId;\n    this._Input = variance;\n    this._Output = variance;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`ContextPatch(AndThen)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id && Equal.equals(this.tag, that.tag) && Equal.equals(this.update, that.update);\n  }\n}\n/** @internal */\nexport const empty = () => new Empty();\n/** @internal */\nexport const diff = (oldValue, newValue) => {\n  const missingServices = new Map(oldValue.unsafeMap);\n  let patch = empty();\n  for (const [tag, newService] of newValue.unsafeMap.entries()) {\n    if (missingServices.has(tag)) {\n      const old = missingServices.get(tag);\n      missingServices.delete(tag);\n      if (!Equal.equals(old, newService)) {\n        patch = combine(new UpdateService(tag, () => newService))(patch);\n      }\n    } else {\n      missingServices.delete(tag);\n      patch = combine(new AddService(tag, newService))(patch);\n    }\n  }\n  for (const [tag] of missingServices.entries()) {\n    patch = combine(new RemoveService(tag))(patch);\n  }\n  return patch;\n};\n/** @internal */\nexport const combine = /*#__PURE__*/Dual.dual(2, (self, that) => new AndThen(self, that));\n/** @internal */\nexport const patch = /*#__PURE__*/Dual.dual(2, (self, context) => {\n  let wasServiceUpdated = false;\n  let patches = Chunk.of(self);\n  const updatedContext = new Map(context.unsafeMap);\n  while (Chunk.isNonEmpty(patches)) {\n    const head = Chunk.headNonEmpty(patches);\n    const tail = Chunk.tailNonEmpty(patches);\n    switch (head._tag) {\n      case \"Empty\":\n        {\n          patches = tail;\n          break;\n        }\n      case \"AddService\":\n        {\n          updatedContext.set(head.tag, head.service);\n          patches = tail;\n          break;\n        }\n      case \"AndThen\":\n        {\n          patches = Chunk.prepend(head.first)(Chunk.prepend(head.second)(tail));\n          break;\n        }\n      case \"RemoveService\":\n        {\n          updatedContext.delete(head.tag);\n          patches = tail;\n          break;\n        }\n      case \"UpdateService\":\n        {\n          updatedContext.set(head.tag, head.update(updatedContext.get(head.tag)));\n          wasServiceUpdated = true;\n          patches = tail;\n          break;\n        }\n    }\n  }\n  if (!wasServiceUpdated) {\n    return new ContextImpl(updatedContext);\n  }\n  const map = new Map();\n  for (const [tag] of context.unsafeMap) {\n    if (updatedContext.has(tag)) {\n      map.set(tag, updatedContext.get(tag));\n      updatedContext.delete(tag);\n    }\n  }\n  for (const [tag, s] of updatedContext) {\n    map.set(tag, s);\n  }\n  return new ContextImpl(map);\n});\n//# sourceMappingURL=ContextPatch.mjs.map","/**\n * @since 1.0.0\n */\nimport * as CP from \"@fp-ts/data/internal/Differ/ContextPatch\";\nconst TypeId = CP.ContextPatchTypeId;\n/**\n * An empty patch which returns the environment unchanged.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const empty = CP.empty;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const diff = CP.diff;\n/**\n * Combines two patches to produce a new patch that describes applying the\n * updates from this patch and then the updates from the specified patch.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const combine = CP.combine;\n/**\n * Applies a `Patch` to the specified `Context` to produce a new patched\n * `Context`.\n *\n * @since 1.0.0\n * @category destructors\n */\nexport const patch = CP.patch;\n//# sourceMappingURL=ContextPatch.mjs.map","import { HashSetImpl } from \"@fp-ts/data/internal/HashSet\";\n/** @internal */\nexport function keySet(self) {\n  return new HashSetImpl(self);\n}\n//# sourceMappingURL=keySet.mjs.map","/**\n * @since 1.0.0\n */\nimport * as HM from \"@fp-ts/data/internal/HashMap\";\nimport * as _keySet from \"@fp-ts/data/internal/HashMap/keySet\";\nconst TypeId = HM.HashMapTypeId;\n/**\n * @since 1.0.0\n * @category refinements\n */\nexport const isHashMap = HM.isHashMap;\n/**\n * Creates a new `HashMap`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const empty = HM.empty;\n/**\n * Constructs a new `HashMap` from an array of key/value pairs.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const make = HM.make;\n/**\n * Constructs a new `HashMap` from an iterable of key/value pairs.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const fromIterable = HM.fromIterable;\n/**\n * Checks if the `HashMap` contains any entries.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const isEmpty = HM.isEmpty;\n/**\n * Safely lookup the value for the specified key in the `HashMap` using the\n * internal hashing function.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const get = HM.get;\n/**\n * Lookup the value for the specified key in the `HashMap` using a custom hash.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const getHash = HM.getHash;\n/**\n * Unsafely lookup the value for the specified key in the `HashMap` using the\n * internal hashing function.\n *\n * @since 1.0.0\n * @category unsafe\n */\nexport const unsafeGet = HM.unsafeGet;\n/**\n * Checks if the specified key has an entry in the `HashMap`.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const has = HM.has;\n/**\n * Checks if the specified key has an entry in the `HashMap` using a custom\n * hash.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const hasHash = HM.hasHash;\n/**\n * Sets the specified key to the specified value using the internal hashing\n * function.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const set = HM.set;\n/**\n * Returns an `IterableIterator` of the keys within the `HashMap`.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const keys = HM.keys;\n/**\n * Returns a `HashSet` of keys within the `HashMap`.\n *\n * @since 1.0.0\n * @category getter\n */\nexport const keySet = _keySet.keySet;\n/**\n * Returns an `IterableIterator` of the values within the `HashMap`.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const values = HM.values;\n/**\n * Returns the number of entries within the `HashMap`.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const size = HM.size;\n/**\n * Marks the `HashMap` as mutable.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const beginMutation = HM.beginMutation;\n/**\n * Marks the `HashMap` as immutable.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const endMutation = HM.endMutation;\n/**\n * Mutates the `HashMap` within the context of the provided function.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const mutate = HM.mutate;\n/**\n * Set or remove the specified key in the `HashMap` using the specified\n * update function. The value of the specified key will be computed using the\n * provided hash.\n *\n * The update function will be invoked with the current value of the key if it\n * exists, or `None` if no such value exists.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const modifyAt = HM.modifyAt;\n/**\n * Alter the value of the specified key in the `HashMap` using the specified\n * update function. The value of the specified key will be computed using the\n * provided hash.\n *\n * The update function will be invoked with the current value of the key if it\n * exists, or `None` if no such value exists.\n *\n * This function will always either update or insert a value into the `HashMap`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const modifyHash = HM.modifyHash;\n/**\n * Updates the value of the specified key within the `HashMap` if it exists.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const modify = HM.modify;\n/**\n * Performs a union of this `HashMap` and that `HashMap`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const union = HM.union;\n/**\n * Remove the entry for the specified key in the `HashMap` using the internal\n * hashing function.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const remove = HM.remove;\n/**\n * Removes all entries in the `HashMap` which have the specified keys.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const removeMany = HM.removeMany;\n/**\n * Maps over the values of the `HashMap` using the specified function.\n *\n * @since 1.0.0\n * @category mapping\n */\nexport const map = HM.map;\n/**\n * Maps over the entries of the `HashMap` using the specified function.\n *\n * @since 1.0.0\n * @category mapping\n */\nexport const mapWithIndex = HM.mapWithIndex;\n/**\n * Chains over the values of the `HashMap` using the specified function.\n *\n * **NOTE**: the hash and equal of both maps have to be the same.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexport const flatMap = HM.flatMap;\n/**\n * Chains over the entries of the `HashMap` using the specified function.\n *\n * **NOTE**: the hash and equal of both maps have to be the same.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexport const flatMapWithIndex = HM.flatMapWithIndex;\n/**\n * Applies the specified function to the values of the `HashMap`.\n *\n * @since 1.0.0\n * @category traversing\n */\nexport const forEach = HM.forEach;\n/**\n * Applies the specified function to the entries of the `HashMap`.\n *\n * @since 1.0.0\n * @category traversing\n */\nexport const forEachWithIndex = HM.forEachWithIndex;\n/**\n * Reduces the specified state over the values of the `HashMap`.\n *\n * @since 1.0.0\n * @category folding\n */\nexport const reduce = HM.reduce;\n/**\n * Reduces the specified state over the entries of the `HashMap`.\n *\n * @since 1.0.0\n * @category folding\n */\nexport const reduceWithIndex = HM.reduceWithIndex;\n/**\n * Filters entries out of a `HashMap` using the specified predicate.\n *\n * @since 1.0.0\n * @category filtering\n */\nexport const filter = HM.filter;\n/**\n * Filters entries out of a `HashMap` using the specified predicate.\n *\n * @since 1.0.0\n * @category filtering\n */\nexport const filterWithIndex = HM.filterWithIndex;\n/**\n * Filters out `None` values from a `HashMap` of `Options`s.\n *\n * @since 1.0.0\n * @category filtering\n */\nexport const compact = HM.compact;\n/**\n * Maps over the values of the `HashMap` using the specified partial function\n * and filters out `None` values.\n *\n * @since 1.0.0\n * @category filtering\n */\nexport const filterMap = HM.filterMap;\n/**\n * Maps over the entries of the `HashMap` using the specified partial function\n * and filters out `None` values.\n *\n * @since 1.0.0\n * @category filtering\n */\nexport const filterMapWithIndex = HM.filterMapWithIndex;\n//# sourceMappingURL=HashMap.mjs.map","import * as Chunk from \"@fp-ts/data/Chunk\";\nimport * as Dual from \"@fp-ts/data/Dual\";\nimport * as Equal from \"@fp-ts/data/Equal\";\nimport * as Hash from \"@fp-ts/data/Hash\";\nimport * as HashMap from \"@fp-ts/data/HashMap\";\n/** @internal */\nexport const HashMapPatchTypeId = /*#__PURE__*/Symbol.for(\"@fp-ts/data/Differ/HashMapPatch\");\nfunction variance(a) {\n  return a;\n}\nclass Empty {\n  constructor() {\n    this._tag = \"Empty\";\n    this._Key = variance;\n    this._Value = variance;\n    this._Patch = variance;\n    this._id = HashMapPatchTypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`HashMapPatch(Empty)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id;\n  }\n}\nclass AndThen {\n  constructor(first, second) {\n    this.first = first;\n    this.second = second;\n    this._tag = \"AndThen\";\n    this._Key = variance;\n    this._Value = variance;\n    this._Patch = variance;\n    this._id = HashMapPatchTypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`HashMapPatch(AndThen)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id && Equal.equals(this.first, that.first) && Equal.equals(this.second, that.second);\n  }\n}\nclass Add {\n  constructor(key, value) {\n    this.key = key;\n    this.value = value;\n    this._tag = \"Add\";\n    this._Key = variance;\n    this._Value = variance;\n    this._Patch = variance;\n    this._id = HashMapPatchTypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`HashMapPatch(Add)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id && Equal.equals(this.key, that.key) && Equal.equals(this.value, that.value);\n  }\n}\nclass Remove {\n  constructor(key) {\n    this.key = key;\n    this._tag = \"Remove\";\n    this._Key = variance;\n    this._Value = variance;\n    this._Patch = variance;\n    this._id = HashMapPatchTypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`HashMapPatch(Remove)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id && Equal.equals(this.key, that.key);\n  }\n}\nclass Update {\n  constructor(key, patch) {\n    this.key = key;\n    this.patch = patch;\n    this._tag = \"Update\";\n    this._Key = variance;\n    this._Value = variance;\n    this._Patch = variance;\n    this._id = HashMapPatchTypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`HashMapPatch(Update)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id && Equal.equals(this.key, that.key) && Equal.equals(this.patch, that.patch);\n  }\n}\n/** @internal */\nexport const empty = () => new Empty();\n/** @internal */\nexport const diff = (oldValue, newValue, differ) => {\n  const [removed, patch] = HashMap.reduceWithIndex([oldValue, empty()], ([map, patch], newValue, key) => {\n    const option = HashMap.get(key)(map);\n    switch (option._tag) {\n      case \"Some\":\n        {\n          const valuePatch = differ.diff(option.value, newValue);\n          if (Equal.equals(valuePatch, differ.empty)) {\n            return [HashMap.remove(key)(map), patch];\n          }\n          return [HashMap.remove(key)(map), combine(new Update(key, valuePatch))(patch)];\n        }\n      case \"None\":\n        {\n          return [map, combine(new Add(key, newValue))(patch)];\n        }\n    }\n  })(newValue);\n  return HashMap.reduceWithIndex(patch, (patch, _, key) => combine(new Remove(key))(patch))(removed);\n};\n/** @internal */\nexport const combine = /*#__PURE__*/Dual.dual(2, (self, that) => new AndThen(self, that));\n/** @internal */\nexport const patch = /*#__PURE__*/Dual.dual(3, (self, oldValue, differ) => {\n  let map = oldValue;\n  let patches = Chunk.of(self);\n  while (Chunk.isNonEmpty(patches)) {\n    const head = Chunk.headNonEmpty(patches);\n    const tail = Chunk.tailNonEmpty(patches);\n    switch (head._tag) {\n      case \"Empty\":\n        {\n          patches = tail;\n          break;\n        }\n      case \"AndThen\":\n        {\n          patches = Chunk.prepend(head.first)(Chunk.prepend(head.second)(tail));\n          break;\n        }\n      case \"Add\":\n        {\n          map = HashMap.set(head.key, head.value)(map);\n          patches = tail;\n          break;\n        }\n      case \"Remove\":\n        {\n          map = HashMap.remove(head.key)(map);\n          patches = tail;\n          break;\n        }\n      case \"Update\":\n        {\n          const option = HashMap.get(head.key)(map);\n          if (option._tag === \"Some\") {\n            map = HashMap.set(head.key, differ.patch(head.patch, option.value))(map);\n          }\n          patches = tail;\n          break;\n        }\n    }\n  }\n  return map;\n});\n//# sourceMappingURL=HashMapPatch.mjs.map","/**\n * @since 1.0.0\n */\nimport * as HMP from \"@fp-ts/data/internal/Differ/HashMapPatch\";\nconst TypeId = HMP.HashMapPatchTypeId;\n/**\n * Constructs an empty map patch.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const empty = HMP.empty;\n/**\n * Constructs a map patch from a new and old map of keys and values and a\n * differ for the values.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const diff = HMP.diff;\n/**\n * Combines two map patches to produce a new map patch that describes\n * applying their changes sequentially.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const combine = HMP.combine;\n/**\n * Applies a map patch to a map of keys and values to produce a new map of\n * keys and values values which represents the original map of keys and\n * values updated with the changes described by this patch.\n *\n * @since 1.0.0\n * @category destructors\n */\nexport const patch = HMP.patch;\n//# sourceMappingURL=HashMapPatch.mjs.map","import * as Chunk from \"@fp-ts/data/Chunk\";\nimport * as Dual from \"@fp-ts/data/Dual\";\nimport * as Equal from \"@fp-ts/data/Equal\";\nimport * as Hash from \"@fp-ts/data/Hash\";\nimport * as HashSet from \"@fp-ts/data/HashSet\";\n/** @internal */\nexport const HashSetPatchTypeId = /*#__PURE__*/Symbol.for(\"@fp-ts/data/Differ/HashSetPatch\");\nfunction variance(a) {\n  return a;\n}\nclass Empty {\n  constructor() {\n    this._tag = \"Empty\";\n    this._Value = variance;\n    this._id = HashSetPatchTypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`HashSetPatch(Empty)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id;\n  }\n}\nclass AndThen {\n  constructor(first, second) {\n    this.first = first;\n    this.second = second;\n    this._tag = \"AndThen\";\n    this._Value = variance;\n    this._id = HashSetPatchTypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`HashSetPatch(AndThen)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id && Equal.equals(this.first, that.first) && Equal.equals(this.second, that.second);\n  }\n}\nclass Add {\n  constructor(value) {\n    this.value = value;\n    this._tag = \"Add\";\n    this._Value = variance;\n    this._id = HashSetPatchTypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`HashSetPatch(Add)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id && Equal.equals(this.value, that.value);\n  }\n}\nclass Remove {\n  constructor(value) {\n    this.value = value;\n    this._tag = \"Remove\";\n    this._Value = variance;\n    this._id = HashSetPatchTypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`HashSetPatch(Remove)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id && Equal.equals(this.value, that.value);\n  }\n}\n/** @internal */\nexport const empty = () => new Empty();\n/** @internal */\nexport const diff = (oldValue, newValue) => {\n  const [removed, patch] = HashSet.reduce([oldValue, empty()], ([set, patch], value) => {\n    if (HashSet.has(value)(set)) {\n      return [HashSet.remove(value)(set), patch];\n    }\n    return [set, combine(new Add(value))(patch)];\n  })(newValue);\n  return HashSet.reduce(patch, (patch, value) => combine(new Remove(value))(patch))(removed);\n};\n/** @internal */\nexport const combine = /*#__PURE__*/Dual.dual(2, (self, that) => new AndThen(self, that));\n/** @internal */\nexport const patch = /*#__PURE__*/Dual.dual(2, (self, oldValue) => {\n  let set = oldValue;\n  let patches = Chunk.of(self);\n  while (Chunk.isNonEmpty(patches)) {\n    const head = Chunk.headNonEmpty(patches);\n    const tail = Chunk.tailNonEmpty(patches);\n    switch (head._tag) {\n      case \"Empty\":\n        {\n          patches = tail;\n          break;\n        }\n      case \"AndThen\":\n        {\n          patches = Chunk.prepend(head.first)(Chunk.prepend(head.second)(tail));\n          break;\n        }\n      case \"Add\":\n        {\n          set = HashSet.add(head.value)(set);\n          patches = tail;\n          break;\n        }\n      case \"Remove\":\n        {\n          set = HashSet.remove(head.value)(set);\n          patches = tail;\n        }\n    }\n  }\n  return set;\n});\n//# sourceMappingURL=HashSetPatch.mjs.map","/**\n * @since 1.0.0\n */\nimport * as HSP from \"@fp-ts/data/internal/Differ/HashSetPatch\";\nconst TypeId = HSP.HashSetPatchTypeId;\n/**\n * Constructs an empty set patch.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const empty = HSP.empty;\n/**\n * Constructs a set patch from a new set of values.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const diff = HSP.diff;\n/**\n * Combines two set patches to produce a new set patch that describes\n * applying their changes sequentially.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const combine = HSP.combine;\n/**\n * Applies a set patch to a set of values to produce a new set of values\n * which represents the original set of values updated with the changes\n * described by this patch.\n *\n * @since 1.0.0\n * @category destructors\n */\nexport const patch = HSP.patch;\n//# sourceMappingURL=HashSetPatch.mjs.map","import * as E from \"@fp-ts/core/Either\";\nimport * as Chunk from \"@fp-ts/data/Chunk\";\nimport * as Dual from \"@fp-ts/data/Dual\";\nimport * as Equal from \"@fp-ts/data/Equal\";\nimport * as Hash from \"@fp-ts/data/Hash\";\n/** @internal */\nexport const OrPatchTypeId = /*#__PURE__*/Symbol.for(\"@fp-ts/data/Differ/OrPatch\");\nfunction variance(a) {\n  return a;\n}\n/** @internal */\nexport class Empty {\n  constructor() {\n    this._tag = \"Empty\";\n    this._Value = variance;\n    this._Value2 = variance;\n    this._Patch = variance;\n    this._Patch2 = variance;\n    this._id = OrPatchTypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`OrPatch(Empty)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id;\n  }\n}\n/** @internal */\nexport class AndThen {\n  constructor(first, second) {\n    this.first = first;\n    this.second = second;\n    this._tag = \"AndThen\";\n    this._Value = variance;\n    this._Value2 = variance;\n    this._Patch = variance;\n    this._Patch2 = variance;\n    this._id = OrPatchTypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`OrPatch(AndThen)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id && Equal.equals(this.first, that.first) && Equal.equals(this.second, that.second);\n  }\n}\n/** @internal */\nexport class SetLeft {\n  constructor(value) {\n    this.value = value;\n    this._tag = \"SetLeft\";\n    this._Value = variance;\n    this._Value2 = variance;\n    this._Patch = variance;\n    this._Patch2 = variance;\n    this._id = OrPatchTypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`OrPatch(SetLeft)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id && Equal.equals(this.value, that.value);\n  }\n}\n/** @internal */\nexport class SetRight {\n  constructor(value) {\n    this.value = value;\n    this._tag = \"SetRight\";\n    this._Value = variance;\n    this._Value2 = variance;\n    this._Patch = variance;\n    this._Patch2 = variance;\n    this._id = OrPatchTypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`OrPatch(SetRight)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id && Equal.equals(this.value, that.value);\n  }\n}\n/** @internal */\nexport class UpdateLeft {\n  constructor(patch) {\n    this.patch = patch;\n    this._tag = \"UpdateLeft\";\n    this._Value = variance;\n    this._Value2 = variance;\n    this._Patch = variance;\n    this._Patch2 = variance;\n    this._id = OrPatchTypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`OrPatch(UpdateLeft)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id && Equal.equals(this.patch, that.patch);\n  }\n}\n/** @internal */\nexport class UpdateRight {\n  constructor(patch) {\n    this.patch = patch;\n    this._tag = \"UpdateRight\";\n    this._Value = variance;\n    this._Value2 = variance;\n    this._Patch = variance;\n    this._Patch2 = variance;\n    this._id = OrPatchTypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.string(`OrPatch(UpdateRight)`);\n  }\n  [Equal.symbol](that) {\n    return typeof that === \"object\" && that !== null && \"_id\" in that && that[\"_id\"] === this._id && \"_tag\" in that && that[\"_tag\"] === this._id && Equal.equals(this.patch, that.patch);\n  }\n}\n/** @internal */\nexport const empty = () => new Empty();\n/** @internal */\nexport const diff = (oldValue, newValue, left, right) => {\n  switch (oldValue._tag) {\n    case \"Left\":\n      {\n        switch (newValue._tag) {\n          case \"Left\":\n            {\n              const valuePatch = left.diff(oldValue.left, newValue.left);\n              if (Equal.equals(valuePatch, left.empty)) {\n                return new Empty();\n              }\n              return new UpdateLeft(valuePatch);\n            }\n          case \"Right\":\n            {\n              return new SetRight(newValue.right);\n            }\n        }\n      }\n    case \"Right\":\n      {\n        switch (newValue._tag) {\n          case \"Left\":\n            {\n              return new SetLeft(newValue.left);\n            }\n          case \"Right\":\n            {\n              const valuePatch = right.diff(oldValue.right, newValue.right);\n              if (Equal.equals(valuePatch, right.empty)) {\n                return new Empty();\n              }\n              return new UpdateRight(valuePatch);\n            }\n        }\n      }\n  }\n};\n/** @internal */\nexport const combine = /*#__PURE__*/Dual.dual(2, (self, that) => new AndThen(self, that));\n/** @internal */\nexport const patch = /*#__PURE__*/Dual.dual(4, (self, oldValue, left, right) => {\n  let patches = Chunk.of(self);\n  let result = oldValue;\n  while (Chunk.isNonEmpty(patches)) {\n    const head = Chunk.headNonEmpty(patches);\n    const tail = Chunk.tailNonEmpty(patches);\n    switch (head._tag) {\n      case \"Empty\":\n        {\n          patches = tail;\n          break;\n        }\n      case \"AndThen\":\n        {\n          patches = Chunk.prepend(head.first)(Chunk.prepend(head.second)(tail));\n          break;\n        }\n      case \"UpdateLeft\":\n        {\n          if (result._tag === \"Left\") {\n            result = E.left(left.patch(head.patch, result.left));\n          }\n          patches = tail;\n          break;\n        }\n      case \"UpdateRight\":\n        {\n          if (result._tag === \"Right\") {\n            result = E.right(right.patch(head.patch, result.right));\n          }\n          patches = tail;\n          break;\n        }\n      case \"SetLeft\":\n        {\n          result = E.left(head.value);\n          patches = tail;\n          break;\n        }\n      case \"SetRight\":\n        {\n          result = E.right(head.value);\n          patches = tail;\n          break;\n        }\n    }\n  }\n  return result;\n});\n//# sourceMappingURL=OrPatch.mjs.map","/**\n * @since 1.0.0\n */\nimport * as OP from \"@fp-ts/data/internal/Differ/OrPatch\";\nconst TypeId = OP.OrPatchTypeId;\n/**\n * Constructs an empty `OrPatch`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const empty = OP.empty;\n/**\n * Constructs an `OrPatch` from a new and old value and a differ for the\n * values.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const diff = OP.diff;\n/**\n * Combines two or patches to produce a new or patch that describes applying\n * their changes sequentially.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const combine = OP.combine;\n/**\n * Applies an `OrPatch` to a value to produce a new value which represents\n * the original value updated with the changes described by this patch.\n *\n * @since 1.0.0\n * @category destructors\n */\nexport const patch = OP.patch;\n//# sourceMappingURL=OrPatch.mjs.map","import { constant, identity } from \"@fp-ts/core/Function\";\nimport * as ChunkPatch from \"@fp-ts/data/Differ/ChunkPatch\";\nimport * as ContextPatch from \"@fp-ts/data/Differ/ContextPatch\";\nimport * as HashMapPatch from \"@fp-ts/data/Differ/HashMapPatch\";\nimport * as HashSetPatch from \"@fp-ts/data/Differ/HashSetPatch\";\nimport * as OrPatch from \"@fp-ts/data/Differ/OrPatch\";\nimport * as Dual from \"@fp-ts/data/Dual\";\nimport * as Equal from \"@fp-ts/data/Equal\";\n/** @internal */\nexport const DifferTypeId = /*#__PURE__*/Symbol.for(\"@fp-ts/data/Differ\");\n/** @internal */\nclass DifferImpl {\n  constructor(params) {\n    this._id = DifferTypeId;\n    this._P = identity;\n    this._V = identity;\n    this.empty = params.empty;\n    this.diff = params.diff;\n    this.combine = params.combine;\n    this.patch = params.patch;\n  }\n}\n/** @internal */\nexport const make = params => new DifferImpl(params);\n/** @internal */\nexport const environment = () => make({\n  empty: ContextPatch.empty(),\n  combine: (first, second) => ContextPatch.combine(second)(first),\n  diff: (oldValue, newValue) => ContextPatch.diff(oldValue, newValue),\n  patch: (patch, oldValue) => ContextPatch.patch(oldValue)(patch)\n});\n/** @internal */\nexport const chunk = differ => make({\n  empty: ChunkPatch.empty(),\n  combine: (first, second) => ChunkPatch.combine(second)(first),\n  diff: (oldValue, newValue) => ChunkPatch.diff(oldValue, newValue, differ),\n  patch: (patch, oldValue) => ChunkPatch.patch(oldValue, differ)(patch)\n});\n/** @internal */\nexport const hashMap = differ => make({\n  empty: HashMapPatch.empty(),\n  combine: (first, second) => HashMapPatch.combine(second)(first),\n  diff: (oldValue, newValue) => HashMapPatch.diff(oldValue, newValue, differ),\n  patch: (patch, oldValue) => HashMapPatch.patch(oldValue, differ)(patch)\n});\n/** @internal */\nexport const hashSet = () => make({\n  empty: HashSetPatch.empty(),\n  combine: (first, second) => HashSetPatch.combine(second)(first),\n  diff: (oldValue, newValue) => HashSetPatch.diff(oldValue, newValue),\n  patch: (patch, oldValue) => HashSetPatch.patch(oldValue)(patch)\n});\n/** @internal */\nexport const orElseResult = /*#__PURE__*/Dual.dual(2, (self, that) => make({\n  empty: OrPatch.empty(),\n  combine: (first, second) => OrPatch.combine(second)(first),\n  diff: (oldValue, newValue) => OrPatch.diff(oldValue, newValue, self, that),\n  patch: (patch, oldValue) => OrPatch.patch(oldValue, self, that)(patch)\n}));\n/** @internal */\nexport const transform = /*#__PURE__*/Dual.dual(3, (self, f, g) => make({\n  empty: self.empty,\n  combine: (first, second) => self.combine(first, second),\n  diff: (oldValue, newValue) => self.diff(g(oldValue), g(newValue)),\n  patch: (patch, oldValue) => f(self.patch(patch, g(oldValue)))\n}));\n/** @internal */\nexport const update = () => updateWith((_, a) => a);\n/** @internal */\nexport const updateWith = f => make({\n  empty: identity,\n  combine: (first, second) => {\n    if (first === identity) {\n      return second;\n    }\n    if (second === identity) {\n      return first;\n    }\n    return a => second(first(a));\n  },\n  diff: (oldValue, newValue) => {\n    if (Equal.equals(oldValue, newValue)) {\n      return identity;\n    }\n    return constant(newValue);\n  },\n  patch: (patch, oldValue) => f(oldValue, patch(oldValue))\n});\n/** @internal */\nexport const zip = /*#__PURE__*/Dual.dual(2, (self, that) => make({\n  empty: [self.empty, that.empty],\n  combine: (first, second) => [self.combine(first[0], second[0]), that.combine(first[1], second[1])],\n  diff: (oldValue, newValue) => [self.diff(oldValue[0], newValue[0]), that.diff(oldValue[1], newValue[1])],\n  patch: (patch, oldValue) => [self.patch(patch[0], oldValue[0]), that.patch(patch[1], oldValue[1])]\n}));\n//# sourceMappingURL=Differ.mjs.map","import * as Dual from \"@fp-ts/data/Dual\";\nimport * as D from \"@fp-ts/data/internal/Differ\";\nconst TypeId = D.DifferTypeId;\n/**\n * An empty patch that describes no changes.\n *\n * @since 1.0.0\n * @category patch\n */\nexport const empty = self => self.empty;\n/**\n * An empty patch that describes no changes.\n *\n * @since 1.0.0\n * @category patch\n */\nexport const diff = /*#__PURE__*/Dual.dual(3, (self, oldValue, newValue) => self.diff(oldValue, newValue));\n/**\n * Combines two patches to produce a new patch that describes the updates of\n * the first patch and then the updates of the second patch. The combine\n * operation should be associative. In addition, if the combine operation is\n * commutative then joining multiple fibers concurrently will result in\n * deterministic `FiberRef` values.\n *\n * @since 1.0.0\n * @category patch\n */\nexport const combine = /*#__PURE__*/Dual.dual(3, (self, first, second) => self.combine(first, second));\n/**\n * Applies a patch to an old value to produce a new value that is equal to the\n * old value with the updates described by the patch.\n *\n * @since 1.0.0\n * @category patch\n */\nexport const patch = /*#__PURE__*/Dual.dual(3, (self, patch, oldValue) => self.patch(patch, oldValue));\n/**\n * Constructs a new `Differ`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const make = D.make;\n/**\n * Constructs a differ that knows how to diff `Env` values.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const environment = D.environment;\n/**\n * Constructs a differ that knows how to diff a `Chunk` of values given a\n * differ that knows how to diff the values.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const chunk = D.chunk;\n/**\n * Constructs a differ that knows how to diff a `HashMap` of keys and values given\n * a differ that knows how to diff the values.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const hashMap = D.hashMap;\n/**\n * Constructs a differ that knows how to diff a `HashSet` of values.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const hashSet = D.hashSet;\n/**\n * Combines this differ and the specified differ to produce a differ that\n * knows how to diff the sum of their values.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const orElseResult = D.orElseResult;\n/**\n * Transforms the type of values that this differ knows how to differ using\n * the specified functions that map the new and old value types to each other.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const transform = D.transform;\n/**\n * Constructs a differ that just diffs two values by returning a function that\n * sets the value to the new value. This differ does not support combining\n * multiple updates to the value compositionally and should only be used when\n * there is no compositional way to update them.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const update = D.update;\n/**\n * A variant of `update` that allows specifying the function that will be used\n * to combine old values with new values.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const updateWith = D.updateWith;\n/**\n * Combines this differ and the specified differ to produce a new differ that\n * knows how to diff the product of their values.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const zip = D.zip;\n//# sourceMappingURL=Differ.mjs.map","import * as Debug from \"@effect/io/Debug\";\nimport * as runtimeFlagsPatch from \"@effect/io/internal_effect_untraced/runtimeFlagsPatch\";\nimport * as Differ from \"@fp-ts/data/Differ\";\n/** @internal */\nexport const None = 0;\n/** @internal */\nexport const Interruption = 1 << 0;\n/** @internal */\nexport const OpSupervision = 1 << 1;\n/** @internal */\nexport const RuntimeMetrics = 1 << 2;\n/** @internal */\nexport const WindDown = 1 << 4;\n/** @internal */\nexport const CooperativeYielding = 1 << 5;\n/** @internal */\nexport const allFlags = [None, Interruption, OpSupervision, RuntimeMetrics, WindDown, CooperativeYielding];\n/** @internal */\nexport const cooperativeYielding = self => isEnabled(self, CooperativeYielding);\n/** @internal */\nexport const disable = /*#__PURE__*/Debug.dual(2, (self, flag) => self & ~flag);\n/** @internal */\nexport const disableAll = /*#__PURE__*/Debug.dual(2, (self, flags) => self & ~flags);\n/** @internal */\nexport const enable = /*#__PURE__*/Debug.dual(2, (self, flag) => self | flag);\n/** @internal */\nexport const enableAll = /*#__PURE__*/Debug.dual(2, (self, flags) => self | flags);\n/** @internal */\nexport const interruptible = self => interruption(self) && !windDown(self);\n/** @internal */\nexport const interruption = self => isEnabled(self, Interruption);\n/** @internal */\nexport const isDisabled = /*#__PURE__*/Debug.dual(2, (self, flag) => !isEnabled(self, flag));\n/** @internal */\nexport const isEnabled = /*#__PURE__*/Debug.dual(2, (self, flag) => (self & flag) !== 0);\n/** @internal */\nexport const make = (...flags) => flags.reduce((a, b) => a | b, 0);\n/** @internal */\nexport const none = /*#__PURE__*/make(None);\n/** @internal */\nexport const opSupervision = self => isEnabled(self, OpSupervision);\n/** @internal */\nexport const render = self => {\n  const active = [];\n  allFlags.forEach(flag => {\n    if (isEnabled(self, flag)) {\n      active.push(`${flag}`);\n    }\n  });\n  return `RuntimeFlags(${active.join(\", \")})`;\n};\n/** @internal */\nexport const runtimeMetrics = self => isEnabled(self, RuntimeMetrics);\n/** @internal */\nexport const toSet = self => new Set(allFlags.filter(flag => isEnabled(self, flag)));\nexport const windDown = self => isEnabled(self, WindDown);\n// circular with RuntimeFlagsPatch\n/** @internal */\nexport const enabledSet = self => toSet(runtimeFlagsPatch.active(self) & runtimeFlagsPatch.enabled(self));\n/** @internal */\nexport const disabledSet = self => toSet(runtimeFlagsPatch.active(self) & ~runtimeFlagsPatch.enabled(self));\n/** @internal */\nexport const diff = /*#__PURE__*/Debug.dual(2, (self, that) => runtimeFlagsPatch.make(self ^ that, that));\n/** @internal */\nexport const patch = /*#__PURE__*/Debug.dual(2, (self, patch) => self & (runtimeFlagsPatch.invert(runtimeFlagsPatch.active(patch)) | runtimeFlagsPatch.enabled(patch)) | runtimeFlagsPatch.active(patch) & runtimeFlagsPatch.enabled(patch));\n/** @internal */\nconst renderFlag = a => `${allFlags.find(b => a === b)}`;\n/** @internal */\nexport const renderPatch = self => {\n  const enabled = Array.from(enabledSet(self)).map(flag => renderFlag(flag)).join(\", \");\n  const disabled = Array.from(disabledSet(self)).map(flag => renderFlag(flag)).join(\", \");\n  return `RuntimeFlagsPatch(enabled = (${enabled}), disabled = (${disabled}))`;\n};\n/** @internal */\nexport const differ = () => Differ.make({\n  empty: runtimeFlagsPatch.empty,\n  diff: (oldValue, newValue) => diff(oldValue, newValue),\n  combine: (first, second) => runtimeFlagsPatch.andThen(second)(first),\n  patch: (_patch, oldValue) => patch(oldValue, _patch)\n});\n//# sourceMappingURL=runtimeFlags.mjs.map","import * as runtimeFlags from \"@effect/io/internal_effect_untraced/runtimeFlags\";\nimport * as internal from \"@effect/io/internal_effect_untraced/runtimeFlagsPatch\";\n/**\n * The empty `RuntimeFlagsPatch`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const empty = internal.empty;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const make = internal.make;\n/**\n * Creates a `RuntimeFlagsPatch` describing enabling the provided `RuntimeFlag`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const enable = internal.enable;\n/**\n * Creates a `RuntimeFlagsPatch` describing disabling the provided `RuntimeFlag`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const disable = internal.disable;\n/**\n * Returns `true` if the specified `RuntimeFlagsPatch` is empty.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const isEmpty = internal.isEmpty;\n/**\n * Returns `true` if the `RuntimeFlagsPatch` describes the specified\n * `RuntimeFlag` as active.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const isActive = internal.isActive;\n/**\n * Returns `true` if the `RuntimeFlagsPatch` describes the specified\n * `RuntimeFlag` as enabled.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const isEnabled = internal.isEnabled;\n/**\n * Returns `true` if the `RuntimeFlagsPatch` describes the specified\n * `RuntimeFlag` as disabled.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const isDisabled = internal.isDisabled;\n/**\n * Returns `true` if the `RuntimeFlagsPatch` includes the specified\n * `RuntimeFlag`, `false` otherwise.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const includes = internal.isActive;\n/**\n * Creates a `RuntimeFlagsPatch` describing the application of the `self` patch,\n * followed by `that` patch.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const andThen = internal.andThen;\n/**\n * Creates a `RuntimeFlagsPatch` describing application of both the `self` patch\n * and `that` patch.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const both = internal.both;\n/**\n * Creates a `RuntimeFlagsPatch` describing application of either the `self`\n * patch or `that` patch.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const either = internal.either;\n/**\n * Creates a `RuntimeFlagsPatch` which describes exclusion of the specified\n * `RuntimeFlag` from the set of `RuntimeFlags`.\n *\n * @category mutations\n * @since 1.0.0\n */\nexport const exclude = internal.exclude;\n/**\n * Creates a `RuntimeFlagsPatch` which describes the inverse of the patch\n * specified by the provided `RuntimeFlagsPatch`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const inverse = internal.inverse;\n/**\n * Returns a `ReadonlySet<number>` containing the `RuntimeFlags` described as\n * enabled by the specified `RuntimeFlagsPatch`.\n *\n * @since 1.0.0\n * @category destructors\n */\nexport const enabledSet = runtimeFlags.enabledSet;\n/**\n * Returns a `ReadonlySet<number>` containing the `RuntimeFlags` described as\n * disabled by the specified `RuntimeFlagsPatch`.\n *\n * @since 1.0.0\n * @category destructors\n */\nexport const disabledSet = runtimeFlags.disabledSet;\n/**\n * Renders the provided `RuntimeFlagsPatch` to a string.\n *\n * @since 1.0.0\n * @category destructors\n */\nexport const render = runtimeFlags.renderPatch;\n//# sourceMappingURL=Patch.mjs.map","/** @internal */\nexport const OP_STATE_PENDING = \"Pending\";\n/** @internal */\nexport const OP_STATE_DONE = \"Done\";\n//# sourceMappingURL=deferred.mjs.map","import * as OpCodes from \"@effect/io/internal_effect_untraced/opCodes/deferred\";\n/** @internal */\nconst DeferredSymbolKey = \"@effect/io/Deferred\";\n/** @internal */\nexport const DeferredTypeId = /*#__PURE__*/Symbol.for(DeferredSymbolKey);\n/** @internal */\nexport const deferredVariance = {\n  _E: _ => _,\n  _A: _ => _\n};\n/** @internal */\nexport const pending = joiners => {\n  return {\n    _tag: OpCodes.OP_STATE_PENDING,\n    joiners\n  };\n};\n/** @internal */\nexport const done = effect => {\n  return {\n    _tag: OpCodes.OP_STATE_DONE,\n    effect\n  };\n};\n//# sourceMappingURL=deferred.mjs.map","/** @internal */\nexport const OP_ASYNC = \"Async\";\n/** @internal */\nexport const OP_COMMIT = \"Commit\";\n/** @internal */\nexport const OP_FAILURE = \"Failure\";\n/** @internal */\nexport const OP_ON_FAILURE = \"OnFailure\";\n/** @internal */\nexport const OP_ON_SUCCESS = \"OnSuccess\";\n/** @internal */\nexport const OP_ON_SUCCESS_AND_FAILURE = \"OnSuccessAndFailure\";\n/** @internal */\nexport const OP_TRACED = \"OpTraced\";\n/** @internal */\nexport const OP_SUCCESS = \"Success\";\n/** @internal */\nexport const OP_SYNC = \"Sync\";\n/** @internal */\nexport const OP_UPDATE_RUNTIME_FLAGS = \"UpdateRuntimeFlags\";\n/** @internal */\nexport const OP_WHILE = \"While\";\n/** @internal */\nexport const OP_WITH_RUNTIME = \"WithRuntime\";\n/** @internal */\nexport const OP_YIELD = \"Yield\";\n/** @internal */\nexport const OP_REVERT_FLAGS = \"RevertFlags\";\n//# sourceMappingURL=effect.mjs.map","/** @internal */\nexport class HighPriorityScheduler {\n  constructor() {\n    this.running = false;\n    this.tasks = [];\n  }\n  get preferredExecution() {\n    return \"Async\";\n  }\n  starveInternal(depth) {\n    const toRun = this.tasks;\n    this.tasks = [];\n    for (let i = 0; i < toRun.length; i++) {\n      toRun[i]();\n    }\n    if (this.tasks.length === 0) {\n      this.running = false;\n    } else {\n      this.starve(depth);\n    }\n  }\n  starve(depth = 0) {\n    if (depth >= 2048) {\n      setTimeout(() => this.starveInternal(0), 0);\n    } else {\n      Promise.resolve(void 0).then(() => this.starveInternal(depth + 1));\n    }\n  }\n  scheduleTask(task) {\n    this.tasks.push(task);\n    if (!this.running) {\n      this.running = true;\n      this.starve();\n    }\n  }\n}\n/** @internal */\nexport const defaultScheduler = /*#__PURE__*/new HighPriorityScheduler();\n/** @internal */\nexport class SyncScheduler {\n  constructor() {\n    this.tasks = [];\n    this.deferred = false;\n  }\n  scheduleTask(task) {\n    if (this.deferred) {\n      defaultScheduler.scheduleTask(task);\n    } else {\n      this.tasks.push(task);\n    }\n  }\n  get preferredExecution() {\n    return this.deferred ? \"Async\" : \"Sync\";\n  }\n  flush() {\n    while (this.tasks.length > 0) {\n      const toRun = this.tasks;\n      this.tasks = [];\n      for (let i = 0; i < toRun.length; i++) {\n        toRun[i]();\n      }\n    }\n    this.deferred = true;\n  }\n}\n//# sourceMappingURL=scheduler.mjs.map","import * as C from \"@fp-ts/data/internal/Context\";\nconst TagTypeId = C.TagTypeId;\n/**\n * Specifying the key will make the Tag global, meaning two tags with the same\n * key will map to the same instance.\n *\n * Note: this is useful for cases where live reload can happen and it is\n * desireable to preserve the instance across reloads.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const Tag = key => new C.TagImpl(key);\nconst TypeId = C.ContextTypeId;\n/**\n * @since 1.0.0\n * @category guards\n */\nexport const isContext = C.isContext;\n/**\n * @since 1.0.0\n * @category guards\n */\nexport const isTag = C.isTag;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const empty = C.empty;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const make = C.make;\n/**\n * @since 1.0.0\n * @category mutations\n */\nexport const add = C.add;\n/**\n * @since 1.0.0\n * @category getters\n */\nexport const get = C.get;\n/**\n * @since 1.0.0\n * @category unsafe\n */\nexport const unsafeGet = C.unsafeGet;\n/**\n * @since 1.0.0\n * @category getters\n */\nexport const getOption = C.getOption;\n/**\n * @since 1.0.0\n * @category mutations\n */\nexport const merge = C.merge;\n/**\n * @since 1.0.0\n * @category mutations\n */\nexport const prune = C.prune;\n//# sourceMappingURL=Context.mjs.map","import * as Debug from \"@effect/io/Debug\";\nimport * as FiberId from \"@effect/io/Fiber/Id\";\nimport * as RuntimeFlagsPatch from \"@effect/io/Fiber/Runtime/Flags/Patch\";\nimport * as internalCause from \"@effect/io/internal_effect_untraced/cause\";\nimport * as deferred from \"@effect/io/internal_effect_untraced/deferred\";\nimport * as DeferredOpCodes from \"@effect/io/internal_effect_untraced/opCodes/deferred\";\nimport * as OpCodes from \"@effect/io/internal_effect_untraced/opCodes/effect\";\nimport * as _runtimeFlags from \"@effect/io/internal_effect_untraced/runtimeFlags\";\nimport * as scheduler from \"@effect/io/internal_effect_untraced/scheduler\";\nimport * as Either from \"@fp-ts/core/Either\";\nimport { identity } from \"@fp-ts/core/Function\";\nimport * as Option from \"@fp-ts/core/Option\";\nimport * as Chunk from \"@fp-ts/data/Chunk\";\nimport * as Context from \"@fp-ts/data/Context\";\nimport * as Differ from \"@fp-ts/data/Differ\";\nimport * as ContextPatch from \"@fp-ts/data/Differ/ContextPatch\";\nimport * as HashSetPatch from \"@fp-ts/data/Differ/HashSetPatch\";\nimport * as Equal from \"@fp-ts/data/Equal\";\nimport * as Hash from \"@fp-ts/data/Hash\";\nimport * as HashMap from \"@fp-ts/data/HashMap\";\nimport * as HashSet from \"@fp-ts/data/HashSet\";\nimport * as MutableRef from \"@fp-ts/data/MutableRef\";\n// -----------------------------------------------------------------------------\n// Effect\n// -----------------------------------------------------------------------------\n/** @internal */\nconst EffectErrorSymbolKey = \"@effect/io/Effect/Error\";\n/** @internal */\nexport const EffectErrorTypeId = /*#__PURE__*/Symbol.for(EffectErrorSymbolKey);\n/** @internal */\nexport const isEffectError = u => typeof u === \"object\" && u != null && EffectErrorTypeId in u;\n/** @internal */\nexport const makeEffectError = cause => ({\n  [EffectErrorTypeId]: EffectErrorTypeId,\n  _tag: \"EffectError\",\n  cause\n});\n/** @internal */\nexport const EffectTypeId = /*#__PURE__*/Symbol.for(\"@effect/io/Effect\");\n/** @internal */\nexport class RevertFlags {\n  constructor(patch) {\n    this.patch = patch;\n    this._tag = OpCodes.OP_REVERT_FLAGS;\n  }\n}\n/** @internal */\nconst effectVariance = {\n  _R: _ => _,\n  _E: _ => _,\n  _A: _ => _\n};\n/** @internal */\nexport const proto = {\n  [EffectTypeId]: effectVariance,\n  [Equal.symbol](that) {\n    return this === that;\n  },\n  [Hash.symbol]() {\n    return Hash.random(this);\n  },\n  traced(trace) {\n    if (trace) {\n      const effect = Object.create(proto);\n      effect._tag = OpCodes.OP_TRACED;\n      effect.self = this;\n      effect.trace = trace;\n      return effect;\n    }\n    return this;\n  }\n};\n/** @internal */\nexport const isEffect = u => typeof u === \"object\" && u != null && EffectTypeId in u;\n/* @internal */\nexport const acquireUseRelease = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restoreTracing) => (acquire, use, release) => uninterruptibleMask(restore => flatMap(a => flatMap(exit => matchCauseEffect(cause => {\n  switch (exit._tag) {\n    case OpCodes.OP_FAILURE:\n      {\n        return failCause(internalCause.parallel(exit.cause, cause));\n      }\n    case OpCodes.OP_SUCCESS:\n      {\n        return failCause(cause);\n      }\n  }\n}, () => exit)(suspendSucceed(() => restoreTracing(release)(a, exit))))(exit(suspendSucceed(() => restore(restoreTracing(use)(a))))))(acquire)).traced(trace));\n/* @internal */\nexport const as = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, value) => flatMap(() => succeed(value))(self).traced(trace));\n/* @internal */\nexport const asUnit = /*#__PURE__*/Debug.methodWithTrace(trace => self => as(void 0)(self).traced(trace));\n/* @internal */\nexport const async = /*#__PURE__*/Debug.methodWithTrace(trace => (register, blockingOn = FiberId.none) => {\n  const effect = Object.create(proto);\n  effect._tag = OpCodes.OP_ASYNC;\n  effect.register = register;\n  effect.blockingOn = blockingOn;\n  effect.trace = void 0;\n  if (trace) {\n    return effect.traced(trace);\n  }\n  return effect;\n});\n/* @internal */\nexport const asyncInterruptEither = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (register, blockingOn = FiberId.none) => suspendSucceed(() => {\n  let cancelerRef = unit();\n  return onInterrupt(() => cancelerRef)(async(resume => {\n    const result = restore(register)(resume);\n    if (Either.isRight(result)) {\n      resume(result.right);\n    } else {\n      cancelerRef = result.left;\n    }\n  }, blockingOn));\n}).traced(trace));\n/* @internal */\nexport const asyncInterrupt = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (register, blockingOn = FiberId.none) => suspendSucceed(() => {\n  let cancelerRef = unit();\n  return onInterrupt(() => cancelerRef)(async(resume => {\n    cancelerRef = restore(register)(resume);\n  }, blockingOn));\n}).traced(trace));\n/* @internal */\nexport const catchAllCause = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => {\n  const effect = Object.create(proto);\n  effect._tag = OpCodes.OP_ON_FAILURE;\n  effect.first = self;\n  effect.failK = restore(f);\n  effect.trace = void 0;\n  if (trace) {\n    return effect.traced(trace);\n  }\n  return effect;\n});\n/* @internal */\nexport const catchAll = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => matchEffect(restore(f), succeed)(self).traced(trace));\n/**\n * @macro identity\n * @internal\n */\nexport const unified = f => (...args) => f(...args);\n/* @internal */\nexport const catchSome = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, pf) => matchCauseEffect(unified(cause => {\n  const either = internalCause.failureOrCause(cause);\n  switch (either._tag) {\n    case \"Left\":\n      {\n        return Option.getOrElse(() => failCause(cause))(restore(pf)(either.left));\n      }\n    case \"Right\":\n      {\n        return failCause(either.right);\n      }\n  }\n}), succeed)(self).traced(trace));\n/* @internal */\nexport const checkInterruptible = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => f => withFiberRuntime((_, status) => restore(f)(_runtimeFlags.interruption(status.runtimeFlags))).traced(trace));\n/* @internal */\nexport const die = /*#__PURE__*/Debug.methodWithTrace(trace => defect => failCause(internalCause.die(defect)).traced(trace));\n/* @internal */\nexport const dieSync = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => evaluate => failCauseSync(() => internalCause.die(restore(evaluate)())).traced(trace));\n/* @internal */\nexport const done = /*#__PURE__*/Debug.methodWithTrace(trace => exit => suspendSucceed(() => exit).traced(trace));\n/* @internal */\nexport const either = /*#__PURE__*/Debug.methodWithTrace(trace => self => matchEffect(e => succeed(Either.left(e)), a => succeed(Either.right(a)))(self).traced(trace));\n/* @internal */\nexport const context = /*#__PURE__*/Debug.methodWithTrace(trace => () => suspendSucceed(() => fiberRefGet(currentContext)).traced(trace));\n/* @internal */\nexport const contextWithEffect = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => f => flatMap(restore(f))(context()).traced(trace));\n/* @internal */\nexport const exit = /*#__PURE__*/Debug.methodWithTrace(trace => self => matchCause(failCause, succeed)(self).traced(trace));\n/* @internal */\nexport const fail = /*#__PURE__*/Debug.methodWithTrace(trace => error => failCause(internalCause.fail(error)).traced(trace));\n/* @internal */\nexport const failSync = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => evaluate => failCauseSync(() => internalCause.fail(restore(evaluate)())).traced(trace));\n/* @internal */\nexport const failCause = /*#__PURE__*/Debug.methodWithTrace(trace => cause => {\n  const effect = Object.create(proto);\n  effect._tag = OpCodes.OP_FAILURE;\n  effect.cause = cause;\n  effect.trace = void 0;\n  if (trace) {\n    return effect.traced(trace);\n  }\n  return effect;\n});\n/* @internal */\nexport const failCauseSync = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => evaluate => flatMap(failCause)(sync(restore(evaluate))).traced(trace));\n/* @internal */\nexport const fiberId = /*#__PURE__*/Debug.methodWithTrace(trace => () => withFiberRuntime(state => succeed(state.id())).traced(trace));\n/* @internal */\nexport const fiberIdWith = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => f => withFiberRuntime(state => restore(f)(state.id())).traced(trace));\n/* @internal */\nexport const flatMap = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => {\n  const effect = Object.create(proto);\n  effect._tag = OpCodes.OP_ON_SUCCESS;\n  effect.first = self;\n  effect.successK = restore(f);\n  effect.trace = void 0;\n  if (trace) {\n    return effect.traced(trace);\n  }\n  return effect;\n});\n/* @internal */\nexport const flatten = /*#__PURE__*/Debug.methodWithTrace(trace => self => flatMap(identity)(self).traced(trace));\n/* @internal */\nexport const flip = /*#__PURE__*/Debug.methodWithTrace(trace => self => matchEffect(succeed, fail)(self).traced(trace));\n/* @internal */\nexport const matchCause = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, onFailure, onSuccess) => matchCauseEffect(cause => succeed(restore(onFailure)(cause)), a => succeed(restore(onSuccess)(a)))(self).traced(trace));\n/* @internal */\nexport const matchCauseEffect = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, onFailure, onSuccess) => {\n  const effect = Object.create(proto);\n  effect._tag = OpCodes.OP_ON_SUCCESS_AND_FAILURE;\n  effect.first = self;\n  effect.failK = restore(onFailure);\n  effect.successK = restore(onSuccess);\n  effect.trace = void 0;\n  if (trace) {\n    return effect.traced(trace);\n  }\n  return effect;\n});\n/* @internal */\nexport const matchEffect = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, onFailure, onSuccess) => matchCauseEffect(self, cause => {\n  const either = internalCause.failureOrCause(cause);\n  switch (either._tag) {\n    case \"Left\":\n      {\n        return restore(onFailure)(either.left);\n      }\n    case \"Right\":\n      {\n        return restore(failCause)(either.right);\n      }\n  }\n}, onSuccess).traced(trace));\n/* @internal */\nexport const forEach = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => suspendSucceed(() => {\n  const arr = Array.from(self);\n  const ret = new Array(arr.length);\n  let i = 0;\n  return as(Chunk.unsafeFromArray(ret))(whileLoop(() => i < arr.length, () => restore(f)(arr[i]), b => {\n    ret[i++] = b;\n  }));\n}).traced(trace));\n/* @internal */\nexport const forEachDiscard = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => suspendSucceed(() => {\n  const arr = Array.from(self);\n  let i = 0;\n  return whileLoop(() => i < arr.length, () => restore(f)(arr[i++]), () => {\n    //\n  });\n}).traced(trace));\n/* @internal */\nexport const fromOption = /*#__PURE__*/Debug.methodWithTrace(trace => option => {\n  switch (option._tag) {\n    case \"None\":\n      {\n        return fail(Option.none()).traced(trace);\n      }\n    case \"Some\":\n      {\n        return succeed(option.value).traced(trace);\n      }\n  }\n});\n/* @internal */\nexport const fromEither = /*#__PURE__*/Debug.methodWithTrace(trace => either => {\n  switch (either._tag) {\n    case \"Left\":\n      {\n        return fail(either.left).traced(trace);\n      }\n    case \"Right\":\n      {\n        return succeed(either.right).traced(trace);\n      }\n  }\n});\n/* @internal */\nexport const ifEffect = /*#__PURE__*/Debug.dualWithTrace(3, trace => (self, onTrue, onFalse) => flatMap(unified(b => b ? onTrue : onFalse))(self).traced(trace));\n/* @internal */\nexport const interrupt = /*#__PURE__*/Debug.methodWithTrace(trace => () => flatMap(fiberId => interruptWith(fiberId))(fiberId()).traced(trace));\n/* @internal */\nexport const interruptWith = /*#__PURE__*/Debug.methodWithTrace(trace => fiberId => failCause(internalCause.interrupt(fiberId)).traced(trace));\n/* @internal */\nexport const interruptible = /*#__PURE__*/Debug.methodWithTrace(trace => self => {\n  const effect = Object.create(proto);\n  effect._tag = OpCodes.OP_UPDATE_RUNTIME_FLAGS;\n  effect.update = RuntimeFlagsPatch.enable(_runtimeFlags.Interruption);\n  effect.scope = () => self;\n  effect.trace = void 0;\n  if (trace) {\n    return effect.traced(trace);\n  }\n  return effect;\n});\n/* @internal */\nexport const interruptibleMask = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => f => {\n  const effect = Object.create(proto);\n  effect._tag = OpCodes.OP_UPDATE_RUNTIME_FLAGS;\n  effect.update = RuntimeFlagsPatch.enable(_runtimeFlags.Interruption);\n  effect.scope = oldFlags => _runtimeFlags.interruption(oldFlags) ? restore(f)(interruptible) : restore(f)(uninterruptible);\n  effect.trace = void 0;\n  if (trace) {\n    return effect.traced(trace);\n  }\n  return effect;\n});\n/* @internal */\nexport const intoDeferred = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, deferred) => uninterruptibleMask(restore => flatMap(exit => deferredDone(deferred, exit))(exit(restore(self)))).traced(trace));\n/* @internal */\nexport const map = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => flatMap(a => sync(() => restore(f)(a)))(self).traced(trace));\n/* @internal */\nexport const mapError = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => matchCauseEffect(self, cause => {\n  const either = internalCause.failureOrCause(cause);\n  switch (either._tag) {\n    case \"Left\":\n      {\n        return failSync(() => restore(f)(either.left));\n      }\n    case \"Right\":\n      {\n        return failCause(either.right);\n      }\n  }\n}, succeed).traced(trace));\n/* @internal */\nexport const never = /*#__PURE__*/Debug.methodWithTrace(trace => () => asyncInterruptEither(() => {\n  const interval = setInterval(() => {\n    //\n  }, 2 ** 31 - 1);\n  return Either.left(sync(() => clearInterval(interval)));\n}).traced(trace));\n/* @internal */\nexport const onError = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, cleanup) => onExit(self, unified(exit => exitIsSuccess(exit) ? unit() : restore(cleanup)(exit.cause))).traced(trace));\n/* @internal */\nexport const onExit = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restoreTrace) => (self, cleanup) => uninterruptibleMask(restore => matchCauseEffect(restore(self), cause1 => {\n  const result = exitFailCause(cause1);\n  return matchCauseEffect(cause2 => exitFailCause(internalCause.sequential(cause1, cause2)), () => result)(restoreTrace(cleanup)(result));\n}, success => {\n  const result = exitSucceed(success);\n  return zipRight(result)(restoreTrace(cleanup)(result));\n})).traced(trace));\n/* @internal */\nexport const onInterrupt = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, cleanup) => onExit(self, exitMatch(cause => internalCause.isInterruptedOnly(cause) ? asUnit(restore(cleanup)(internalCause.interruptors(cause))) : unit(), () => unit())).traced(trace));\n/* @internal */\nexport const orElse = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, that) => tryOrElse(restore(that), succeed)(self).traced(trace));\n/* @internal */\nexport const orDie = /*#__PURE__*/Debug.methodWithTrace(trace => self => orDieWith(identity)(self).traced(trace));\n/* @internal */\nexport const orDieWith = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => matchEffect(e => die(restore(f)(e)), succeed)(self).traced(trace));\n/* @internal */\nexport const partitionMap = (elements, f) => Array.from(elements).reduceRight(([lefts, rights], current) => {\n  const either = f(current);\n  switch (either._tag) {\n    case \"Left\":\n      {\n        return [Chunk.prepend(either.left)(lefts), rights];\n      }\n    case \"Right\":\n      {\n        return [lefts, Chunk.prepend(either.right)(rights)];\n      }\n  }\n}, [Chunk.empty(), Chunk.empty()]);\n/* @internal */\nexport const provideContext = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, context) => fiberRefLocally(currentContext, context)(self).traced(trace));\n/* @internal */\nexport const contramapContext = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => contextWithEffect(context => provideContext(restore(f)(context))(self)).traced(trace));\n/* @internal */\nexport const runtimeFlags = /*#__PURE__*/Debug.methodWithTrace(trace => () => withFiberRuntime((_, status) => succeed(status.runtimeFlags)).traced(trace));\n/* @internal */\nexport const service = /*#__PURE__*/Debug.methodWithTrace(trace => tag => serviceWithEffect(tag, succeed).traced(trace));\n/* @internal */\nexport const serviceWith = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (tag, f) => serviceWithEffect(tag, a => sync(() => restore(f)(a))).traced(trace));\n/* @internal */\nexport const serviceWithEffect = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (tag, f) => suspendSucceed(() => flatMap(env => restore(f)(Context.unsafeGet(tag)(env)))(fiberRefGet(currentContext))).traced(trace));\n/* @internal */\nexport const succeed = /*#__PURE__*/Debug.methodWithTrace(trace => value => {\n  const effect = Object.create(proto);\n  effect._tag = OpCodes.OP_SUCCESS;\n  effect.value = value;\n  effect.trace = void 0;\n  if (trace) {\n    return effect.traced(trace);\n  }\n  return effect;\n});\n/* @internal */\nexport const suspendSucceed = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => effect => flatMap(identity)(sync(restore(effect))).traced(trace));\n/* @internal */\nexport const sync = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => evaluate => {\n  const effect = Object.create(proto);\n  effect._tag = OpCodes.OP_SYNC;\n  effect.evaluate = restore(evaluate);\n  effect.trace = void 0;\n  if (trace) {\n    return effect.traced(trace);\n  }\n  return effect;\n});\n/* @internal */\nexport const tags = /*#__PURE__*/Debug.methodWithTrace(trace => () => fiberRefGet(currentTags).traced(trace));\n/* @internal */\nexport const tap = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => flatMap(a => as(a)(restore(f)(a)))(self).traced(trace));\n/* @internal */\nexport const transplant = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => f => withFiberRuntime(state => {\n  const scopeOverride = state.getFiberRef(forkScopeOverride);\n  const scope = Option.getOrElse(() => state.scope())(scopeOverride);\n  return restore(f)(fiberRefLocally(forkScopeOverride, Option.some(scope)));\n}).traced(trace));\n/* @internal */\nexport const tryOrElse = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, that, onSuccess) => matchCauseEffect(self, cause => {\n  const option = internalCause.keepDefects(cause);\n  switch (option._tag) {\n    case \"None\":\n      {\n        return restore(that)();\n      }\n    case \"Some\":\n      {\n        return failCause(option.value);\n      }\n  }\n}, restore(onSuccess)).traced(trace));\n/* @internal */\nexport const uninterruptible = /*#__PURE__*/Debug.methodWithTrace(trace => self => {\n  const effect = Object.create(proto);\n  effect._tag = OpCodes.OP_UPDATE_RUNTIME_FLAGS;\n  effect.update = RuntimeFlagsPatch.disable(_runtimeFlags.Interruption);\n  effect.scope = () => self;\n  effect.trace = void 0;\n  if (trace) {\n    return effect.traced(trace);\n  }\n  return effect;\n});\n/* @internal */\nexport const uninterruptibleMask = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => f => {\n  const effect = Object.create(proto);\n  effect._tag = OpCodes.OP_UPDATE_RUNTIME_FLAGS;\n  effect.update = RuntimeFlagsPatch.disable(_runtimeFlags.Interruption);\n  effect.scope = oldFlags => {\n    return _runtimeFlags.interruption(oldFlags) ? restore(f)(interruptible) : restore(f)(uninterruptible);\n  };\n  effect.trace = void 0;\n  if (trace) {\n    return effect.traced(trace);\n  }\n  return effect;\n});\n/* @internal */\nexport const unit = /*#__PURE__*/Debug.methodWithTrace(trace => _ => succeed(void 0).traced(trace));\n/* @internal */\nexport const updateRuntimeFlags = /*#__PURE__*/Debug.methodWithTrace(trace => patch => {\n  const effect = Object.create(proto);\n  effect._tag = OpCodes.OP_UPDATE_RUNTIME_FLAGS;\n  effect.update = patch;\n  effect.scope = void 0;\n  effect.trace = void 0;\n  if (trace) {\n    return effect.traced(trace);\n  }\n  return effect;\n});\n/* @internal */\nexport const whenEffect = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, predicate) => flatMap(b => {\n  if (b) {\n    return map(Option.some)(self);\n  }\n  return succeed(Option.none());\n})(predicate).traced(trace));\n/* @internal */\nexport const whileLoop = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (check, body, process) => {\n  const effect = Object.create(proto);\n  effect._tag = OpCodes.OP_WHILE;\n  effect.check = restore(check);\n  effect.body = restore(body);\n  effect.process = restore(process);\n  effect.trace = void 0;\n  if (trace) {\n    return effect.traced(trace);\n  }\n  return effect;\n});\n/* @internal */\nexport const withFiberRuntime = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => withRuntime => {\n  const effect = Object.create(proto);\n  effect._tag = OpCodes.OP_WITH_RUNTIME;\n  effect.withRuntime = restore(withRuntime);\n  effect.trace = void 0;\n  if (trace) {\n    return effect.traced(trace);\n  }\n  return effect;\n});\n/* @internal */\nexport const withParallelism = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, parallelism) => suspendSucceed(() => fiberRefLocally(currentParallelism, Option.some(parallelism))(self)).traced(trace));\n/* @internal */\nexport const withParallelismUnbounded = /*#__PURE__*/Debug.methodWithTrace(trace => self => suspendSucceed(() => fiberRefLocally(currentParallelism, Option.none())(self)).traced(trace));\n/* @internal */\nexport const withRuntimeFlags = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, update) => {\n  const effect = Object.create(proto);\n  effect._tag = OpCodes.OP_UPDATE_RUNTIME_FLAGS;\n  effect.update = update;\n  effect.scope = () => self;\n  effect.trace = void 0;\n  if (trace) {\n    return effect.traced(trace);\n  }\n  return effect;\n});\n/* @internal */\nexport const yieldNow = /*#__PURE__*/Debug.methodWithTrace(trace => (priority = \"normal\") => {\n  const effect = Object.create(proto);\n  effect._tag = OpCodes.OP_YIELD;\n  effect.priority = priority;\n  effect.trace = void 0;\n  if (trace) {\n    return effect.traced(trace);\n  }\n  return effect;\n});\n/* @internal */\nexport const zip = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => flatMap(self, a => map(that, b => [a, b])).traced(trace));\n/* @internal */\nexport const zipFlatten = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => flatMap(self, a => map(that, b => [...a, b])).traced(trace));\n/* @internal */\nexport const zipLeft = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => flatMap(self, a => as(that, a)).traced(trace));\n/* @internal */\nexport const zipRight = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => flatMap(self, () => that).traced(trace));\n/* @internal */\nexport const zipWith = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, that, f) => flatMap(self, a => map(that, b => restore(f)(a, b))).traced(trace));\n// -----------------------------------------------------------------------------\n// Fiber\n// -----------------------------------------------------------------------------\n/* @internal */\nexport const interruptFiber = /*#__PURE__*/Debug.methodWithTrace(trace => self => flatMap(fiberId => interruptAsFiber(fiberId)(self))(fiberId()).traced(trace));\n/* @internal */\nexport const interruptAsFiber = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, fiberId) => flatMap(() => self.await())(self.interruptAsFork(fiberId)).traced(trace));\n// -----------------------------------------------------------------------------\n// LogLevel\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const logLevelAll = {\n  _tag: \"All\",\n  syslog: 0,\n  label: \"ALL\",\n  ordinal: Number.MIN_SAFE_INTEGER\n};\n/** @internal */\nexport const logLevelFatal = {\n  _tag: \"Fatal\",\n  syslog: 2,\n  label: \"FATAL\",\n  ordinal: 50000\n};\n/** @internal */\nexport const logLevelError = {\n  _tag: \"Error\",\n  syslog: 3,\n  label: \"ERROR\",\n  ordinal: 40000\n};\n/** @internal */\nexport const logLevelWarning = {\n  _tag: \"Warning\",\n  syslog: 4,\n  label: \"WARN\",\n  ordinal: 30000\n};\n/** @internal */\nexport const logLevelInfo = {\n  _tag: \"Info\",\n  syslog: 6,\n  label: \"INFO\",\n  ordinal: 20000\n};\n/** @internal */\nexport const logLevelDebug = {\n  _tag: \"Debug\",\n  syslog: 7,\n  label: \"DEBUG\",\n  ordinal: 10000\n};\n/** @internal */\nexport const logLevelTrace = {\n  _tag: \"Trace\",\n  syslog: 7,\n  label: \"TRACE\",\n  ordinal: 0\n};\n/** @internal */\nexport const logLevelNone = {\n  _tag: \"None\",\n  syslog: 7,\n  label: \"OFF\",\n  ordinal: Number.MAX_SAFE_INTEGER\n};\n// -----------------------------------------------------------------------------\n// FiberRef\n// -----------------------------------------------------------------------------\n/** @internal */\nconst FiberRefSymbolKey = \"@effect/io/FiberRef\";\n/** @internal */\nexport const FiberRefTypeId = /*#__PURE__*/Symbol.for(FiberRefSymbolKey);\n/** @internal */\nconst fiberRefVariance = {\n  _A: _ => _\n};\n/* @internal */\nexport const fiberRefGet = /*#__PURE__*/Debug.methodWithTrace(trace => self => fiberRefModify(self, a => [a, a]).traced(trace));\n/* @internal */\nexport const fiberRefGetAndSet = /*#__PURE__*/Debug.methodWithTrace(trace => (self, value) => fiberRefModify(self, v => [v, value]).traced(trace));\n/* @internal */\nexport const fiberRefGetAndUpdate = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (self, f) => fiberRefModify(self, v => [v, restore(f)(v)]).traced(trace));\n/* @internal */\nexport const fiberRefGetAndUpdateSome = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (self, pf) => fiberRefModify(self, v => [v, Option.getOrElse(() => v)(restore(pf)(v))]).traced(trace));\n/* @internal */\nexport const fiberRefGetWith = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (self, f) => flatMap(restore(f))(fiberRefGet(self)).traced(trace));\n/* @internal */\nexport const fiberRefSet = /*#__PURE__*/Debug.methodWithTrace(trace => (self, value) => fiberRefModify(self, () => [void 0, value]).traced(trace));\n/* @internal */\nexport const fiberRefDelete = /*#__PURE__*/Debug.methodWithTrace(trace => self => withFiberRuntime(state => {\n  state.unsafeDeleteFiberRef(self);\n  return unit();\n}).traced(trace));\n/* @internal */\nexport const fiberRefReset = /*#__PURE__*/Debug.methodWithTrace(trace => self => fiberRefSet(self, self.initial).traced(trace));\n/* @internal */\nexport const fiberRefModify = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (self, f) => withFiberRuntime(state => {\n  const [b, a] = restore(f)(state.getFiberRef(self));\n  state.setFiberRef(self, a);\n  return succeed(b);\n}).traced(trace));\n/* @internal */\nexport const fiberRefModifySome = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (self, def, f) => fiberRefModify(self, v => Option.getOrElse(() => [def, v])(restore(f)(v))).traced(trace));\n/* @internal */\nexport const fiberRefUpdate = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (self, f) => fiberRefModify(self, v => [void 0, restore(f)(v)]).traced(trace));\n/* @internal */\nexport const fiberRefUpdateSome = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (self, pf) => fiberRefModify(self, v => [void 0, Option.getOrElse(() => v)(restore(pf)(v))]).traced(trace));\n/* @internal */\nexport const fiberRefUpdateAndGet = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (self, f) => fiberRefModify(self, v => {\n  const result = restore(f)(v);\n  return [result, result];\n}).traced(trace));\n/* @internal */\nexport const fiberRefUpdateSomeAndGet = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (self, pf) => fiberRefModify(self, v => {\n  const result = Option.getOrElse(() => v)(restore(pf)(v));\n  return [result, result];\n}).traced(trace));\n/* @internal */\nexport const fiberRefLocally = /*#__PURE__*/Debug.dualWithTrace(3, trace => (use, self, value) => acquireUseRelease(zipLeft(fiberRefSet(self, value))(fiberRefGet(self)), () => use, oldValue => fiberRefSet(self, oldValue)).traced(trace));\n/* @internal */\nexport const fiberRefLocallyWith = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (use, self, f) => fiberRefGetWith(self, a => fiberRefLocally(self, restore(f)(a))(use)).traced(trace));\n/** @internal */\nexport const fiberRefUnsafeMake = (initial, fork = identity, join = (_, a) => a) => fiberRefUnsafeMakePatch(initial, Differ.update(), fork, join);\n/** @internal */\nexport const fiberRefUnsafeMakeHashSet = initial => fiberRefUnsafeMakePatch(initial, Differ.hashSet(), HashSetPatch.empty());\n/** @internal */\nexport const fiberRefUnsafeMakeContext = initial => fiberRefUnsafeMakePatch(initial, Differ.environment(), ContextPatch.empty());\n/** @internal */\nexport const fiberRefUnsafeMakePatch = (initial, differ, fork, join = (_, n) => n) => ({\n  [FiberRefTypeId]: fiberRefVariance,\n  initial,\n  diff: (oldValue, newValue) => Differ.diff(oldValue, newValue)(differ),\n  combine: (first, second) => Differ.combine(first, second)(differ),\n  patch: patch => oldValue => Differ.patch(patch, oldValue)(differ),\n  fork,\n  join\n});\n/** @internal */\nexport const fiberRefUnsafeMakeRuntimeFlags = initial => fiberRefUnsafeMakePatch(initial, _runtimeFlags.differ(), RuntimeFlagsPatch.empty);\n/** @internal */\nexport const currentContext = /*#__PURE__*/fiberRefUnsafeMakeContext( /*#__PURE__*/Context.empty());\n/** @internal */\nexport const currentLogAnnotations = /*#__PURE__*/fiberRefUnsafeMake( /*#__PURE__*/HashMap.empty());\n/** @internal */\nexport const currentLogLevel = /*#__PURE__*/fiberRefUnsafeMake(logLevelInfo);\n/** @internal */\nexport const currentLogSpan = /*#__PURE__*/fiberRefUnsafeMake( /*#__PURE__*/Chunk.empty());\n/** @internal */\nexport const currentScheduler = /*#__PURE__*/fiberRefUnsafeMake(scheduler.defaultScheduler);\n/** @internal */\nexport const currentParallelism = /*#__PURE__*/fiberRefUnsafeMake( /*#__PURE__*/Option.none());\n/** @internal */\nexport const currentTags = /*#__PURE__*/fiberRefUnsafeMakeHashSet( /*#__PURE__*/HashSet.empty());\n/** @internal */\nexport const forkScopeOverride = /*#__PURE__*/fiberRefUnsafeMake( /*#__PURE__*/Option.none(), () => Option.none(), (parent, _) => parent);\n/** @internal */\nexport const interruptedCause = /*#__PURE__*/fiberRefUnsafeMake(internalCause.empty, () => internalCause.empty, (parent, _) => parent);\n// -----------------------------------------------------------------------------\n// Scope\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const ScopeTypeId = /*#__PURE__*/Symbol.for(\"@effect/io/Scope\");\n/** @internal */\nexport const CloseableScopeTypeId = /*#__PURE__*/Symbol.for(\"@effect/io/CloseableScope\");\n/* @internal */\nexport const scopeAddFinalizer = /*#__PURE__*/Debug.methodWithTrace(trace => (self, finalizer) => self.addFinalizer(() => asUnit(finalizer)).traced(trace));\n/* @internal */\nexport const scopeAddFinalizerExit = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (self, finalizer) => self.addFinalizer(restore(finalizer)).traced(trace));\n/* @internal */\nexport const scopeClose = /*#__PURE__*/Debug.methodWithTrace(trace => (self, exit) => self.close(exit).traced(trace));\n/* @internal */\nexport const scopeFork = /*#__PURE__*/Debug.methodWithTrace(trace => (self, strategy) => self.fork(strategy).traced(trace));\n/* @internal */\nexport const releaseMapAdd = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, finalizer) => map(Option.match(() => () => unit(), key => exit => releaseMapRelease(key, exit)(self)))(releaseMapAddIfOpen(restore(finalizer))(self)).traced(trace));\n/* @internal */\nexport const releaseMapRelease = /*#__PURE__*/Debug.dualWithTrace(3, trace => (self, key, exit) => suspendSucceed(() => {\n  switch (self.state._tag) {\n    case \"Exited\":\n      {\n        return unit();\n      }\n    case \"Running\":\n      {\n        const finalizer = self.state.finalizers.get(key);\n        self.state.finalizers.delete(key);\n        if (finalizer != null) {\n          return self.state.update(finalizer)(exit);\n        }\n        return unit();\n      }\n  }\n}).traced(trace));\n/* @internal */\nexport const releaseMapAddIfOpen = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, finalizer) => suspendSucceed(() => {\n  switch (self.state._tag) {\n    case \"Exited\":\n      {\n        self.state.nextKey += 1;\n        return as(Option.none())(restore(finalizer)(self.state.exit));\n      }\n    case \"Running\":\n      {\n        const key = self.state.nextKey;\n        self.state.finalizers.set(key, finalizer);\n        self.state.nextKey += 1;\n        return succeed(Option.some(key));\n      }\n  }\n}).traced(trace));\n/* @internal */\nexport const releaseMapGet = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, key) => sync(() => self.state._tag === \"Running\" ? Option.fromNullable(self.state.finalizers.get(key)) : Option.none()).traced(trace));\n/* @internal */\nexport const releaseMapReplace = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, key, finalizer) => suspendSucceed(() => {\n  switch (self.state._tag) {\n    case \"Exited\":\n      {\n        return as(Option.none())(restore(finalizer)(self.state.exit));\n      }\n    case \"Running\":\n      {\n        const fin = Option.fromNullable(self.state.finalizers.get(key));\n        self.state.finalizers.set(key, restore(finalizer));\n        return succeed(fin);\n      }\n  }\n}).traced(trace));\n/* @internal */\nexport const releaseMapRemove = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, key) => sync(() => {\n  if (self.state._tag === \"Exited\") {\n    return Option.none();\n  }\n  const fin = Option.fromNullable(self.state.finalizers.get(key));\n  self.state.finalizers.delete(key);\n  return fin;\n}).traced(trace));\n/* @internal */\nexport const releaseMapMake = /*#__PURE__*/Debug.methodWithTrace(trace => () => sync(() => ({\n  state: {\n    _tag: \"Running\",\n    nextKey: 0,\n    finalizers: new Map(),\n    update: identity\n  }\n})).traced(trace));\n// -----------------------------------------------------------------------------\n// Exit\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const exitIsExit = u => isEffect(u) && \"_tag\" in u && (u._tag === \"Success\" || u._tag === \"Failure\");\n/** @internal */\nexport const exitIsFailure = self => self._tag === \"Failure\";\n/** @internal */\nexport const exitIsSuccess = self => self._tag === \"Success\";\n/** @internal */\nexport const exitIsInterrupted = self => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      {\n        return internalCause.isInterrupted(self.cause);\n      }\n    case OpCodes.OP_SUCCESS:\n      {\n        return false;\n      }\n  }\n};\n/** @internal */\nexport const exitAs = /*#__PURE__*/Debug.dual(2, (self, value) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      {\n        return self;\n      }\n    case OpCodes.OP_SUCCESS:\n      {\n        return exitSucceed(value);\n      }\n  }\n});\n/** @internal */\nexport const exitAsUnit = self => exitAs(self, void 0);\n/** @internal */\nexport const exitCauseOption = self => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      {\n        return Option.some(self.cause);\n      }\n    case OpCodes.OP_SUCCESS:\n      {\n        return Option.none();\n      }\n  }\n};\n/** @internal */\nexport const exitCollectAll = exits => exitCollectAllInternal(exits, internalCause.sequential);\n/** @internal */\nexport const exitCollectAllPar = exits => exitCollectAllInternal(exits, internalCause.parallel);\n/** @internal */\nexport const exitDie = defect => exitFailCause(internalCause.die(defect));\n/** @internal */\nexport const exitExists = /*#__PURE__*/Debug.dual(2, (self, predicate) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      {\n        return false;\n      }\n    case OpCodes.OP_SUCCESS:\n      {\n        return predicate(self.value);\n      }\n  }\n});\n/** @internal */\nexport const exitFail = error => exitFailCause(internalCause.fail(error));\n/** @internal */\nexport const exitFailCause = cause => {\n  const exit = Object.create(proto);\n  exit._tag = OpCodes.OP_FAILURE;\n  exit.cause = cause;\n  exit.trace = void 0;\n  return exit;\n};\n/** @internal */\nexport const exitFlatMap = /*#__PURE__*/Debug.dual(2, (self, f) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      {\n        return self;\n      }\n    case OpCodes.OP_SUCCESS:\n      {\n        return f(self.value);\n      }\n  }\n});\n/** @internal */\nexport const exitFlatMapEffect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      {\n        return succeed(self).traced(trace);\n      }\n    case OpCodes.OP_SUCCESS:\n      {\n        return restore(f)(self.value).traced(trace);\n      }\n  }\n});\n/** @internal */\nexport const exitFlatten = self => exitFlatMap(identity)(self);\n/** @internal */\nexport const exitForEachEffect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      {\n        return succeed(exitFailCause(self.cause)).traced(trace);\n      }\n    case OpCodes.OP_SUCCESS:\n      {\n        return exit(restore(f)(self.value)).traced(trace);\n      }\n  }\n});\n/** @internal */\nexport const exitFromEither = either => {\n  switch (either._tag) {\n    case \"Left\":\n      {\n        return exitFail(either.left);\n      }\n    case \"Right\":\n      {\n        return exitSucceed(either.right);\n      }\n  }\n};\n/** @internal */\nexport const exitFromOption = option => {\n  switch (option._tag) {\n    case \"None\":\n      {\n        return exitFail(void 0);\n      }\n    case \"Some\":\n      {\n        return exitSucceed(option.value);\n      }\n  }\n};\n/** @internal */\nexport const exitGetOrElse = /*#__PURE__*/Debug.dual(2, (self, orElse) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      {\n        return orElse(self.cause);\n      }\n    case OpCodes.OP_SUCCESS:\n      {\n        return self.value;\n      }\n  }\n});\n/** @internal */\nexport const exitInterrupt = fiberId => exitFailCause(internalCause.interrupt(fiberId));\n/** @internal */\nexport const exitMap = /*#__PURE__*/Debug.dual(2, (self, f) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      {\n        return self;\n      }\n    case OpCodes.OP_SUCCESS:\n      {\n        return exitSucceed(f(self.value));\n      }\n  }\n});\n/** @internal */\nexport const exitMapBoth = /*#__PURE__*/Debug.dual(3, (self, onFailure, onSuccess) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      {\n        return exitFailCause(internalCause.map(onFailure)(self.cause));\n      }\n    case OpCodes.OP_SUCCESS:\n      {\n        return exitSucceed(onSuccess(self.value));\n      }\n  }\n});\n/** @internal */\nexport const exitMapError = /*#__PURE__*/Debug.dual(2, (self, f) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      {\n        return exitFailCause(internalCause.map(f)(self.cause));\n      }\n    case OpCodes.OP_SUCCESS:\n      {\n        return self;\n      }\n  }\n});\n/** @internal */\nexport const exitMapErrorCause = /*#__PURE__*/Debug.dual(2, (self, f) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      {\n        return exitFailCause(f(self.cause));\n      }\n    case OpCodes.OP_SUCCESS:\n      {\n        return self;\n      }\n  }\n});\n/** @internal */\nexport const exitMatch = /*#__PURE__*/Debug.dual(3, (self, onFailure, onSuccess) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      {\n        return onFailure(self.cause);\n      }\n    case OpCodes.OP_SUCCESS:\n      {\n        return onSuccess(self.value);\n      }\n  }\n});\n/** @internal */\nexport const exitMatchEffect = /*#__PURE__*/Debug.dual(3, (self, onFailure, onSuccess) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      {\n        return onFailure(self.cause);\n      }\n    case OpCodes.OP_SUCCESS:\n      {\n        return onSuccess(self.value);\n      }\n  }\n});\n/** @internal */\nexport const exitSucceed = value => {\n  const exit = Object.create(proto);\n  exit._tag = OpCodes.OP_SUCCESS;\n  exit.value = value;\n  exit.trace = void 0;\n  return exit;\n};\n/** @internal */\nexport const exitUnannotate = exit => exitIsSuccess(exit) ? exit : exitFailCause(internalCause.unannotate(exit.cause));\n/** @internal */\nexport const exitUnit = () => exitSucceed(void 0);\n/** @internal */\nexport const exitZip = /*#__PURE__*/Debug.dual(2, (self, that) => exitZipWith(self, that, (a, a2) => [a, a2], internalCause.sequential));\n/** @internal */\nexport const exitZipLeft = /*#__PURE__*/Debug.dual(2, (self, that) => exitZipWith(self, that, (a, _) => a, internalCause.sequential));\n/** @internal */\nexport const exitZipRight = /*#__PURE__*/Debug.dual(2, (self, that) => exitZipWith(self, that, (_, a2) => a2, internalCause.sequential));\n/** @internal */\nexport const exitZipPar = /*#__PURE__*/Debug.dual(2, (self, that) => exitZipWith(self, that, (a, a2) => [a, a2], internalCause.parallel));\n/** @internal */\nexport const exitZipParLeft = /*#__PURE__*/Debug.dual(2, (self, that) => exitZipWith(self, that, (a, _) => a, internalCause.parallel));\n/** @internal */\nexport const exitZipParRight = /*#__PURE__*/Debug.dual(2, (self, that) => exitZipWith(self, that, (_, a2) => a2, internalCause.parallel));\n/** @internal */\nexport const exitZipWith = /*#__PURE__*/Debug.dual(4, (self, that, f, g) => {\n  switch (self._tag) {\n    case OpCodes.OP_FAILURE:\n      {\n        switch (that._tag) {\n          case OpCodes.OP_SUCCESS:\n            {\n              return self;\n            }\n          case OpCodes.OP_FAILURE:\n            {\n              return exitFailCause(g(self.cause, that.cause));\n            }\n        }\n      }\n    case OpCodes.OP_SUCCESS:\n      {\n        switch (that._tag) {\n          case OpCodes.OP_SUCCESS:\n            {\n              return exitSucceed(f(self.value, that.value));\n            }\n          case OpCodes.OP_FAILURE:\n            {\n              return that;\n            }\n        }\n      }\n  }\n});\nconst exitCollectAllInternal = (exits, combineCauses) => {\n  const list = Chunk.fromIterable(exits);\n  if (!Chunk.isNonEmpty(list)) {\n    return Option.none();\n  }\n  return Option.some(exitMap(Chunk.reverse)(Chunk.reduce(exitMap(Chunk.of)(Chunk.headNonEmpty(list)), (accumulator, current) => exitZipWith(current, (list, value) => Chunk.prepend(value)(list), combineCauses)(accumulator))(Chunk.tailNonEmpty(list))));\n};\n// -----------------------------------------------------------------------------\n// Deferred\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const deferredUnsafeMake = fiberId => ({\n  [deferred.DeferredTypeId]: deferred.deferredVariance,\n  state: MutableRef.make(deferred.pending([])),\n  blockingOn: fiberId\n});\n/* @internal */\nexport const deferredMake = /*#__PURE__*/Debug.methodWithTrace(trace => () => flatMap(id => deferredMakeAs(id))(fiberId()).traced(trace));\n/* @internal */\nexport const deferredMakeAs = /*#__PURE__*/Debug.methodWithTrace(trace => fiberId => sync(() => deferredUnsafeMake(fiberId)).traced(trace));\n/* @internal */\nexport const deferredAwait = /*#__PURE__*/Debug.methodWithTrace(trace => self => asyncInterruptEither(k => {\n  const state = MutableRef.get(self.state);\n  switch (state._tag) {\n    case DeferredOpCodes.OP_STATE_DONE:\n      {\n        return Either.right(state.effect);\n      }\n    case DeferredOpCodes.OP_STATE_PENDING:\n      {\n        MutableRef.set(deferred.pending([k, ...state.joiners]))(self.state);\n        return Either.left(deferredInterruptJoiner(self, k));\n      }\n  }\n}, self.blockingOn).traced(trace));\n/* @internal */\nexport const deferredComplete = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, effect) => intoDeferred(effect, self).traced(trace));\n/* @internal */\nexport const deferredCompleteWith = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, effect) => sync(() => {\n  const state = MutableRef.get(self.state);\n  switch (state._tag) {\n    case DeferredOpCodes.OP_STATE_DONE:\n      {\n        return false;\n      }\n    case DeferredOpCodes.OP_STATE_PENDING:\n      {\n        MutableRef.set(deferred.done(effect))(self.state);\n        for (let i = 0; i < state.joiners.length; i++) {\n          state.joiners[i](effect);\n        }\n        return true;\n      }\n  }\n}).traced(trace));\n/* @internal */\nexport const deferredDone = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, exit) => deferredCompleteWith(self, done(exit)).traced(trace));\n/* @internal */\nexport const deferredFail = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, error) => deferredCompleteWith(self, fail(error)).traced(trace));\n/* @internal */\nexport const deferredFailSync = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, evaluate) => deferredCompleteWith(self, failSync(restore(evaluate))).traced(trace));\n/* @internal */\nexport const deferredFailCause = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, cause) => deferredCompleteWith(self, failCause(cause)).traced(trace));\n/* @internal */\nexport const deferredFailCauseSync = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, evaluate) => deferredCompleteWith(self, failCauseSync(restore(evaluate))).traced(trace));\n/* @internal */\nexport const deferredDie = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, defect) => deferredCompleteWith(self, die(defect)).traced(trace));\n/* @internal */\nexport const deferredDieSync = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, evaluate) => deferredCompleteWith(self, dieSync(restore(evaluate))).traced(trace));\n/* @internal */\nexport const deferredInterrupt = /*#__PURE__*/Debug.methodWithTrace(trace => self => flatMap(fiberId => deferredCompleteWith(self, interruptWith(fiberId)))(fiberId()).traced(trace));\n/* @internal */\nexport const deferredInterruptWith = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, fiberId) => deferredCompleteWith(self, interruptWith(fiberId)).traced(trace));\n/* @internal */\nexport const deferredIsDone = /*#__PURE__*/Debug.methodWithTrace(trace => self => sync(() => MutableRef.get(self.state)._tag === DeferredOpCodes.OP_STATE_DONE).traced(trace));\n/* @internal */\nexport const deferredPoll = /*#__PURE__*/Debug.methodWithTrace(trace => self => sync(() => {\n  const state = MutableRef.get(self.state);\n  switch (state._tag) {\n    case DeferredOpCodes.OP_STATE_DONE:\n      {\n        return Option.some(state.effect);\n      }\n    case DeferredOpCodes.OP_STATE_PENDING:\n      {\n        return Option.none();\n      }\n  }\n}).traced(trace));\n/* @internal */\nexport const deferredSucceed = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, value) => deferredCompleteWith(self, succeed(value)).traced(trace));\n/* @internal */\nexport const deferredSync = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, evaluate) => deferredCompleteWith(self, sync(restore(evaluate))).traced(trace));\n/** @internal */\nexport const deferredUnsafeDone = (self, effect) => {\n  const state = MutableRef.get(self.state);\n  if (state._tag === DeferredOpCodes.OP_STATE_PENDING) {\n    MutableRef.set(deferred.done(effect))(self.state);\n    for (let i = state.joiners.length - 1; i >= 0; i--) {\n      state.joiners[i](effect);\n    }\n  }\n};\nconst deferredInterruptJoiner = (self, joiner) => sync(() => {\n  const state = MutableRef.get(self.state);\n  if (state._tag === DeferredOpCodes.OP_STATE_PENDING) {\n    MutableRef.set(deferred.pending(state.joiners.filter(j => j !== joiner)))(self.state);\n  }\n});\n//# sourceMappingURL=core.mjs.map","import * as Debug from \"@effect/io/Debug\";\nimport * as internal from \"@effect/io/internal_effect_untraced/cause\";\nimport { StackAnnotation } from \"@effect/io/internal_effect_untraced/cause\";\nimport * as core from \"@effect/io/internal_effect_untraced/core\";\nimport * as OpCodes from \"@effect/io/internal_effect_untraced/opCodes/cause\";\nimport * as Option from \"@fp-ts/core/Option\";\nimport * as Chunk from \"@fp-ts/data/Chunk\";\n// -----------------------------------------------------------------------------\n// Pretty Printing\n// -----------------------------------------------------------------------------\n/** @internal */\nconst renderToString = u => {\n  if (typeof u === \"object\" && u != null && \"toString\" in u && typeof u[\"toString\"] === \"function\" && u[\"toString\"] !== Object.prototype.toString) {\n    return u[\"toString\"]();\n  }\n  if (typeof u === \"string\") {\n    return `Error: ${u}`;\n  }\n  if (typeof u === \"object\" && u !== null) {\n    if (\"message\" in u && typeof u[\"message\"] === \"string\") {\n      const raw = JSON.parse(JSON.stringify(u));\n      const keys = new Set(Object.keys(raw));\n      keys.delete(\"name\");\n      keys.delete(\"message\");\n      keys.delete(\"_tag\");\n      if (keys.size === 0) {\n        return `${\"name\" in u && typeof u.name === \"string\" ? u.name : \"Error\"}${\"_tag\" in u && typeof u[\"_tag\"] === \"string\" ? `(${u._tag})` : ``}: ${u.message}`;\n      }\n    }\n  }\n  return `Error: ${JSON.stringify(u)}`;\n};\nconst renderTraces = chunk => {\n  const ret = [];\n  for (const s of chunk) {\n    const r = s?.toFrame();\n    if (r) {\n      if (Debug.runtimeDebug.filterStackFrame(r)) {\n        ret.push(renderFrame(r));\n      }\n    }\n  }\n  return ret;\n};\n/** @internal */\nconst renderStack = span => {\n  if (Option.isNone(span)) {\n    return [];\n  }\n  if (span.value.stack.length > 0) {\n    return renderTraces(span.value.stack);\n  }\n  return [];\n};\n/** @internal */\nconst renderFail = (error, stack) => {\n  return [new RenderError(stack._tag === \"Some\" ? stack.value.seq : 0, error, renderStack(stack).join(\"\\r\\n\"))];\n};\n/** @internal */\nconst renderError = error => {\n  if (error.stack) {\n    const stack = Debug.runtimeDebug.parseStack(error);\n    const traces = [];\n    for (const frame of stack) {\n      if (frame) {\n        if (Debug.runtimeDebug.filterStackFrame(frame)) {\n          traces.push(renderFrame(frame));\n        } else {\n          break;\n        }\n      }\n    }\n    return [renderToString(error), ...traces].join(\"\\r\\n\");\n  }\n  return String(error);\n};\n/** @internal */\nconst defaultErrorToLines = error => {\n  if (error instanceof Error) {\n    return renderError(error);\n  }\n  return renderToString(error);\n};\nclass RenderError {\n  constructor(seq, message, stack) {\n    this.seq = seq;\n    this.message = message;\n    this.stack = stack;\n  }\n}\nconst render = (cause, stack) => {\n  switch (cause._tag) {\n    case OpCodes.OP_ANNOTATED:\n      {\n        const annotation = cause.annotation;\n        if (internal.isStackAnnotation(annotation)) {\n          return core.suspendSucceed(() => render(cause.cause, Option.orElse(Option.some(annotation))(Option.map(parent => new StackAnnotation(annotation.stack.length < Debug.runtimeDebug.traceStackLimit && parent.stack.length > 0 && (annotation.stack.length > 0 && Chunk.unsafeLast(parent.stack) !== Chunk.unsafeLast(annotation.stack) || annotation.stack.length === 0) ? Chunk.take(Debug.runtimeDebug.traceStackLimit)(Chunk.dedupeAdjacent(Chunk.concat(parent.stack)(annotation.stack))) : annotation.stack, annotation.seq))(stack))));\n        }\n        return core.suspendSucceed(() => render(cause.cause, stack));\n      }\n    case OpCodes.OP_EMPTY:\n      {\n        return core.succeed([]);\n      }\n    case OpCodes.OP_FAIL:\n      {\n        return core.succeed(renderFail(defaultErrorToLines(cause.error), stack));\n      }\n    case OpCodes.OP_DIE:\n      {\n        return core.succeed(renderFail(defaultErrorToLines(cause.defect), stack));\n      }\n    case OpCodes.OP_INTERRUPT:\n      {\n        return core.succeed([]);\n      }\n    case OpCodes.OP_SEQUENTIAL:\n      {\n        return core.zipWith(core.suspendSucceed(() => render(cause.left, stack)), core.suspendSucceed(() => render(cause.right, stack)), (left, right) => [...left, ...right]);\n      }\n    case OpCodes.OP_PARALLEL:\n      {\n        return core.zipWith(core.suspendSucceed(() => render(cause.left, stack)), core.suspendSucceed(() => render(cause.right, stack)), (left, right) => [...left, ...right]);\n      }\n    default:\n      {\n        return core.succeed([]);\n      }\n  }\n};\n/** @internal */\nexport const prettySafe = cause => {\n  if (internal.isInterruptedOnly(cause)) {\n    return core.succeed(\"All fibers interrupted without errors.\");\n  }\n  return core.map(render(cause, Option.none()), errors => {\n    const final = Array.from(errors).sort((a, b) => a.seq === b.seq ? 0 : a.seq > b.seq ? 1 : -1).map(e => {\n      let message = e.message;\n      if (e.stack && e.stack.length > 0) {\n        message += `\\r\\n${e.stack}`;\n      }\n      return message;\n    }).join(\"\\r\\n\\r\\n\");\n    if (!final.includes(\"\\r\\n\")) {\n      return final;\n    }\n    return `\\r\\n${final}\\r\\n`;\n  });\n};\nfunction renderFrame(r) {\n  if (r) {\n    if (r.name) {\n      return `    at ${r.name} (${r.fileName}:${r.line}:${r.column})`;\n    }\n    return `    at ${r.fileName}:${r.line}:${r.column}`;\n  }\n  return `    at <unknown>`;\n}\n//# sourceMappingURL=cause-pretty.mjs.map","import * as core from \"@effect/io/internal_effect_untraced/core\";\n/**\n * Returns `true` if the specified value is an `Exit`, `false` otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexport const isExit = core.exitIsExit;\n/**\n * Returns `true` if the specified `Exit` is a `Failure`, `false` otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexport const isFailure = core.exitIsFailure;\n/**\n * Returns `true` if the specified `Exit` is a `Success`, `false` otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexport const isSuccess = core.exitIsSuccess;\n/**\n * Returns `true` if the specified exit is a `Failure` **and** the `Cause` of\n * the failure was due to interruption, `false` otherwise.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const isInterrupted = core.exitIsInterrupted;\n/**\n * Maps the `Success` value of the specified exit to the provided constant\n * value.\n *\n * @since 1.0.0\n * @category mapping\n */\nexport const as = core.exitAs;\n/**\n * Maps the `Success` value of the specified exit to a void.\n *\n * @since 1.0.0\n * @category mapping\n */\nexport const asUnit = core.exitAsUnit;\n/**\n * Returns a `Some<Cause<E>>` if the specified exit is a `Failure`, `None`\n * otherwise.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const causeOption = core.exitCauseOption;\n/**\n * Collects all of the specified exit values into a `Some<Exit<E, List<A>>>`. If\n * the provided iterable contains no elements, `None` will be returned.\n *\n * **Note**: `Exit.collectAll` combines `Cause` values sequentially.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const collectAll = core.exitCollectAll;\n/**\n * Collects all of the specified exit values into a `Some<Exit<E, List<A>>>`. If\n * the provided iterable contains no elements, `None` will be returned.\n *\n * **Note**: `Exit.collectAll` combines `Cause` values in parallel.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const collectAllPar = core.exitCollectAllPar;\n/**\n * Constructs a new `Exit.Failure` from the specified unrecoverable defect.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const die = core.exitDie;\n/**\n * Executes the predicate on the value of the specified exit if it is a\n * `Success`, otherwise returns `false`.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const exists = core.exitExists;\n/**\n * Constructs a new `Exit.Failure` from the specified recoverable error of type\n * `E`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const fail = core.exitFail;\n/**\n * Constructs a new `Exit.Failure` from the specified `Cause` of type `E`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const failCause = core.exitFailCause;\n/**\n * @since 1.0.0\n * @category sequencing\n */\nexport const flatMap = core.exitFlatMap;\n/**\n * @since 1.0.0\n * @category sequencing\n */\nexport const flatMapEffect = core.exitFlatMapEffect;\n/**\n * @since 1.0.0\n * @category sequencing\n */\nexport const flatten = core.exitFlatten;\n/**\n * @since 1.0.0\n * @category traversing\n */\nexport const forEachEffect = core.exitForEachEffect;\n/**\n * Converts an `Either<E, A>` into an `Exit<E, A>`.\n *\n * @since 1.0.0\n * @category conversions\n */\nexport const fromEither = core.exitFromEither;\n/**\n * Converts an `Option<A>` into an `Exit<void, A>`.\n *\n * @since 1.0.0\n * @category conversions\n */\nexport const fromOption = core.exitFromOption;\n/**\n * Returns the `A` if specified exit is a `Success`, otherwise returns the\n * alternate `A` value computed from the specified function which receives the\n * `Cause<E>` of the exit `Failure`.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const getOrElse = core.exitGetOrElse;\n/**\n * Constructs a new `Exit.Failure` from the specified `FiberId` indicating that\n * the `Fiber` running an `Effect` workflow was terminated due to interruption.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const interrupt = core.exitInterrupt;\n/**\n * Maps over the `Success` value of the specified exit using the provided\n * function.\n *\n * @since 1.0.0\n * @category mapping\n */\nexport const map = core.exitMap;\n/**\n * Maps over the `Success` and `Failure` cases of the specified exit using the\n * provided functions.\n *\n * @since 1.0.0\n * @category mapping\n */\nexport const mapBoth = core.exitMapBoth;\n/**\n * Maps over the error contained in the `Failure` of the specified exit using\n * the provided function.\n *\n * @since 1.0.0\n * @category mapping\n */\nexport const mapError = core.exitMapError;\n/**\n * Maps over the `Cause` contained in the `Failure` of the specified exit using\n * the provided function.\n *\n * @since 1.0.0\n * @category mapping\n */\nexport const mapErrorCause = core.exitMapErrorCause;\n/**\n * @since 1.0.0\n * @category folding\n */\nexport const match = core.exitMatch;\n/**\n * @since 1.0.0\n * @category folding\n */\nexport const matchEffect = core.exitMatchEffect;\n/**\n * Constructs a new `Exit.Success` containing the specified value of type `A`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const succeed = core.exitSucceed;\n/**\n * Removes any annotation from the failure cause\n *\n * @since 1.0.0\n * @category filtering\n */\nexport const unannotate = core.exitUnannotate;\n/**\n * Represents an `Exit` which succeeds with `undefined`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const unit = core.exitUnit;\n/**\n * Sequentially zips the this result with the specified result or else returns\n * the failed `Cause<E | E2>`.\n *\n * @since 1.0.0\n * @category zipping\n */\nexport const zip = core.exitZip;\n/**\n * Sequentially zips the this result with the specified result discarding the\n * second element of the tuple or else returns the failed `Cause<E | E2>`.\n *\n * @since 1.0.0\n * @category zipping\n */\nexport const zipLeft = core.exitZipLeft;\n/**\n * Sequentially zips the this result with the specified result discarding the\n * first element of the tuple or else returns the failed `Cause<E | E2>`.\n *\n * @since 1.0.0\n * @category zipping\n */\nexport const zipRight = core.exitZipRight;\n/**\n * Parallelly zips the this result with the specified result or else returns\n * the failed `Cause<E | E2>`.\n *\n * @since 1.0.0\n * @category zipping\n */\nexport const zipPar = core.exitZipPar;\n/**\n * Parallelly zips the this result with the specified result discarding the\n * second element of the tuple or else returns the failed `Cause<E | E2>`.\n *\n * @since 1.0.0\n * @category zipping\n */\nexport const zipParLeft = core.exitZipParLeft;\n/**\n * Parallelly zips the this result with the specified result discarding the\n * first element of the tuple or else returns the failed `Cause<E | E2>`.\n *\n * @since 1.0.0\n * @category zipping\n */\nexport const zipParRight = core.exitZipParRight;\n/**\n * Zips this exit together with that exit using the specified combination\n * functions.\n *\n * @since 1.0.0\n * @category zipping\n */\nexport const zipWith = core.exitZipWith;\n//# sourceMappingURL=Exit.mjs.map","import * as Debug from \"@effect/io/Debug\";\n/** @internal */\nexport const OP_SEQUENTIAL = \"Sequential\";\n/** @internal */\nexport const OP_PARALLEL = \"Parallel\";\n/** @internal */\nexport const OP_PARALLEL_N = \"ParallelN\";\n/** @internal */\nexport const sequential = {\n  _tag: OP_SEQUENTIAL\n};\n/** @internal */\nexport const parallel = {\n  _tag: OP_PARALLEL\n};\n/** @internal */\nexport const parallelN = parallelism => {\n  return {\n    _tag: OP_PARALLEL_N,\n    parallelism\n  };\n};\n/** @internal */\nexport const isSequential = self => {\n  return self._tag === OP_SEQUENTIAL;\n};\n/** @internal */\nexport const isParallel = self => {\n  return self._tag === OP_PARALLEL;\n};\n/** @internal */\nexport const isParallelN = self => {\n  return self._tag === OP_PARALLEL_N;\n};\n/** @internal */\nexport const match = /*#__PURE__*/Debug.dual(4, (self, onSequential, onParallel, onParallelN) => {\n  switch (self._tag) {\n    case OP_SEQUENTIAL:\n      {\n        return onSequential();\n      }\n    case OP_PARALLEL:\n      {\n        return onParallel();\n      }\n    case OP_PARALLEL_N:\n      {\n        return onParallelN(self.parallelism);\n      }\n  }\n});\n//# sourceMappingURL=executionStrategy.mjs.map","/**\n * @since 1.0.0\n */\nimport * as internal from \"@effect/io/internal_effect_untraced/executionStrategy\";\n/**\n * Execute effects sequentially.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const sequential = internal.sequential;\n/**\n * Execute effects in parallel.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const parallel = internal.parallel;\n/**\n * Execute effects in parallel, up to the specified number of concurrent fibers.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const parallelN = internal.parallelN;\n/**\n * Returns `true` if the specified `ExecutionStrategy` is an instance of\n * `Sequential`, `false` otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexport const isSequential = internal.isSequential;\n/**\n * Returns `true` if the specified `ExecutionStrategy` is an instance of\n * `Sequential`, `false` otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexport const isParallel = internal.isParallel;\n/**\n * Returns `true` if the specified `ExecutionStrategy` is an instance of\n * `Sequential`, `false` otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexport const isParallelN = internal.isParallelN;\n/**\n * Folds over the specified `ExecutionStrategy` using the provided case\n * functions.\n *\n * @since 1.0.0\n * @category folding\n */\nexport const match = internal.match;\n//# sourceMappingURL=ExecutionStrategy.mjs.map","var _a;\nimport * as Debug from \"@effect/io/Debug\";\nimport * as core from \"@effect/io/internal_effect_untraced/core\";\nimport * as Either from \"@fp-ts/core/Either\";\nimport { constFalse } from \"@fp-ts/core/Function\";\nimport * as Context from \"@fp-ts/data/Context\";\n/** @internal */\nconst ClockSymbolKey = \"@effect/io/Clock\";\n/** @internal */\nexport const ClockTypeId = /*#__PURE__*/Symbol.for(ClockSymbolKey);\n/** @internal */\nexport const clockTag = /*#__PURE__*/Context.Tag();\n/** @internal */\nexport const MAX_TIMER_MILLIS = 2 ** 31 - 1;\n/** @internal */\nexport const globalClockScheduler = {\n  unsafeSchedule(task, duration) {\n    // If the duration is greater than the value allowable by the JS timer\n    // functions, treat the value as an infinite duration\n    if (duration.millis > MAX_TIMER_MILLIS) {\n      return constFalse;\n    }\n    let completed = false;\n    const handle = setTimeout(() => {\n      completed = true;\n      task();\n    }, duration.millis);\n    return () => {\n      clearTimeout(handle);\n      return !completed;\n    };\n  }\n};\n/** @internal */\nclass ClockImpl {\n  constructor() {\n    this[_a] = ClockTypeId;\n  }\n  unsafeCurrentTimeMillis() {\n    return new Date().getTime();\n  }\n  currentTimeMillis() {\n    return Debug.bodyWithTrace(trace => core.sync(() => this.unsafeCurrentTimeMillis()).traced(trace));\n  }\n  scheduler() {\n    return Debug.bodyWithTrace(trace => core.succeed(globalClockScheduler).traced(trace));\n  }\n  sleep(duration) {\n    return Debug.bodyWithTrace(trace => core.asyncInterruptEither(cb => {\n      const canceler = globalClockScheduler.unsafeSchedule(() => cb(core.unit()), duration);\n      return Either.left(core.asUnit(core.sync(canceler)));\n    }).traced(trace));\n  }\n}\n_a = ClockTypeId;\n/** @internal */\nexport const make = () => new ClockImpl();\n//# sourceMappingURL=clock.mjs.map","/**\n * @since 1.0.0\n */\nvar _a, _b;\n/**\n * This file is ported from\n *\n * Scala (https://www.scala-lang.org)\n *\n * Copyright EPFL and Lightbend, Inc.\n *\n * Licensed under Apache License 2.0\n * (http://www.apache.org/licenses/LICENSE-2.0).\n */\nimport * as Either from \"@fp-ts/core/Either\";\nimport { identity, unsafeCoerce } from \"@fp-ts/core/Function\";\nimport * as Option from \"@fp-ts/core/Option\";\nimport * as Chunk from \"@fp-ts/data/Chunk\";\nimport * as Dual from \"@fp-ts/data/Dual\";\nimport * as Equal from \"@fp-ts/data/Equal\";\nimport * as Hash from \"@fp-ts/data/Hash\";\nconst ListSymbolKey = \"@fp-ts/data/List\";\n/**\n * @since 1.0.0\n * @category symbol\n */\nexport const ListTypeId = /*#__PURE__*/Symbol.for(ListSymbolKey);\nconst listVariance = {\n  _A: _ => _\n};\nclass ConsImpl {\n  constructor(head, tail) {\n    this.head = head;\n    this.tail = tail;\n    this._tag = \"Cons\";\n    this[_a] = listVariance;\n  }\n  toString() {\n    return `List.Cons(${toReadonlyArray(this).map(String).join(\", \")})`;\n  }\n  toJSON() {\n    return {\n      _tag: \"List.Cons\",\n      values: toReadonlyArray(this)\n    };\n  }\n  [(_a = ListTypeId, Symbol.for(\"nodejs.util.inspect.custom\"))]() {\n    return this.toJSON();\n  }\n  [Equal.symbol](that) {\n    return isList(that) && this._tag === that._tag && equalsWith(this, that, Equal.equals);\n  }\n  [Hash.symbol]() {\n    return Hash.string(ListSymbolKey);\n  }\n  [Symbol.iterator]() {\n    let done = false;\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let self = this;\n    return {\n      next() {\n        if (done) {\n          return this.return();\n        }\n        if (self._tag === \"Nil\") {\n          done = true;\n          return this.return();\n        }\n        const value = self.head;\n        self = self.tail;\n        return {\n          done,\n          value\n        };\n      },\n      return(value) {\n        if (!done) {\n          done = true;\n        }\n        return {\n          done: true,\n          value\n        };\n      }\n    };\n  }\n}\nclass NilImpl {\n  constructor() {\n    this._tag = \"Nil\";\n    this[_b] = listVariance;\n  }\n  toString() {\n    return `List.Nil`;\n  }\n  toJSON() {\n    return {\n      _tag: \"List.Nil\"\n    };\n  }\n  [(_b = ListTypeId, Symbol.for(\"nodejs.util.inspect.custom\"))]() {\n    return this.toJSON();\n  }\n  [Hash.symbol]() {\n    return Hash.array(Array.from(this));\n  }\n  [Equal.symbol](that) {\n    return isList(that) && this._tag === that._tag;\n  }\n  [Symbol.iterator]() {\n    return {\n      next() {\n        return {\n          done: true,\n          value: undefined\n        };\n      }\n    };\n  }\n}\n/**\n * Returns `true` if the specified value is a `List`, `false` otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexport const isList = u => typeof u === \"object\" && u != null && ListTypeId in u;\n/**\n * Returns `true` if the specified value is a `List.Nil<A>`, `false` otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexport const isNil = self => self._tag === \"Nil\";\n/**\n * Returns `true` if the specified value is a `List.Cons<A>`, `false` otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexport const isCons = self => self._tag === \"Cons\";\n/**\n * Returns the number of elements contained in the specified `List`\n *\n * @since 1.0.0\n * @category getters\n */\nexport const length = self => {\n  let these = self;\n  let len = 0;\n  while (!isNil(these)) {\n    len += 1;\n    these = these.tail;\n  }\n  return len;\n};\n/**\n * Returns `true` if the two lists are equal according to the provided function,\n * `false` otherwise.\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const equalsWith = /*#__PURE__*/Dual.dual(3, (self, that, f) => {\n  if (self === that) {\n    return true;\n  }\n  if (length(self) !== length(that)) {\n    return false;\n  }\n  const selfIterator = self[Symbol.iterator]();\n  const thatIterator = that[Symbol.iterator]();\n  let nextSelf;\n  let nextThat;\n  while (!(nextSelf = selfIterator.next()).done && !(nextThat = thatIterator.next()).done) {\n    if (!f(nextSelf.value, nextThat.value)) {\n      return false;\n    }\n  }\n  return true;\n});\nconst _Nil = /*#__PURE__*/new NilImpl();\n/**\n * Constructs a new `List.Nil<A>`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const nil = () => _Nil;\n/**\n * Constructs a new `List.Cons<A>` from the specified `head` and `tail` values.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const cons = (head, tail) => new ConsImpl(head, tail);\n/**\n * Constructs a new empty `List<A>`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const empty = () => _Nil;\n/**\n * Constructs a new `List<A>` from the specified value.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const of = value => new ConsImpl(value, _Nil);\n/**\n * Constructs a new `List<A>` from the specified `Iterable<A>`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const fromIterable = prefix => {\n  const iterator = prefix[Symbol.iterator]();\n  let next;\n  if ((next = iterator.next()) && !next.done) {\n    const result = new ConsImpl(next.value, _Nil);\n    let curr = result;\n    while ((next = iterator.next()) && !next.done) {\n      const temp = new ConsImpl(next.value, _Nil);\n      curr.tail = temp;\n      curr = temp;\n    }\n    return result;\n  } else {\n    return _Nil;\n  }\n};\n/**\n * Constructs a new `List<A>` from the specified values.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const make = (...elements) => fromIterable(elements);\n/**\n * Removes all `None` values from the specified list.\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const compact = self => filterMap(self, identity);\n/**\n * Concatentates the specified lists together.\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const concat = /*#__PURE__*/Dual.dual(2, (self, that) => prependAll(that, self));\n/**\n * Drops the first `n` elements from the specified list.\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const drop = /*#__PURE__*/Dual.dual(2, (self, n) => {\n  if (n <= 0) {\n    return self;\n  }\n  if (n >= length(self)) {\n    return _Nil;\n  }\n  let these = self;\n  let i = 0;\n  while (!isNil(these) && i < n) {\n    these = these.tail;\n    i += 1;\n  }\n  return these;\n});\n/**\n * Returns `true` if all elements of the specified list satisfy the specified\n * predicate, `false` otherwise.\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const every = /*#__PURE__*/Dual.dual(2, (self, predicate) => {\n  for (const a of self) {\n    if (!predicate(a)) {\n      return false;\n    }\n  }\n  return true;\n});\n/**\n * Filters a list using the specified predicate.\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const filter = /*#__PURE__*/Dual.dual(2, (self, predicate) => noneIn(self, predicate, false));\n/**\n * Filters and maps a list using the specified partial function. The resulting\n * list may be smaller than the input list due to the possibility of the partial\n * function not being defined for some elements.\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const filterMap = /*#__PURE__*/Dual.dual(2, (self, pf) => {\n  const bs = [];\n  for (const a of self) {\n    const oa = pf(a);\n    if (Option.isSome(oa)) {\n      bs.push(oa.value);\n    }\n  }\n  return fromIterable(bs);\n});\n/**\n * Returns the first element of the specified list that satisfies the specified\n * predicate, or `None` if no such element exists.\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const findFirst = /*#__PURE__*/Dual.dual(2, (self, predicate) => {\n  let these = self;\n  while (!isNil(these)) {\n    if (predicate(these.head)) {\n      return Option.some(these.head);\n    }\n    these = these.tail;\n  }\n  return Option.none();\n});\n/**\n * Flat maps a list using the specified function.\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const flatMap = /*#__PURE__*/Dual.dual(2, (self, f) => {\n  let rest = self;\n  let head = undefined;\n  let tail = undefined;\n  while (!isNil(rest)) {\n    let bs = f(rest.head);\n    while (!isNil(bs)) {\n      const next = new ConsImpl(bs.head, _Nil);\n      if (tail === undefined) {\n        head = next;\n      } else {\n        tail.tail = next;\n      }\n      tail = next;\n      bs = bs.tail;\n    }\n    rest = rest.tail;\n  }\n  if (head === undefined) {\n    return _Nil;\n  }\n  return head;\n});\n/**\n * Applies the specified function to each element of the list.\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const forEach = /*#__PURE__*/Dual.dual(2, (self, f) => {\n  let these = self;\n  while (!isNil(these)) {\n    f(these.head);\n    these = these.tail;\n  }\n});\n/**\n * Returns the first element of the specified list, or `None` if the list is\n * empty.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const head = self => isNil(self) ? Option.none() : Option.some(self.head);\n/**\n * Returns the last element of the specified list, or `None` if the list is\n * empty.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const last = self => isNil(self) ? Option.none() : Option.some(unsafeLast(self));\n/**\n * Applies the specified mapping function to each element of the list.\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const map = /*#__PURE__*/Dual.dual(2, (self, f) => {\n  if (isNil(self)) {\n    return self;\n  } else {\n    const head = new ConsImpl(f(self.head), _Nil);\n    let nextHead = head;\n    let rest = self.tail;\n    while (!isNil(rest)) {\n      const next = new ConsImpl(f(rest.head), _Nil);\n      nextHead.tail = next;\n      nextHead = next;\n      rest = rest.tail;\n    }\n    return head;\n  }\n});\n/**\n * Partition a list into two lists, where the first list contains all elements\n * that did not satisfy the specified predicate, and the second list contains\n * all elements that did satisfy the specified predicate.\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const partition = /*#__PURE__*/Dual.dual(2, (self, predicate) => {\n  const left = [];\n  const right = [];\n  for (const a of self) {\n    if (predicate(a)) {\n      right.push(a);\n    } else {\n      left.push(a);\n    }\n  }\n  return [fromIterable(left), fromIterable(right)];\n});\n/**\n * Partition a list into two lists, where the first list contains all elements\n * for which the specified function returned a `Left`, and the second list\n * contains all elements for which the specified function returned a `Right`.\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const partitionMap = /*#__PURE__*/Dual.dual(2, (self, f) => {\n  const left = [];\n  const right = [];\n  for (const a of self) {\n    const e = f(a);\n    if (Either.isLeft(e)) {\n      left.push(e.left);\n    } else {\n      right.push(e.right);\n    }\n  }\n  return [fromIterable(left), fromIterable(right)];\n});\n/**\n * Prepends the specified element to the beginning of the list.\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const prepend = /*#__PURE__*/Dual.dual(2, (self, element) => cons(element, self));\n/**\n * Prepends the specified prefix list to the beginning of the specified list.\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const prependAll = /*#__PURE__*/Dual.dual(2, (self, prefix) => {\n  if (isNil(self)) {\n    return prefix;\n  } else if (isNil(prefix)) {\n    return self;\n  } else {\n    const result = new ConsImpl(prefix.head, self);\n    let curr = result;\n    let that = prefix.tail;\n    while (!isNil(that)) {\n      const temp = new ConsImpl(that.head, self);\n      curr.tail = temp;\n      curr = temp;\n      that = that.tail;\n    }\n    return result;\n  }\n});\n/**\n * Prepends the specified prefix list (in reverse order) to the beginning of the\n * specified list.\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const prependAllReversed = /*#__PURE__*/Dual.dual(2, (self, prefix) => {\n  let these = self;\n  let pres = prefix;\n  while (isCons(pres)) {\n    these = new ConsImpl(pres.head, these);\n    pres = pres.tail;\n  }\n  return these;\n});\n/**\n * Folds over the elements of the list using the specified function, using the\n * specified initial value.\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const reduce = /*#__PURE__*/Dual.dual(3, (self, zero, f) => {\n  let acc = zero;\n  let these = self;\n  while (!isNil(these)) {\n    acc = f(acc, these.head);\n    these = these.tail;\n  }\n  return acc;\n});\n/**\n * Folds over the elements of the list using the specified function, beginning\n * with the last element of the list, using the specified initial value.\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const reduceRight = /*#__PURE__*/Dual.dual(3, (self, zero, f) => {\n  let acc = zero;\n  let these = reverse(self);\n  while (!isNil(these)) {\n    acc = f(acc, these.head);\n    these = these.tail;\n  }\n  return acc;\n});\n/**\n * Returns a new list with the elements of the specified list in reverse order.\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const reverse = self => {\n  let result = empty();\n  let these = self;\n  while (!isNil(these)) {\n    result = prepend(result, these.head);\n    these = these.tail;\n  }\n  return result;\n};\n/**\n * Returns `true` if any element of the specified list satisfies the specified\n * predicate, `false` otherwise.\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const some = /*#__PURE__*/Dual.dual(2, (self, predicate) => {\n  let these = self;\n  while (!isNil(these)) {\n    if (predicate(these.head)) {\n      return true;\n    }\n    these = these.tail;\n  }\n  return false;\n});\n/**\n * Splits the specified list into two lists at the specified index.\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const splitAt = /*#__PURE__*/Dual.dual(2, (self, n) => [take(self, n), drop(self, n)]);\n/**\n * Returns the tail of the specified list, or `None` if the list is empty.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const tail = self => isNil(self) ? Option.none() : Option.some(self.tail);\n/**\n * Takes the specified number of elements from the beginning of the specified\n * list.\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const take = /*#__PURE__*/Dual.dual(2, (self, n) => {\n  if (n <= 0) {\n    return _Nil;\n  }\n  if (n >= length(self)) {\n    return self;\n  }\n  let these = make(unsafeHead(self));\n  let current = unsafeTail(self);\n  for (let i = 1; i < n; i++) {\n    these = new ConsImpl(unsafeHead(current), these);\n    current = unsafeTail(current);\n  }\n  return reverse(these);\n});\n/**\n * Converts the specified list to a `Chunk`.\n *\n * @since 1.0.0\n * @category conversions\n */\nexport const toChunk = self => Chunk.fromIterable(self);\n/**\n * Converts the specified list to a `ReadonlyArray`.\n *\n * @since 1.0.0\n * @category conversions\n */\nexport const toReadonlyArray = self => Array.from(self);\n/**\n * Unsafely returns the first element of the specified `List`.\n *\n * @since 1.0.0\n * @category unsafe\n */\nexport const unsafeHead = self => {\n  if (isNil(self)) {\n    throw new Error(\"Error: Expected List to be non-empty\");\n  }\n  return self.head;\n};\n/**\n * Unsafely returns the last element of the specified `List`.\n *\n * @since 1.0.0\n * @category unsafe\n */\nexport const unsafeLast = self => {\n  if (isNil(self)) {\n    throw new Error(\"Error: Expected List to be non-empty\");\n  }\n  let these = self;\n  let scout = self.tail;\n  while (!isNil(scout)) {\n    these = scout;\n    scout = scout.tail;\n  }\n  return these.head;\n};\n/**\n * Unsafely returns the tail of the specified `List`.\n *\n * @since 1.0.0\n * @category unsafe\n */\nexport const unsafeTail = self => {\n  if (isNil(self)) {\n    throw new Error(\"Error: Expected List to be non-empty\");\n  }\n  return self.tail;\n};\nconst noneIn = (self, predicate, isFlipped) => {\n  /* eslint-disable no-constant-condition */\n  while (true) {\n    if (isNil(self)) {\n      return _Nil;\n    } else {\n      if (predicate(self.head) !== isFlipped) {\n        return allIn(self, self.tail, predicate, isFlipped);\n      } else {\n        self = self.tail;\n      }\n    }\n  }\n};\nconst allIn = (self, remaining, predicate, isFlipped) => {\n  /* eslint-disable no-constant-condition */\n  while (true) {\n    if (isNil(remaining)) {\n      return self;\n    } else {\n      if (predicate(remaining.head) !== isFlipped) {\n        remaining = remaining.tail;\n      } else {\n        return partialFill(self, remaining, predicate, isFlipped);\n      }\n    }\n  }\n};\nconst partialFill = (self, firstMiss, predicate, isFlipped) => {\n  const newHead = new ConsImpl(unsafeHead(self), _Nil);\n  let toProcess = unsafeTail(self);\n  let currentLast = newHead;\n  while (!(toProcess === firstMiss)) {\n    const newElem = new ConsImpl(unsafeHead(toProcess), _Nil);\n    currentLast.tail = newElem;\n    currentLast = unsafeCoerce(newElem);\n    toProcess = unsafeCoerce(toProcess.tail);\n  }\n  let next = firstMiss.tail;\n  let nextToCopy = unsafeCoerce(next);\n  while (!isNil(next)) {\n    const head = unsafeHead(next);\n    if (predicate(head) !== isFlipped) {\n      next = next.tail;\n    } else {\n      while (!(nextToCopy === next)) {\n        const newElem = new ConsImpl(unsafeHead(nextToCopy), _Nil);\n        currentLast.tail = newElem;\n        currentLast = newElem;\n        nextToCopy = unsafeCoerce(nextToCopy.tail);\n      }\n      nextToCopy = unsafeCoerce(next.tail);\n      next = next.tail;\n    }\n  }\n  if (!isNil(nextToCopy)) {\n    currentLast.tail = nextToCopy;\n  }\n  return newHead;\n};\n//# sourceMappingURL=List.mjs.map","import * as Debug from \"@effect/io/Debug\";\nimport * as configError from \"@effect/io/internal_effect_untraced/configError\";\nimport * as Either from \"@fp-ts/core/Either\";\nimport * as Option from \"@fp-ts/core/Option\";\nimport * as String from \"@fp-ts/core/String\";\nimport * as Chunk from \"@fp-ts/data/Chunk\";\nimport * as List from \"@fp-ts/data/List\";\n/** @internal */\nexport const empty = {\n  _tag: \"Empty\"\n};\n/** @internal */\nexport const andThen = /*#__PURE__*/Debug.dual(2, (self, that) => ({\n  _tag: \"AndThen\",\n  first: self,\n  second: that\n}));\n/** @internal */\nexport const mapName = /*#__PURE__*/Debug.dual(2, (self, f) => andThen(self, {\n  _tag: \"MapName\",\n  f\n}));\n/** @internal */\nexport const nested = /*#__PURE__*/Debug.dual(2, (self, name) => andThen(self, {\n  _tag: \"Nested\",\n  name\n}));\n/** @internal */\nexport const unnested = /*#__PURE__*/Debug.dual(2, (self, name) => andThen(self, {\n  _tag: \"Unnested\",\n  name\n}));\n/** @internal */\nexport const patch = /*#__PURE__*/Debug.dual(2, (path, patch) => {\n  let input = List.of(patch);\n  let output = path;\n  while (List.isCons(input)) {\n    const patch = input.head;\n    switch (patch._tag) {\n      case \"Empty\":\n        {\n          input = input.tail;\n          break;\n        }\n      case \"AndThen\":\n        {\n          input = List.cons(patch.first, List.cons(patch.second, input.tail));\n          break;\n        }\n      case \"MapName\":\n        {\n          output = Chunk.map(output, patch.f);\n          input = input.tail;\n          break;\n        }\n      case \"Nested\":\n        {\n          output = Chunk.prepend(output, patch.name);\n          input = input.tail;\n          break;\n        }\n      case \"Unnested\":\n        {\n          const containsName = Option.contains(String.Equivalence)(patch.name)(Chunk.head(output));\n          if (containsName) {\n            output = Chunk.tailNonEmpty(output);\n            input = input.tail;\n          } else {\n            return Either.left(configError.MissingData(output, `Expected ${patch.name} to be in path in ConfigProvider#unnested`));\n          }\n          break;\n        }\n    }\n  }\n  return Either.right(output);\n});\n//# sourceMappingURL=pathPatch.mjs.map","/**\n * Adapted from the `change-case` library.\n *\n * Copyright (c) 2014 Blake Embrey (hello@blakeembrey.com)\n */\n/** @internal */\nexport const lowerCase = str => str.toLowerCase();\n/** @internal */\nexport const upperCase = str => str.toUpperCase();\n/**\n * Replace `re` in the input string with the replacement value.\n */\nconst replace = (input, re, value) => re instanceof RegExp ? input.replace(re, value) : re.reduce((input, re) => input.replace(re, value), input);\n// Support camel case (\"camelCase\" -> \"camel Case\" and \"CAMELCase\" -> \"CAMEL Case\").\nconst DEFAULT_SPLIT_REGEXP = [/([a-z0-9])([A-Z])/g, /([A-Z])([A-Z][a-z])/g];\n// Remove all non-word characters.\nconst DEFAULT_STRIP_REGEXP = /[^A-Z0-9]+/gi;\n/**\n * Normalize the string into something other libraries can manipulate easier.\n */\nconst noCase = (input, options = {}) => {\n  const {\n    splitRegexp = DEFAULT_SPLIT_REGEXP,\n    stripRegexp = DEFAULT_STRIP_REGEXP,\n    transform = lowerCase,\n    delimiter = \" \"\n  } = options;\n  const result = replace(replace(input, splitRegexp, \"$1\\0$2\"), stripRegexp, \"\\0\");\n  let start = 0;\n  let end = result.length;\n  // Trim the delimiter from around the output string.\n  while (result.charAt(start) === \"\\0\") {\n    start++;\n  }\n  while (result.charAt(end - 1) === \"\\0\") {\n    end--;\n  }\n  // Transform each token independently.\n  return result.slice(start, end).split(\"\\0\").map(transform).join(delimiter);\n};\nconst pascalCaseTransform = (input, index) => {\n  const firstChar = input.charAt(0);\n  const lowerChars = input.substring(1).toLowerCase();\n  if (index > 0 && firstChar >= \"0\" && firstChar <= \"9\") {\n    return `_${firstChar}${lowerChars}`;\n  }\n  return `${firstChar.toUpperCase()}${lowerChars}`;\n};\n/** @internal */\nexport const pascalCase = (input, options = {}) => noCase(input, {\n  delimiter: \"\",\n  transform: pascalCaseTransform,\n  ...options\n});\nconst camelCaseTransform = (input, index) => index === 0 ? input.toLowerCase() : pascalCaseTransform(input, index);\n/** @internal */\nexport const camelCase = (input, options = {}) => pascalCase(input, {\n  transform: camelCaseTransform,\n  ...options\n});\n/** @internal */\nexport const constantCase = (input, options = {}) => noCase(input, {\n  delimiter: \"_\",\n  transform: upperCase,\n  ...options\n});\n/** @internal */\nexport const kebabCase = (input, options = {}) => noCase(input, {\n  delimiter: \"-\",\n  ...options\n});\n/** @internal */\nexport const snakeCase = (input, options = {}) => noCase(input, {\n  delimiter: \"_\",\n  ...options\n});\n//# sourceMappingURL=string-utils.mjs.map","import * as Debug from \"@effect/io/Debug\";\nimport * as _config from \"@effect/io/internal_effect_untraced/config\";\nimport * as configError from \"@effect/io/internal_effect_untraced/configError\";\nimport * as pathPatch from \"@effect/io/internal_effect_untraced/configProvider/pathPatch\";\nimport * as core from \"@effect/io/internal_effect_untraced/core\";\nimport * as OpCodes from \"@effect/io/internal_effect_untraced/opCodes/config\";\nimport * as StringUtils from \"@effect/io/internal_effect_untraced/string-utils\";\nimport * as Either from \"@fp-ts/core/Either\";\nimport * as Option from \"@fp-ts/core/Option\";\nimport * as Chunk from \"@fp-ts/data/Chunk\";\nimport * as Context from \"@fp-ts/data/Context\";\nimport * as HashMap from \"@fp-ts/data/HashMap\";\nimport * as HashSet from \"@fp-ts/data/HashSet\";\n/** @internal */\nexport const configProviderTag = /*#__PURE__*/Context.Tag();\n/** @internal */\nconst ConfigProviderSymbolKey = \"@effect/io/Config/Provider\";\n/** @internal */\nexport const ConfigProviderTypeId = /*#__PURE__*/Symbol.for(ConfigProviderSymbolKey);\n/** @internal */\nconst FlatConfigProviderSymbolKey = \"@effect/io/Config/Provider/Flat\";\n/** @internal */\nexport const FlatConfigProviderTypeId = /*#__PURE__*/Symbol.for(FlatConfigProviderSymbolKey);\n/** @internal */\nexport const make = /*#__PURE__*/Debug.untracedMethod(restore => (load, flattened) => ({\n  [ConfigProviderTypeId]: ConfigProviderTypeId,\n  load: Debug.methodWithTrace(trace => config => restore(load)(config).traced(trace)),\n  flattened\n}));\n/** @internal */\nexport const makeFlat = /*#__PURE__*/Debug.untracedMethod(restore => (load, enumerateChildren, patch) => ({\n  [FlatConfigProviderTypeId]: FlatConfigProviderTypeId,\n  patch,\n  load: Debug.methodWithTrace(trace => (path, config, split = true) => restore(load)(path, config, split).traced(trace)),\n  enumerateChildren: Debug.methodWithTrace(trace => path => restore(enumerateChildren)(path).traced(trace))\n}));\n/** @internal */\nexport const fromFlat = /*#__PURE__*/Debug.untracedMethod(() => flat => make(config => core.flatMap(fromFlatLoop(flat, Chunk.empty(), config, false), chunk => Option.match(() => core.fail(configError.MissingData(Chunk.empty(), `Expected a single value having structure: ${config}`)), core.succeed)(Chunk.head(chunk))), flat));\n/** @internal */\nexport const fromEnv = /*#__PURE__*/Debug.untracedMethod(() => (config = {}) => {\n  const {\n    pathDelim,\n    seqDelim\n  } = Object.assign({}, {\n    pathDelim: \"_\",\n    seqDelim: \",\"\n  }, config);\n  const makePathString = path => Chunk.join(pathDelim)(path);\n  const unmakePathString = pathString => pathString.split(pathDelim);\n  const getEnv = () => typeof process !== \"undefined\" && \"env\" in process && typeof process.env === \"object\" ? process.env : {};\n  const load = (path, primitive, split = true) => {\n    const pathString = makePathString(path);\n    const current = getEnv();\n    const valueOpt = pathString in current ? Option.some(current[pathString]) : Option.none();\n    return core.flatMap(value => parsePrimitive(value, path, primitive, seqDelim, split))(core.mapError(() => configError.MissingData(path, `Expected ${pathString} to exist in the process context`))(core.fromOption(valueOpt)));\n  };\n  const enumerateChildren = path => core.sync(() => {\n    const current = getEnv();\n    const keys = Object.keys(current);\n    const keyPaths = Array.from(keys).map(value => unmakePathString(value.toUpperCase()));\n    const filteredKeyPaths = keyPaths.filter(keyPath => {\n      for (let i = 0; i < path.length; i++) {\n        const pathComponent = Chunk.unsafeGet(i)(path);\n        const currentElement = keyPath[i];\n        if (currentElement === undefined || pathComponent !== currentElement) {\n          return false;\n        }\n      }\n      return true;\n    }).flatMap(keyPath => keyPath.slice(path.length, path.length + 1));\n    return HashSet.fromIterable(filteredKeyPaths);\n  });\n  return fromFlat(makeFlat(load, enumerateChildren, pathPatch.empty));\n});\n/** @internal */\nexport const fromMap = /*#__PURE__*/Debug.untracedMethod(() => (map, config = {}) => {\n  const {\n    pathDelim,\n    seqDelim\n  } = Object.assign({}, {\n    seqDelim: \",\",\n    pathDelim: \".\"\n  }, config);\n  const makePathString = path => Chunk.join(pathDelim)(path);\n  const unmakePathString = pathString => pathString.split(pathDelim);\n  const load = (path, primitive, split = true) => {\n    const pathString = makePathString(path);\n    const valueOpt = map.has(pathString) ? Option.some(map.get(pathString)) : Option.none();\n    return core.flatMap(value => parsePrimitive(value, path, primitive, seqDelim, split))(core.mapError(() => configError.MissingData(path, `Expected ${pathString} to exist in the provided map`))(core.fromOption(valueOpt)));\n  };\n  const enumerateChildren = path => core.sync(() => {\n    const keyPaths = Array.from(map.keys()).map(unmakePathString);\n    const filteredKeyPaths = keyPaths.filter(keyPath => {\n      for (let i = 0; i < path.length; i++) {\n        const pathComponent = Chunk.unsafeGet(i)(path);\n        const currentElement = keyPath[i];\n        if (currentElement === undefined || pathComponent !== currentElement) {\n          return false;\n        }\n      }\n      return true;\n    }).flatMap(keyPath => keyPath.slice(path.length, path.length + 1));\n    return HashSet.fromIterable(filteredKeyPaths);\n  });\n  return fromFlat(makeFlat(load, enumerateChildren, pathPatch.empty));\n});\nconst extend = (leftDef, rightDef, left, right) => {\n  const leftPad = Chunk.unfold(left.length, index => index >= right.length ? Option.none() : Option.some([leftDef(index), index + 1]));\n  const rightPad = Chunk.unfold(right.length, index => index >= left.length ? Option.none() : Option.some([rightDef(index), index + 1]));\n  const leftExtension = Chunk.concat(leftPad)(left);\n  const rightExtension = Chunk.concat(rightPad)(right);\n  return [leftExtension, rightExtension];\n};\nconst fromFlatLoop = (flat, prefix, config, split) => {\n  const op = config;\n  switch (op._tag) {\n    case OpCodes.OP_CONSTANT:\n      {\n        return core.succeed(Chunk.of(op.value));\n      }\n    case OpCodes.OP_DESCRIBED:\n      {\n        return core.suspendSucceed(() => fromFlatLoop(flat, prefix, op.config, split));\n      }\n    case OpCodes.OP_FAIL:\n      {\n        return core.fail(configError.MissingData(prefix, op.message));\n      }\n    case OpCodes.OP_FALLBACK:\n      {\n        return core.catchAll(error1 => {\n          if (op.condition(error1)) {\n            return core.catchAll(error2 => core.fail(configError.Or(error1, error2)))(fromFlatLoop(flat, prefix, op.second, split));\n          }\n          return core.fail(error1);\n        })(core.suspendSucceed(() => fromFlatLoop(flat, prefix, op.first, split)));\n      }\n    case OpCodes.OP_LAZY:\n      {\n        return core.suspendSucceed(() => fromFlatLoop(flat, prefix, op.config(), split));\n      }\n    case OpCodes.OP_MAP_OR_FAIL:\n      {\n        return core.suspendSucceed(() => core.flatMap(core.forEach(a => core.mapError(configError.prefixed(prefix))(core.fromEither(op.mapOrFail(a)))))(fromFlatLoop(flat, prefix, op.original, split)));\n      }\n    case OpCodes.OP_NESTED:\n      {\n        return core.suspendSucceed(() => fromFlatLoop(flat, Chunk.concat(Chunk.of(op.name))(prefix), op.config, split));\n      }\n    case OpCodes.OP_PRIMITIVE:\n      {\n        return core.flatMap(prefix => core.flatMap(values => {\n          if (Chunk.isEmpty(values)) {\n            const name = Option.getOrElse(() => \"<n/a>\")(Chunk.last(prefix));\n            return core.fail(_config.missingError(name));\n          }\n          return core.succeed(values);\n        })(flat.load(prefix, op, split)))(core.fromEither(pathPatch.patch(prefix, flat.patch)));\n      }\n    case OpCodes.OP_SEQUENCE:\n      {\n        return core.suspendSucceed(() => core.map(Chunk.of)(fromFlatLoop(flat, prefix, op.config, true)));\n      }\n    case OpCodes.OP_TABLE:\n      {\n        return core.suspendSucceed(() => core.flatMap(prefix => core.flatMap(keys => {\n          return core.map(values => {\n            if (values.length === 0) {\n              return Chunk.of(HashMap.empty());\n            }\n            const matrix = Chunk.toReadonlyArray(values).map(Chunk.toReadonlyArray);\n            return Chunk.map(values => HashMap.fromIterable(Chunk.zip(Chunk.fromIterable(keys), values)))(Chunk.unsafeFromArray(transpose(matrix).map(Chunk.unsafeFromArray)));\n          })(core.forEach(key => fromFlatLoop(flat, Chunk.concat(Chunk.of(key))(prefix), op.valueConfig, split))(keys));\n        })(flat.enumerateChildren(prefix)))(core.fromEither(pathPatch.patch(prefix, flat.patch))));\n      }\n    case OpCodes.OP_ZIP_WITH:\n      {\n        return core.suspendSucceed(() => core.flatMap(left => core.flatMap(right => {\n          if (Either.isLeft(left) && Either.isLeft(right)) {\n            return core.fail(configError.And(left.left, right.left));\n          }\n          if (Either.isLeft(left) && Either.isRight(right)) {\n            return core.fail(left.left);\n          }\n          if (Either.isRight(left) && Either.isLeft(right)) {\n            return core.fail(right.left);\n          }\n          if (Either.isRight(left) && Either.isRight(right)) {\n            const path = Chunk.join(\".\")(prefix);\n            const fail = fromFlatLoopFail(prefix, path);\n            const [lefts, rights] = extend(fail, fail, Chunk.map(Either.right)(left.right), Chunk.map(Either.right)(right.right));\n            return core.forEach(([left, right]) => core.map(([left, right]) => op.zip(left, right))(core.zip(core.fromEither(right))(core.fromEither(left))))(Chunk.zip(rights)(lefts));\n          }\n          throw new Error(\"BUG: ConfigProvider.fromFlatLoop - please report an issue at https://github.com/Effect-TS/io/issues\");\n        })(core.either(fromFlatLoop(flat, prefix, op.right, split))))(core.either(fromFlatLoop(flat, prefix, op.left, split))));\n      }\n  }\n};\nconst fromFlatLoopFail = (prefix, path) => index => Either.left(configError.MissingData(prefix, `The element at index ${index} in a sequence at path \"${path}\" was missing`));\n/** @internal */\nexport const contramapPath = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => fromFlat(contramapPathFlat(self.flattened, restore(f))));\nconst contramapPathFlat = (self, f) => makeFlat((path, config, split = true) => self.load(path, config, split), path => self.enumerateChildren(path), pathPatch.mapName(self.patch, f));\n/** @internal */\nexport const nested = /*#__PURE__*/Debug.untracedDual(2, () => (self, name) => fromFlat(makeFlat((path, config) => self.flattened.load(path, config, true), path => self.flattened.enumerateChildren(Chunk.prepend(name)(path)), pathPatch.nested(self.flattened.patch, name))));\n/** @internal */\nexport const unnested = /*#__PURE__*/Debug.untracedDual(2, () => (self, name) => fromFlat(makeFlat((path, config) => self.flattened.load(path, config, true), path => self.flattened.enumerateChildren(path), pathPatch.unnested(self.flattened.patch, name))));\n/** @internal */\nexport const orElse = /*#__PURE__*/Debug.untracedDual(2, restore => (self, that) => fromFlat(orElseFlat(self.flattened, () => restore(that)().flattened)));\nconst orElseFlat = (self, that) => makeFlat((path, config, split) => core.catchAll(error1 => core.flatMap(that => core.catchAll(error2 => core.fail(configError.Or(error1, error2)))(core.flatMap(patch => that.load(patch, config, split))(core.fromEither(pathPatch.patch(path, that.patch)))))(core.sync(that)))(core.flatMap(patch => self.load(patch, config, split))(core.fromEither(pathPatch.patch(path, self.patch)))), path => core.flatMap(left => core.flatMap(that => core.flatMap(right => {\n  if (Either.isLeft(left) && Either.isLeft(right)) {\n    return core.fail(configError.And(left.left, right.left));\n  }\n  if (Either.isLeft(left) && Either.isRight(right)) {\n    return core.fail(left.left);\n  }\n  if (Either.isRight(left) && Either.isLeft(right)) {\n    return core.fail(right.left);\n  }\n  if (Either.isRight(left) && Either.isRight(right)) {\n    return core.succeed(HashSet.union(right.right)(left.right));\n  }\n  throw new Error(\"BUG: ConfigProvider.orElseFlat - please report an issue at https://github.com/Effect-TS/io/issues\");\n})(core.either(core.flatMap(patch => that.enumerateChildren(patch))(core.fromEither(pathPatch.patch(path, that.patch))))))(core.sync(that)))(core.either(core.flatMap(patch => self.enumerateChildren(patch))(core.fromEither(pathPatch.patch(path, self.patch))))), pathPatch.empty);\n/** @internal */\nexport const constantCase = self => contramapPath(self, StringUtils.constantCase);\n/** @internal */\nexport const kebabCase = self => contramapPath(self, StringUtils.kebabCase);\n/** @internal */\nexport const lowerCase = self => contramapPath(self, StringUtils.lowerCase);\n/** @internal */\nexport const snakeCase = self => contramapPath(self, StringUtils.snakeCase);\n/** @internal */\nexport const upperCase = self => contramapPath(self, StringUtils.upperCase);\n/** @internal */\nexport const within = /*#__PURE__*/Debug.untracedDual(3, () => (self, path, f) => {\n  const unnest = Chunk.reduce(path, self, (provider, name) => unnested(provider, name));\n  const nest = Chunk.reduceRight(path, f(unnest), (provider, name) => nested(provider, name));\n  return orElse(nest, () => self);\n});\nconst splitPathString = (text, delim) => {\n  const split = text.split(new RegExp(`\\\\s*${escapeRegex(delim)}\\\\s*`));\n  return Chunk.unsafeFromArray(split);\n};\nconst parsePrimitive = (text, path, primitive, delimiter, split) => {\n  if (!split) {\n    return core.mapError(configError.prefixed(path))(core.map(Chunk.of)(core.fromEither(primitive.parse(text))));\n  }\n  return core.mapError(configError.prefixed(path))(core.forEach(char => core.fromEither(primitive.parse(char.trim())))(splitPathString(text, delimiter)));\n};\nconst transpose = array => {\n  return Object.keys(array[0]).map(column => array.map(row => row[column]));\n};\nconst escapeRegex = string => {\n  return string.replace(/[/\\-\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n};\n//# sourceMappingURL=configProvider.mjs.map","var _a;\nimport * as Debug from \"@effect/io/Debug\";\nimport * as core from \"@effect/io/internal_effect_untraced/core\";\nimport * as Chunk from \"@fp-ts/data/Chunk\";\nimport * as Context from \"@fp-ts/data/Context\";\nimport * as PCGRandom from \"@fp-ts/data/Random\";\n/** @internal */\nconst RandomSymbolKey = \"@effect/io/Random\";\n/** @internal */\nexport const RandomTypeId = /*#__PURE__*/Symbol.for(RandomSymbolKey);\n/** @internal */\nexport const randomTag = /*#__PURE__*/Context.Tag();\n/** @internal */\nclass RandomImpl {\n  constructor(seed) {\n    this.seed = seed;\n    this[_a] = RandomTypeId;\n    this.PRNG = new PCGRandom.PCGRandom(seed);\n  }\n  next() {\n    return Debug.bodyWithTrace(trace => core.sync(() => this.PRNG.number()).traced(trace));\n  }\n  nextBoolean() {\n    return Debug.bodyWithTrace(trace => core.map(this.next(), n => n > 0.5).traced(trace));\n  }\n  nextInt() {\n    return Debug.bodyWithTrace(trace => core.sync(() => this.PRNG.integer(Number.MAX_SAFE_INTEGER)).traced(trace));\n  }\n  nextRange(min, max) {\n    return Debug.bodyWithTrace(trace => core.map(this.next(), n => (max - min) * n + min).traced(trace));\n  }\n  nextIntBetween(min, max) {\n    return Debug.bodyWithTrace(trace => core.sync(() => this.PRNG.integer(1 + max - min) + min).traced(trace));\n  }\n  shuffle(elements) {\n    return Debug.bodyWithTrace(trace => shuffleWith(elements, n => this.nextIntBetween(0, n)).traced(trace));\n  }\n}\n_a = RandomTypeId;\nconst shuffleWith = (elements, nextIntBounded) => {\n  return core.suspendSucceed(() => core.flatMap(buffer => {\n    const numbers = [];\n    for (let i = buffer.length; i >= 2; i = i - 1) {\n      numbers.push(i);\n    }\n    return core.as(Chunk.fromIterable(buffer))(core.forEachDiscard(n => core.map(k => swap(buffer, n - 1, k))(nextIntBounded(n)))(numbers));\n  })(core.sync(() => Array.from(elements))));\n};\nconst swap = (buffer, index1, index2) => {\n  const tmp = buffer[index1];\n  buffer[index1] = buffer[index2];\n  buffer[index2] = tmp;\n  return buffer;\n};\nexport const make = seed => new RandomImpl(seed);\n//# sourceMappingURL=random.mjs.map","import * as Debug from \"@effect/io/Debug\";\nimport * as clock from \"@effect/io/internal_effect_untraced/clock\";\nimport * as configProvider from \"@effect/io/internal_effect_untraced/configProvider\";\nimport * as core from \"@effect/io/internal_effect_untraced/core\";\nimport * as random from \"@effect/io/internal_effect_untraced/random\";\nimport * as Context from \"@fp-ts/data/Context\";\n/** @internal */\nexport const liveServices = /*#__PURE__*/Context.add(configProvider.configProviderTag, configProvider.fromEnv())( /*#__PURE__*/Context.add(random.randomTag, random.make(Math.random() * 4294967296 >>> 0))( /*#__PURE__*/Context.add(clock.clockTag, clock.make())( /*#__PURE__*/Context.empty())));\n/**\n * The `FiberRef` holding the default `Effect` services.\n *\n * @since 1.0.0\n * @category fiberRefs\n */\nexport const currentServices = /*#__PURE__*/core.fiberRefUnsafeMakeContext(liveServices);\n// circular with Clock\n/** @internal */\nexport const currentTimeMillis = /*#__PURE__*/Debug.methodWithTrace(trace => () => clockWith(clock => clock.currentTimeMillis()).traced(trace));\n/** @internal */\nexport const sleep = /*#__PURE__*/Debug.methodWithTrace(trace => duration => clockWith(clock => clock.sleep(duration)).traced(trace));\n/** @internal */\nexport const clockWith = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => f => core.fiberRefGetWith(currentServices, services => restore(f)(Context.get(clock.clockTag)(services))).traced(trace));\n/** @internal */\nexport const withClock = /*#__PURE__*/Debug.dualWithTrace(2, trace => (effect, value) => core.fiberRefLocallyWith(currentServices, Context.add(clock.clockTag, value))(effect).traced(trace));\n// circular with ConfigProvider\n/** @internal */\nexport const withConfigProvider = /*#__PURE__*/Debug.dualWithTrace(2, trace => (effect, value) => core.fiberRefLocallyWith(currentServices, Context.add(configProvider.configProviderTag, value))(effect).traced(trace));\n/** @internal */\nexport const configProviderWith = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => f => core.fiberRefGetWith(currentServices, services => restore(f)(Context.get(configProvider.configProviderTag)(services))).traced(trace));\n/** @internal */\nexport const config = /*#__PURE__*/Debug.methodWithTrace(trace => config => configProviderWith(_ => _.load(config)).traced(trace));\n/** @internal */\nexport const configOrDie = /*#__PURE__*/Debug.methodWithTrace(trace => config => core.orDie(configProviderWith(_ => _.load(config))).traced(trace));\n// circular with Random\n/** @internal */\nexport const randomWith = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => f => core.fiberRefGetWith(currentServices, services => restore(f)(Context.get(random.randomTag)(services))).traced(trace));\n/** @internal */\nexport const next = /*#__PURE__*/Debug.methodWithTrace(trace => () => randomWith(random => random.next()).traced(trace));\n/** @internal */\nexport const nextInt = /*#__PURE__*/Debug.methodWithTrace(trace => () => randomWith(random => random.nextInt()).traced(trace));\n/** @internal */\nexport const nextBoolean = /*#__PURE__*/Debug.methodWithTrace(trace => () => randomWith(random => random.nextBoolean()).traced(trace));\n/** @internal */\nexport const nextRange = /*#__PURE__*/Debug.methodWithTrace(trace => (min, max) => randomWith(random => random.nextRange(min, max)).traced(trace));\n/** @internal */\nexport const nextIntBetween = /*#__PURE__*/Debug.methodWithTrace(trace => (min, max) => randomWith(random => random.nextIntBetween(min, max)).traced(trace));\n/** @internal */\nexport const shuffle = /*#__PURE__*/Debug.methodWithTrace(trace => elements => randomWith(random => random.shuffle(elements)).traced(trace));\n//# sourceMappingURL=defaultServices.mjs.map","import * as internal from \"@effect/io/internal_effect_untraced/clock\";\nimport * as defaultServices from \"@effect/io/internal_effect_untraced/defaultServices\";\n/**\n * @since 1.0.0\n * @category symbols\n */\nexport const ClockTypeId = internal.ClockTypeId;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const make = internal.make;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const sleep = defaultServices.sleep;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const currentTimeMillis = defaultServices.currentTimeMillis;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const clockWith = defaultServices.clockWith;\n/**\n * @since 1.0.0\n * @category context\n */\nexport const Tag = internal.clockTag;\n//# sourceMappingURL=Clock.mjs.map","var _a;\nimport * as Debug from \"@effect/io/Debug\";\nimport * as core from \"@effect/io/internal_effect_untraced/core\";\nimport * as Option from \"@fp-ts/core/Option\";\nimport * as Arr from \"@fp-ts/core/ReadonlyArray\";\nimport * as Equal from \"@fp-ts/data/Equal\";\nimport * as HashSet from \"@fp-ts/data/HashSet\";\n/** @internal */\nexport function unsafeMake(fiberRefLocals) {\n  return new FiberRefsImpl(fiberRefLocals);\n}\n/** @internal */\nexport const FiberRefsSym = /*#__PURE__*/Symbol.for(\"@effect/io/FiberRefs\");\n/** @internal */\nexport class FiberRefsImpl {\n  constructor(locals) {\n    this.locals = locals;\n    this[_a] = FiberRefsSym;\n  }\n}\n_a = FiberRefsSym;\n/** @internal */\nconst findAncestor = (_ref, _parentStack, _childStack, _childModified = false) => {\n  const ref = _ref;\n  let parentStack = _parentStack;\n  let childStack = _childStack;\n  let childModified = _childModified;\n  let ret = undefined;\n  while (ret === undefined) {\n    if (Arr.isNonEmpty(parentStack) && Arr.isNonEmpty(childStack)) {\n      const parentFiberId = Arr.headNonEmpty(parentStack)[0];\n      const parentAncestors = Arr.tailNonEmpty(parentStack);\n      const childFiberId = Arr.headNonEmpty(childStack)[0];\n      const childRefValue = Arr.headNonEmpty(childStack)[1];\n      const childAncestors = Arr.tailNonEmpty(childStack);\n      if (parentFiberId.startTimeMillis < childFiberId.startTimeMillis) {\n        childStack = childAncestors;\n        childModified = true;\n      } else if (parentFiberId.startTimeMillis > childFiberId.startTimeMillis) {\n        parentStack = parentAncestors;\n      } else {\n        if (parentFiberId.id < childFiberId.id) {\n          childStack = childAncestors;\n          childModified = true;\n        } else if (parentFiberId.id > childFiberId.id) {\n          parentStack = parentAncestors;\n        } else {\n          ret = [childRefValue, childModified];\n        }\n      }\n    } else {\n      ret = [ref.initial, true];\n    }\n  }\n  return ret;\n};\n/** @internal */\nexport const joinAs = /*#__PURE__*/Debug.dual(3, (self, fiberId, that) => {\n  const parentFiberRefs = new Map(self.locals);\n  for (const [fiberRef, childStack] of that.locals) {\n    const childValue = Arr.headNonEmpty(childStack)[1];\n    if (!Equal.equals(Arr.headNonEmpty(childStack)[0], fiberId)) {\n      if (!parentFiberRefs.has(fiberRef)) {\n        if (Equal.equals(childValue, fiberRef.initial)) {\n          continue;\n        }\n        parentFiberRefs.set(fiberRef, [[fiberId, fiberRef.join(fiberRef.initial, childValue)]]);\n        continue;\n      }\n      const parentStack = parentFiberRefs.get(fiberRef);\n      const [ancestor, wasModified] = findAncestor(fiberRef, parentStack, childStack);\n      if (wasModified) {\n        const patch = fiberRef.diff(ancestor, childValue);\n        const oldValue = Arr.headNonEmpty(parentStack)[1];\n        const newValue = fiberRef.join(oldValue, fiberRef.patch(patch)(oldValue));\n        if (!Equal.equals(oldValue, newValue)) {\n          let newStack;\n          const parentFiberId = Arr.headNonEmpty(parentStack)[0];\n          if (Equal.equals(parentFiberId, fiberId)) {\n            newStack = Arr.prepend([parentFiberId, newValue])(Arr.tailNonEmpty(parentStack));\n          } else {\n            newStack = Arr.prepend([fiberId, newValue])(parentStack);\n          }\n          parentFiberRefs.set(fiberRef, newStack);\n        }\n      }\n    }\n  }\n  return new FiberRefsImpl(new Map(parentFiberRefs));\n});\n/** @internal */\nexport const forkAs = /*#__PURE__*/Debug.dual(2, (self, childId) => {\n  const map = new Map();\n  for (const [fiberRef, stack] of self.locals.entries()) {\n    const oldValue = Arr.headNonEmpty(stack)[1];\n    const newValue = fiberRef.patch(fiberRef.fork)(oldValue);\n    if (Equal.equals(oldValue, newValue)) {\n      map.set(fiberRef, stack);\n    } else {\n      map.set(fiberRef, Arr.prepend([childId, newValue])(stack));\n    }\n  }\n  return new FiberRefsImpl(map);\n});\n/** @internal */\nexport const fiberRefs = self => HashSet.fromIterable(self.locals.keys());\n/** @internal */\nexport const setAll = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.forEachDiscard(fiberRefs(self), fiberRef => core.fiberRefSet(fiberRef, getOrDefault(self, fiberRef))).traced(trace));\n/** @internal */\nexport const delete_ = /*#__PURE__*/Debug.dual(2, (self, fiberRef) => {\n  const locals = new Map(self.locals);\n  locals.delete(fiberRef);\n  return new FiberRefsImpl(locals);\n});\n/** @internal */\nexport const get = /*#__PURE__*/Debug.dual(2, (self, fiberRef) => {\n  if (!self.locals.has(fiberRef)) {\n    return Option.none();\n  }\n  return Option.some(Arr.headNonEmpty(self.locals.get(fiberRef))[1]);\n});\n/** @internal */\nexport const getOrDefault = /*#__PURE__*/Debug.dual(2, (self, fiberRef) => Option.getOrElse(() => fiberRef.initial)(get(self, fiberRef)));\n/** @internal */\nexport const updatedAs = /*#__PURE__*/Debug.dual(4, (self, fiberId, fiberRef, value) => {\n  const oldStack = self.locals.has(fiberRef) ? self.locals.get(fiberRef) : Arr.empty();\n  let newStack;\n  if (Arr.isEmpty(oldStack)) {\n    newStack = Arr.of([fiberId, value]);\n  } else {\n    const [currentId, currentValue] = Arr.headNonEmpty(oldStack);\n    if (Equal.equals(currentId, fiberId)) {\n      if (Equal.equals(currentValue, value)) {\n        return self;\n      } else {\n        newStack = Arr.prepend([fiberId, value])(Arr.tailNonEmpty(oldStack));\n      }\n    } else {\n      newStack = Arr.prepend([fiberId, value])(oldStack);\n    }\n  }\n  const locals = new Map(self.locals);\n  return new FiberRefsImpl(locals.set(fiberRef, newStack));\n});\n//# sourceMappingURL=fiberRefs.mjs.map","import * as internal from \"@effect/io/internal_effect_untraced/fiberRefs\";\n/**\n * @since 1.0.0\n * @category symbols\n */\nexport const FiberRefsSym = internal.FiberRefsSym;\nconst delete_ = internal.delete_;\nexport {\n/**\n * Deletes the specified `FiberRef` from the `FibterRefs`.\n *\n * @since 1.0.0\n * @category mutations\n */\ndelete_ as delete };\n/**\n * Returns a set of each `FiberRef` in this collection.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const fiberRefs = internal.fiberRefs;\n/**\n * Forks this collection of fiber refs as the specified child fiber id. This\n * will potentially modify the value of the fiber refs, as determined by the\n * individual fiber refs that make up the collection.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const forkAs = internal.forkAs;\n/**\n * Gets the value of the specified `FiberRef` in this collection of `FiberRef`\n * values if it exists or `None` otherwise.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const get = internal.get;\n/**\n * Gets the value of the specified `FiberRef` in this collection of `FiberRef`\n * values if it exists or the `initial` value of the `FiberRef` otherwise.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const getOrDefault = internal.getOrDefault;\n/**\n * Joins this collection of fiber refs to the specified collection, as the\n * specified fiber id. This will perform diffing and merging to ensure\n * preservation of maximum information from both child and parent refs.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const joinAs = internal.joinAs;\n/**\n * Set each ref to either its value or its default.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const setAll = internal.setAll;\n/**\n * Updates the value of the specified `FiberRef` using the provided `FiberId`\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const updatedAs = internal.updatedAs;\n/**\n * Note: it will not copy the provided Map, make sure to provide a fresh one.\n *\n * @since 1.0.0\n * @category unsafe\n */\nexport const unsafeMake = internal.unsafeMake;\n//# sourceMappingURL=FiberRefs.mjs.map","import * as Debug from \"@effect/io/Debug\";\nimport * as _fiberRefs from \"@effect/io/internal_effect_untraced/fiberRefs\";\nimport * as Arr from \"@fp-ts/core/ReadonlyArray\";\nimport { equals } from \"@fp-ts/data/Equal\";\n/** @internal */\nexport const OP_EMPTY = \"Empty\";\n/** @internal */\nexport const OP_ADD = \"Add\";\n/** @internal */\nexport const OP_REMOVE = \"Remove\";\n/** @internal */\nexport const OP_UPDATE = \"Update\";\n/** @internal */\nexport const OP_AND_THEN = \"AndThen\";\n/** @internal */\nexport const empty = () => ({\n  _tag: OP_EMPTY\n});\n/** @internal */\nexport const diff = (oldValue, newValue) => {\n  const missingLocals = new Map(oldValue.locals);\n  let patch = empty();\n  for (const [fiberRef, pairs] of newValue.locals.entries()) {\n    const newValue = Arr.headNonEmpty(pairs)[1];\n    const old = missingLocals.get(fiberRef);\n    if (old !== undefined) {\n      const oldValue = Arr.headNonEmpty(old)[1];\n      if (!equals(oldValue, newValue)) {\n        patch = combine({\n          _tag: OP_UPDATE,\n          fiberRef,\n          patch: fiberRef.diff(oldValue, newValue)\n        })(patch);\n      }\n    } else {\n      patch = combine({\n        _tag: OP_ADD,\n        fiberRef,\n        value: newValue\n      })(patch);\n    }\n    missingLocals.delete(fiberRef);\n  }\n  for (const [fiberRef] of missingLocals.entries()) {\n    patch = combine({\n      _tag: OP_REMOVE,\n      fiberRef\n    })(patch);\n  }\n  return patch;\n};\n/** @internal */\nexport const combine = /*#__PURE__*/Debug.dual(2, (self, that) => ({\n  _tag: OP_AND_THEN,\n  first: self,\n  second: that\n}));\n/** @internal */\nexport const patch = /*#__PURE__*/Debug.dual(3, (self, fiberId, oldValue) => {\n  let fiberRefs = oldValue;\n  let patches = Arr.of(self);\n  while (Arr.isNonEmpty(patches)) {\n    const head = Arr.headNonEmpty(patches);\n    const tail = Arr.tailNonEmpty(patches);\n    switch (head._tag) {\n      case OP_EMPTY:\n        {\n          patches = tail;\n          break;\n        }\n      case OP_ADD:\n        {\n          fiberRefs = _fiberRefs.updatedAs(fiberRefs, fiberId, head.fiberRef, head.value);\n          patches = tail;\n          break;\n        }\n      case OP_REMOVE:\n        {\n          fiberRefs = _fiberRefs.delete_(fiberRefs, head.fiberRef);\n          patches = tail;\n          break;\n        }\n      case OP_UPDATE:\n        {\n          const value = _fiberRefs.getOrDefault(fiberRefs, head.fiberRef);\n          fiberRefs = _fiberRefs.updatedAs(fiberRefs, fiberId, head.fiberRef, head.fiberRef.patch(head.patch)(value));\n          patches = tail;\n          break;\n        }\n      case OP_AND_THEN:\n        {\n          patches = Arr.prepend(head.first)(Arr.prepend(head.second)(tail));\n          break;\n        }\n    }\n  }\n  return fiberRefs;\n});\n//# sourceMappingURL=patch.mjs.map","var _a;\nimport * as Equal from \"@fp-ts/data/Equal\";\nimport * as Hash from \"@fp-ts/data/Hash\";\n/** @internal */\nconst MetricLabelSymbolKey = \"@effect/io/Metric/Label\";\n/** @internal */\nexport const MetricLabelTypeId = /*#__PURE__*/Symbol.for(MetricLabelSymbolKey);\n/** @internal */\nclass MetricLabelImpl {\n  constructor(key, value) {\n    this.key = key;\n    this.value = value;\n    this[_a] = MetricLabelTypeId;\n  }\n  [(_a = MetricLabelTypeId, Hash.symbol)]() {\n    return Hash.combine(Hash.hash(this.value))(Hash.combine(Hash.hash(this.key))(Hash.hash(MetricLabelSymbolKey)));\n  }\n  [Equal.symbol](that) {\n    return isMetricLabel(that) && this.key === that.key && this.value === that.value;\n  }\n}\n/** @internal */\nexport const make = (key, value) => {\n  return new MetricLabelImpl(key, value);\n};\n/** @internal */\nexport const isMetricLabel = u => {\n  return typeof u === \"object\" && u != null && MetricLabelTypeId in u;\n};\n//# sourceMappingURL=label.mjs.map","/** @internal */\nexport class SingleShotGen {\n  constructor(self) {\n    this.self = self;\n    this.called = false;\n  }\n  next(a) {\n    return this.called ? {\n      value: a,\n      done: true\n    } : (this.called = true, {\n      value: this.self,\n      done: false\n    });\n  }\n  return(a) {\n    return {\n      value: a,\n      done: true\n    };\n  }\n  throw(e) {\n    throw e;\n  }\n  [Symbol.iterator]() {\n    return new SingleShotGen(this.self);\n  }\n}\n//# sourceMappingURL=singleShotGen.mjs.map","import * as monoid from \"@fp-ts/core/typeclass/Monoid\";\nimport * as order from \"@fp-ts/core/typeclass/Order\";\nimport * as semigroup from \"@fp-ts/core/typeclass/Semigroup\";\n/**\n * `Monoid` that returns last minimum of elements.\n *\n * @category constructors\n * @since 1.0.0\n */\nexport const min = B => monoid.fromSemigroup(semigroup.min(B), B.maxBound);\n/**\n * `Monoid` that returns last maximum of elements.\n *\n * @category constructors\n * @since 1.0.0\n */\nexport const max = B => monoid.fromSemigroup(semigroup.max(B), B.minBound);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const number = {\n  compare: order.number.compare,\n  maxBound: Infinity,\n  minBound: -Infinity\n};\n/**\n * Clamp a value between `minBound` and `maxBound` values.\n *\n * @since 1.0.0\n */\nexport const clamp = B => order.clamp(B)(B.minBound, B.maxBound);\n/**\n * Reverses the `Order` of a `Bounded` and flips `maxBound` and `minBound` values.\n *\n * @since 1.0.0\n */\nexport const reverse = B => ({\n  ...order.reverse(B),\n  minBound: B.minBound,\n  maxBound: B.maxBound\n});\n//# sourceMappingURL=Bounded.mjs.map","import * as predicate from \"@fp-ts/core/Predicate\";\nimport * as bounded from \"@fp-ts/core/typeclass/Bounded\";\nimport * as equivalence from \"@fp-ts/core/typeclass/Equivalence\";\nimport * as monoid from \"@fp-ts/core/typeclass/Monoid\";\nimport * as order from \"@fp-ts/core/typeclass/Order\";\nimport * as semigroup from \"@fp-ts/core/typeclass/Semigroup\";\n/**\n * @category guards\n * @since 1.0.0\n */\nexport const isNumber = predicate.isNumber;\n/**\n * @since 1.0.0\n */\nexport const sum = that => self => semigroup.numberSum.combine(self, that);\n/**\n * @since 1.0.0\n */\nexport const multiply = that => self => semigroup.numberMultiply.combine(self, that);\n/**\n * @since 1.0.0\n */\nexport const subtract = that => self => self - that;\n/**\n * @since 1.0.0\n */\nexport const divide = that => self => self / that;\n/**\n * @since 1.0.0\n */\nexport const increment = n => n + 1;\n/**\n * @since 1.0.0\n */\nexport const decrement = n => n - 1;\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Equivalence = equivalence.number;\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Order = order.number;\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const Bounded = bounded.number;\n/**\n * `number` semigroup under addition.\n *\n * @example\n * import { SemigroupSum } from '@fp-ts/core/Number'\n * import { pipe } from '@fp-ts/core/Function'\n *\n * assert.deepStrictEqual(SemigroupSum.combine(2, 3), 5)\n *\n * @category instances\n * @since 1.0.0\n */\nexport const SemigroupSum = semigroup.numberSum;\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const SemigroupMax = /*#__PURE__*/semigroup.max(Order);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const SemigroupMin = /*#__PURE__*/semigroup.min(Order);\n/**\n * `number` semigroup under multiplication.\n *\n * @example\n * import { SemigroupMultiply } from '@fp-ts/core/Number'\n * import { pipe } from '@fp-ts/core/Function'\n *\n * assert.deepStrictEqual(SemigroupMultiply.combine(2, 3), 6)\n *\n * @category instances\n * @since 1.0.0\n */\nexport const SemigroupMultiply = semigroup.numberMultiply;\n/**\n * `number` monoid under addition.\n *\n * The `empty` value is `0`.\n *\n * @category instances\n * @since 1.0.0\n */\nexport const MonoidSum = monoid.numberSum;\n/**\n * `number` monoid under multiplication.\n *\n * The `empty` value is `1`.\n *\n * @category instances\n * @since 1.0.0\n */\nexport const MonoidMultiply = monoid.numberMultiply;\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const MonoidMax = /*#__PURE__*/bounded.max(Bounded);\n/**\n * @category instances\n * @since 1.0.0\n */\nexport const MonoidMin = /*#__PURE__*/bounded.min(Bounded);\n/**\n * @since 1.0.0\n */\nexport const sign = n => n < 0 ? -1 : n > 0 ? 1 : 0;\n/*\n\n  Missing:\n\n  - toFixed\n  - toPrecision\n  - toExponential\n  - toLocaleString\n\n*/\n//# sourceMappingURL=Number.mjs.map","import * as core from \"@effect/io/internal_effect_untraced/core\";\nimport * as number from \"@fp-ts/core/Number\";\nimport * as order from \"@fp-ts/core/typeclass/Order\";\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const All = core.logLevelAll;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const Fatal = core.logLevelFatal;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const Error = core.logLevelError;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const Warning = core.logLevelWarning;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const Info = core.logLevelInfo;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const Debug = core.logLevelDebug;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const Trace = core.logLevelTrace;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const None = core.logLevelNone;\n/**\n * Locally applies the specified `LogLevel` to an `Effect` workflow, reverting\n * to the previous `LogLevel` after the `Effect` workflow completes.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const locally = level => core.fiberRefLocally(core.currentLogLevel, level);\n/**\n * @since 1.0.0\n * @category instances\n */\nexport const Order = /*#__PURE__*/order.contramap(level => level.ordinal)(number.Order);\n/**\n * @since 1.0.0\n * @category ordering\n */\nexport const lessThan = /*#__PURE__*/order.lessThan(Order);\n/**\n * @since 1.0.0\n * @category ordering\n */\nexport const lessThanEqual = /*#__PURE__*/order.lessThanOrEqualTo(Order);\n/**\n * @since 1.0.0\n * @category ordering\n */\nexport const greaterThan = /*#__PURE__*/order.greaterThan(Order);\n/**\n * @since 1.0.0\n * @category ordering\n */\nexport const greaterThanEqual = /*#__PURE__*/order.greaterThanOrEqualTo(Order);\n/**\n * @since 1.0.0\n * @category conversions\n */\nexport const fromLiteral = _ => {\n  switch (_) {\n    case \"All\":\n      {\n        return All;\n      }\n    case \"Debug\":\n      {\n        return Debug;\n      }\n    case \"Error\":\n      {\n        return Error;\n      }\n    case \"Fatal\":\n      {\n        return Fatal;\n      }\n    case \"Info\":\n      {\n        return Info;\n      }\n    case \"Trace\":\n      {\n        return Trace;\n      }\n    case \"None\":\n      {\n        return None;\n      }\n    case \"Warning\":\n      {\n        return Warning;\n      }\n  }\n};\n//# sourceMappingURL=Level.mjs.map","/** @internal */\nexport const make = (label, startTime) => ({\n  label,\n  startTime\n});\n/** @internal */\nexport const render = now => {\n  return self => {\n    const label = self.label.replace(/[\\s=\"]/g, \"_\");\n    return `${label}=${now - self.startTime}ms`;\n  };\n};\n//# sourceMappingURL=logSpan.mjs.map","/**\n * @since 1.0.0\n */\nimport * as internal from \"@effect/io/internal_effect_untraced/logSpan\";\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const make = internal.make;\n/**\n * @since 1.0.0\n * @category destructors\n */\nexport const render = internal.render;\n//# sourceMappingURL=Span.mjs.map","import * as defaultServices from \"@effect/io/internal_effect_untraced/defaultServices\";\nimport * as internal from \"@effect/io/internal_effect_untraced/random\";\n/**\n * @since 1.0.0\n * @category symbols\n */\nexport const RandomTypeId = internal.RandomTypeId;\n/**\n * Returns the next numeric value from the pseudo-random number generator.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const next = defaultServices.next;\n/**\n * Returns the next integer value from the pseudo-random number generator.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const nextInt = defaultServices.nextInt;\n/**\n * Returns the next boolean value from the pseudo-random number generator.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const nextBoolean = defaultServices.nextBoolean;\n/**\n * Returns the next numeric value in the specified range from the\n * pseudo-random number generator.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const nextRange = defaultServices.nextRange;\n/**\n * Returns the next integer value in the specified range from the\n * pseudo-random number generator.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const nextIntBetween = defaultServices.nextIntBetween;\n/**\n * Uses the pseudo-random number generator to shuffle the specified iterable.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const shuffle = defaultServices.shuffle;\n/**\n * Retreives the `Random` service from the context and uses it to run the\n * specified workflow.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const randomWith = defaultServices.randomWith;\n//# sourceMappingURL=Random.mjs.map","var _a;\nimport * as Debug from \"@effect/io/Debug\";\nimport * as core from \"@effect/io/internal_effect_untraced/core\";\nimport * as Option from \"@fp-ts/core/Option\";\nimport * as MutableRef from \"@fp-ts/data/MutableRef\";\n/** @internal */\nexport const RefTypeId = /*#__PURE__*/Symbol.for(\"@effect/io/Ref\");\n/** @internal */\nexport const refVariance = {\n  _A: _ => _\n};\nclass RefImpl {\n  constructor(ref) {\n    this.ref = ref;\n    this[_a] = refVariance;\n  }\n  modify(f) {\n    return Debug.bodyWithTrace((trace, restore) => core.sync(() => {\n      const current = MutableRef.get(this.ref);\n      const [b, a] = restore(f)(current);\n      if (current !== a) {\n        MutableRef.set(a)(this.ref);\n      }\n      return b;\n    }).traced(trace));\n  }\n}\n_a = RefTypeId;\n/** @internal */\nexport const unsafeMake = value => new RefImpl(MutableRef.make(value));\n/** @internal */\nexport const make = /*#__PURE__*/Debug.methodWithTrace(trace => value => core.sync(() => unsafeMake(value)).traced(trace));\n/** @internal */\nexport const get = /*#__PURE__*/Debug.methodWithTrace(trace => self => self.modify(a => [a, a]).traced(trace));\n/** @internal */\nexport const set = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, value) => self.modify(() => [void 0, value]).traced(trace));\n/** @internal */\nexport const getAndSet = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, value) => self.modify(a => [a, value]).traced(trace));\n/** @internal */\nexport const getAndUpdate = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => self.modify(a => [a, restore(f)(a)]).traced(trace));\n/** @internal */\nexport const getAndUpdateSome = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, pf) => self.modify(value => {\n  const option = restore(pf)(value);\n  switch (option._tag) {\n    case \"None\":\n      {\n        return [value, value];\n      }\n    case \"Some\":\n      {\n        return [value, option.value];\n      }\n  }\n}).traced(trace));\n/** @internal */\nexport const setAndGet = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, value) => self.modify(() => [value, value]).traced(trace));\n/** @internal */\nexport const modify = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => self.modify(restore(f)).traced(trace));\n/** @internal */\nexport const modifySome = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, fallback, pf) => self.modify(value => {\n  const option = restore(pf)(value);\n  switch (option._tag) {\n    case \"None\":\n      {\n        return [fallback, value];\n      }\n    case \"Some\":\n      {\n        return option.value;\n      }\n  }\n}).traced(trace));\n/** @internal */\nexport const update = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => self.modify(a => [void 0, restore(f)(a)]).traced(trace));\n/** @internal */\nexport const updateAndGet = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => self.modify(a => {\n  const result = restore(f)(a);\n  return [result, result];\n}).traced(trace));\n/** @internal */\nexport const updateSome = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => self.modify(a => [void 0, Option.match(() => a, b => b)(restore(f)(a))]).traced(trace));\n/** @internal */\nexport const updateSomeAndGet = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, pf) => self.modify(value => {\n  const option = restore(pf)(value);\n  switch (option._tag) {\n    case \"None\":\n      {\n        return [value, value];\n      }\n    case \"Some\":\n      {\n        return [option.value, option.value];\n      }\n  }\n}).traced(trace));\n/** @internal */\nexport const unsafeGet = self => MutableRef.get(self.ref);\n//# sourceMappingURL=ref.mjs.map","import * as internal from \"@effect/io/internal_effect_untraced/ref\";\n/**\n * @since 1.0.0\n * @category symbols\n */\nexport const RefTypeId = internal.RefTypeId;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const make = internal.make;\n/**\n * @since 1.0.0\n * @category getters\n */\nexport const get = internal.get;\n/**\n * @since 1.0.0\n * @category mutations\n */\nexport const getAndSet = internal.getAndSet;\n/**\n * @since 1.0.0\n * @category mutations\n */\nexport const getAndUpdate = internal.getAndUpdate;\n/**\n * @since 1.0.0\n * @category mutations\n */\nexport const getAndUpdateSome = internal.getAndUpdateSome;\n/**\n * @since 1.0.0\n * @category mutations\n */\nexport const modify = internal.modify;\n/**\n * @since 1.0.0\n * @category mutations\n */\nexport const modifySome = internal.modifySome;\n/**\n * @since 1.0.0\n * @category mutations\n */\nexport const set = internal.set;\n/**\n * @since 1.0.0\n * @category mutations\n */\nexport const setAndGet = internal.setAndGet;\n/**\n * @since 1.0.0\n * @category mutations\n */\nexport const update = internal.update;\n/**\n * @since 1.0.0\n * @category mutations\n */\nexport const updateAndGet = internal.updateAndGet;\n/**\n * @since 1.0.0\n * @category mutations\n */\nexport const updateSome = internal.updateSome;\n/**\n * @since 1.0.0\n * @category mutations\n */\nexport const updateSomeAndGet = internal.updateSomeAndGet;\n/**\n * @since 1.0.0\n * @category unsafe\n */\nexport const unsafeMake = internal.unsafeMake;\n//# sourceMappingURL=Ref.mjs.map","/**\n * @since 1.0.0\n */\nimport * as Dual from \"@fp-ts/data/Dual\";\nimport * as Equal from \"@fp-ts/data/Equal\";\nimport * as Hash from \"@fp-ts/data/Hash\";\nconst TypeId = /*#__PURE__*/Symbol.for(\"@fp-ts/data/Duration\");\n/** @internal */\nclass DurationImpl {\n  constructor(millis) {\n    this.millis = millis;\n    this._id = TypeId;\n  }\n  [Hash.symbol]() {\n    return Hash.hash(this.millis);\n  }\n  [Equal.symbol](that) {\n    return isDuration(that) && this.millis === that.millis;\n  }\n}\n/**\n * @since 1.0.0\n * @category guards\n */\nexport const isDuration = u => typeof u === \"object\" && u != null && \"_id\" in u && u[\"_id\"] === TypeId;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const zero = /*#__PURE__*/new DurationImpl(0);\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const infinity = /*#__PURE__*/new DurationImpl(Infinity);\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const millis = millis => new DurationImpl(millis);\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const seconds = seconds => new DurationImpl(seconds * 1000);\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const minutes = minutes => new DurationImpl(minutes * 60000);\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const hours = hours => new DurationImpl(hours * 3600000);\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const days = days => new DurationImpl(days * 86400000);\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const weeks = weeks => new DurationImpl(weeks * 604800000);\n/**\n * @since 1.0.0\n * @category mutations\n */\nexport const times = /*#__PURE__*/Dual.dual(2, (self, times) => new DurationImpl(self.millis * times));\n/**\n * @since 1.0.0\n * @category mutations\n */\nexport const add = /*#__PURE__*/Dual.dual(2, (self, that) => new DurationImpl(self.millis + that.millis));\n/**\n * @since 1.0.0\n * @category mutations\n */\nexport const subtract = /*#__PURE__*/Dual.dual(2, (self, that) => new DurationImpl(self.millis - that.millis));\n/**\n * @since 1.0.0\n * @category comparisons\n */\nexport const lessThan = /*#__PURE__*/Dual.dual(2, (self, that) => self.millis < that.millis);\n/**\n * @since 1.0.0\n * @category comparisons\n */\nexport const lessThanOrEqualTo = /*#__PURE__*/Dual.dual(2, (self, that) => self.millis <= that.millis);\n/**\n * @since 1.0.0\n * @category comparisons\n */\nexport const greaterThan = /*#__PURE__*/Dual.dual(2, (self, that) => self.millis > that.millis);\n/**\n * @since 1.0.0\n * @category comparisons\n */\nexport const greaterThanOrEqualTo = /*#__PURE__*/Dual.dual(2, (self, that) => self.millis >= that.millis);\n/**\n * @since 1.0.0\n * @category comparisons\n */\nexport const equals = /*#__PURE__*/Dual.dual(2, (self, that) => self.millis === that.millis);\n//# sourceMappingURL=Duration.mjs.map","import * as Clock from \"@effect/io/Clock\";\nimport * as Debug from \"@effect/io/Debug\";\nimport * as Exit from \"@effect/io/Exit\";\nimport * as FiberId from \"@effect/io/Fiber/Id\";\nimport * as FiberRefs from \"@effect/io/FiberRefs\";\nimport * as internalCause from \"@effect/io/internal_effect_untraced/cause\";\nimport * as core from \"@effect/io/internal_effect_untraced/core\";\nimport * as fiberRefsPatch from \"@effect/io/internal_effect_untraced/fiberRefs/patch\";\nimport * as metricLabel from \"@effect/io/internal_effect_untraced/metric/label\";\nimport * as SingleShotGen from \"@effect/io/internal_effect_untraced/singleShotGen\";\nimport * as LogLevel from \"@effect/io/Logger/Level\";\nimport * as LogSpan from \"@effect/io/Logger/Span\";\nimport * as Random from \"@effect/io/Random\";\nimport * as Ref from \"@effect/io/Ref\";\nimport * as Either from \"@fp-ts/core/Either\";\nimport { constFalse, constTrue, constVoid, identity } from \"@fp-ts/core/Function\";\nimport * as Option from \"@fp-ts/core/Option\";\nimport * as Chunk from \"@fp-ts/data/Chunk\";\nimport * as Context from \"@fp-ts/data/Context\";\nimport * as Duration from \"@fp-ts/data/Duration\";\nimport * as HashMap from \"@fp-ts/data/HashMap\";\nimport * as HashSet from \"@fp-ts/data/HashSet\";\n/* @internal */\nexport const absolve = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.flatMap(self, core.fromEither).traced(trace));\n/* @internal */\nexport const absorb = /*#__PURE__*/Debug.methodWithTrace(trace => self => absorbWith(self, identity).traced(trace));\n/* @internal */\nexport const absorbWith = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.matchEffect(sandbox(self), cause => core.fail(internalCause.squashWith(restore(f))(cause)), core.succeed).traced(trace));\n/* @internal */\nexport const allowInterrupt = /*#__PURE__*/Debug.methodWithTrace(trace => () => descriptorWith(descriptor => HashSet.size(descriptor.interruptors) > 0 ? core.interrupt() : core.unit()).traced(trace));\n/* @internal */\nexport const asLeft = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.map(Either.left)(self).traced(trace));\n/* @internal */\nexport const asLeftError = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.mapError(Either.left)(self).traced(trace));\n/* @internal */\nexport const asRight = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.map(Either.right)(self).traced(trace));\n/* @internal */\nexport const asRightError = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.mapError(Either.right)(self).traced(trace));\n/* @internal */\nexport const asSome = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.map(Option.some)(self).traced(trace));\n/* @internal */\nexport const asSomeError = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.mapError(Option.some)(self).traced(trace));\n/* @internal */\nexport const asyncOption = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (register, blockingOn = FiberId.none) => core.asyncInterruptEither(cb => {\n  const option = restore(register)(cb);\n  switch (option._tag) {\n    case \"None\":\n      {\n        return Either.left(core.unit());\n      }\n    case \"Some\":\n      {\n        return Either.right(option.value);\n      }\n  }\n}, blockingOn).traced(trace));\n/* @internal */\nexport const attempt = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => evaluate => core.sync(() => {\n  try {\n    return restore(evaluate)();\n  } catch (error) {\n    throw core.makeEffectError(internalCause.fail(error));\n  }\n}).traced(trace));\n/* @internal */\nexport const blocking = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.zipRight(core.yieldNow(\"background\"), self).traced(trace));\n/* @internal */\nexport const _catch = /*#__PURE__*/Debug.dualWithTrace(\n// @ts-expect-error - TODO: figure out why the above functions do not infer properly (probably a TS bug DF doesn't extend (...args: any[]) => any), but ofc it does)\n4, (trace, restore) => (self, tag, k, f) => core.catchAll(self, e => {\n  if (typeof e === \"object\" && e != null && tag in e && e[tag] === k) {\n    return restore(f)(e);\n  }\n  return core.fail(e);\n}).traced(trace));\n/* @internal */\nexport const catchAllDefect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => catchSomeDefect(self, defect => Option.some(restore(f)(defect))).traced(trace));\n/* @internal */\nexport const catchSomeCause = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.matchCauseEffect(self, cause => {\n  const option = restore(f)(cause);\n  switch (option._tag) {\n    case \"None\":\n      {\n        return core.failCause(cause);\n      }\n    case \"Some\":\n      {\n        return option.value;\n      }\n  }\n}, core.succeed).traced(trace));\n/* @internal */\nexport const catchSomeDefect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, pf) => core.catchAll(s => s)(unrefineWith(self, restore(pf), core.fail)).traced(trace));\n/* @internal */\nexport const catchTag = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, k, f) => core.catchAll(self, e => {\n  if (\"_tag\" in e && e[\"_tag\"] === k) {\n    return restore(f)(e);\n  }\n  return core.fail(e);\n}).traced(trace));\n/* @internal */\nexport const cause = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.matchCause(identity, () => internalCause.empty)(self).traced(trace));\n/* @internal */\nexport const clock = /*#__PURE__*/Debug.methodWithTrace(trace => () => clockWith(core.succeed).traced(trace));\n/* @internal */\nexport const clockWith = Clock.clockWith;\n/* @internal */\nexport const collectAll = /*#__PURE__*/Debug.methodWithTrace(trace => effects => core.forEach(effects, identity).traced(trace));\n/* @internal */\nexport const collectAllDiscard = /*#__PURE__*/Debug.methodWithTrace(trace => effects => core.forEachDiscard(effects, identity).traced(trace));\n/* @internal */\nexport const collectAllWith = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, pf) => core.map(collectAll(elements), Chunk.filterMap(restore(pf))).traced(trace));\n/* @internal */\nexport const collectAllWithEffect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => {\n  const array = Array.from(elements);\n  // Break out early if there are no elements\n  if (array.length === 0) {\n    return core.succeed(Chunk.empty()).traced(trace);\n  }\n  // Break out early if there is only one element\n  if (array.length === 1) {\n    const option = restore(f)(array[0]);\n    switch (option._tag) {\n      case \"None\":\n        {\n          return core.succeed(Chunk.empty()).traced(trace);\n        }\n      case \"Some\":\n        {\n          return core.map(option.value, Chunk.of).traced(trace);\n        }\n    }\n  }\n  // Otherwise create the intermediate result structure\n  let result = core.succeed(Chunk.empty());\n  for (let i = array.length - 1; i >= 0; i--) {\n    const option = restore(f)(array[i]);\n    if (option._tag === \"Some\") {\n      result = core.zipWith(result, option.value, (list, b) => Chunk.prepend(b)(list));\n    }\n  }\n  return core.map(result, Chunk.fromIterable).traced(trace);\n});\n/* @internal */\nexport const collectAllSuccesses = /*#__PURE__*/Debug.methodWithTrace(trace => as => collectAllWith(exit => Exit.isSuccess(exit) ? Option.some(exit.value) : Option.none())(Array.from(as).map(core.exit)).traced(trace));\n/* @internal */\nexport const collectFirst = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => core.suspendSucceed(() => collectFirstLoop(restore, elements[Symbol.iterator](), restore(f))).traced(trace));\nconst collectFirstLoop = (restore, iterator, f) => {\n  const next = restore(() => iterator.next())();\n  return next.done ? core.succeed(Option.none()) : core.flatMap(option => {\n    switch (option._tag) {\n      case \"None\":\n        {\n          return collectFirstLoop(restore, iterator, f);\n        }\n      case \"Some\":\n        {\n          return core.succeed(option);\n        }\n    }\n  })(f(next.value));\n};\n/* @internal */\nexport const collectWhile = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => {\n  const array = Array.from(elements);\n  // Break out early if the input is empty\n  if (array.length === 0) {\n    return core.succeed(Chunk.empty()).traced(trace);\n  }\n  // Break out early if there is only one element in the list\n  if (array.length === 1) {\n    const option = restore(f)(array[0]);\n    switch (option._tag) {\n      case \"None\":\n        {\n          return core.succeed(Chunk.empty()).traced(trace);\n        }\n      case \"Some\":\n        {\n          return core.map(option.value, Chunk.of).traced(trace);\n        }\n    }\n  }\n  // Otherwise setup our intermediate result\n  let result = core.succeed(Chunk.empty());\n  for (let i = array.length - 1; i >= 0; i--) {\n    const option = restore(f)(array[i]);\n    switch (option._tag) {\n      case \"None\":\n        {\n          return core.map(result, Chunk.fromIterable).traced(trace);\n        }\n      case \"Some\":\n        {\n          result = core.zipWith(result, option.value, (bs, b) => Chunk.prepend(b)(bs));\n        }\n    }\n  }\n  return core.map(result, Chunk.fromIterable).traced(trace);\n});\n/* @internal */\nexport const cond = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (predicate, result, error) => core.suspendSucceed(() => restore(predicate)() ? core.sync(restore(result)) : core.failSync(restore(error))).traced(trace));\n/* @internal */\nexport const continueOrFail = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, error, pf) => continueOrFailEffect(self, error, a => Option.map(core.succeed)(restore(pf)(a))).traced(trace));\n/* @internal */\nexport const continueOrFailEffect = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, error, pf) => core.flatMap(self, value => Option.getOrElse(() => core.fail(error))(restore(pf)(value))).traced(trace));\n/* @internal */\nexport const delay = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, duration) => core.zipRight(Clock.sleep(duration), self).traced(trace));\n/* @internal */\nexport const descriptor = /*#__PURE__*/Debug.methodWithTrace(trace => () => descriptorWith(core.succeed).traced(trace));\n/* @internal */\nexport const descriptorWith = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => f => core.withFiberRuntime((state, status) => restore(f)({\n  id: state.id(),\n  status,\n  interruptors: internalCause.interruptors(state.getFiberRef(core.interruptedCause))\n})).traced(trace));\n/* @internal */\nexport const dieMessage = /*#__PURE__*/Debug.methodWithTrace(trace => message => core.failCauseSync(() => internalCause.die(internalCause.RuntimeException(message))).traced(trace));\n/* @internal */\nexport const diffFiberRefs = /*#__PURE__*/Debug.methodWithTrace(trace => self => summarized(getFiberRefs(), fiberRefsPatch.diff)(self).traced(trace));\n/* @internal */\nexport const Do = /*#__PURE__*/Debug.methodWithTrace(trace => () => core.succeed({}).traced(trace));\n/* @internal */\nexport const bind = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, tag, f) => core.flatMap(self, k => core.map(restore(f)(k), a => ({\n  ...k,\n  [tag]: a\n}))).traced(trace));\n/* @internal */\nexport const bindValue = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, tag, f) => core.map(self, k => ({\n  ...k,\n  [tag]: restore(f)(k)\n})).traced(trace));\n/* @internal */\nexport const dropUntil = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, predicate) => core.suspendSucceed(() => {\n  const iterator = elements[Symbol.iterator]();\n  const builder = [];\n  let next;\n  let dropping = core.succeed(false);\n  while ((next = iterator.next()) && !next.done) {\n    const a = next.value;\n    dropping = core.flatMap(dropping, bool => {\n      if (bool) {\n        builder.push(a);\n        return core.succeed(true);\n      }\n      return restore(predicate)(a);\n    });\n  }\n  return core.map(dropping, () => Chunk.unsafeFromArray(builder));\n}).traced(trace));\n/* @internal */\nexport const dropWhile = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => core.suspendSucceed(() => {\n  const iterator = elements[Symbol.iterator]();\n  const builder = [];\n  let next;\n  let dropping = core.succeed(true);\n  while ((next = iterator.next()) && !next.done) {\n    const a = next.value;\n    dropping = core.flatMap(dropping, d => core.map(d ? restore(f)(a) : core.succeed(false), b => {\n      if (!b) {\n        builder.push(a);\n      }\n      return b;\n    }));\n  }\n  return core.map(dropping, () => Chunk.unsafeFromArray(builder));\n}).traced(trace));\n/* @internal */\nexport const contextWith = /*#__PURE__*/Debug.methodWithTrace(trace => f => core.map(core.context(), f).traced(trace));\n/* @internal */\nexport const exists = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => core.suspendSucceed(() => existsLoop(restore, elements[Symbol.iterator](), restore(f))).traced(trace));\nconst existsLoop = (restore, iterator, f) => {\n  const next = restore(() => iterator.next())();\n  if (next.done) {\n    return core.succeed(false);\n  }\n  return core.flatMap(b => b ? core.succeed(b) : existsLoop(restore, iterator, f))(f(next.value));\n};\n/* @internal */\nexport const eventually = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.orElse(self, () => core.flatMap(() => eventually(self))(core.yieldNow())).traced(trace));\n/* @internal */\nexport const filter = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => core.suspendSucceed(() => Array.from(elements).reduceRight((effect, a) => core.zipWith(effect, core.suspendSucceed(() => restore(f)(a)), (list, b) => b ? Chunk.prepend(a)(list) : list), core.sync(() => Chunk.empty()))).traced(trace));\n/* @internal */\nexport const filterNot = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => filter(elements, a => core.map(restore(f)(a), b => !b)).traced(trace));\n/* @internal */\nexport const filterOrDie = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, f, defect) => filterOrElse(self, restore(f), () => core.dieSync(restore(defect))).traced(trace));\n/* @internal */\nexport const filterOrDieMessage = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, f, message) => filterOrElse(self, restore(f), () => dieMessage(message)).traced(trace));\n/* @internal */\nexport const filterOrElse = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, f, orElse) => filterOrElseWith(self, restore(f), orElse).traced(trace));\n/* @internal */\nexport const filterOrElseWith = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, f, orElse) => core.flatMap(self, a => restore(f)(a) ? core.succeed(a) : restore(orElse)(a)).traced(trace));\n/* @internal */\nexport const filterOrFail = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, f, error) => filterOrElse(self, restore(f), () => core.failSync(restore(error))).traced(trace));\n/* @internal */\nexport const find = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => core.suspendSucceed(() => {\n  const array = Array.from(elements);\n  const iterator = array[Symbol.iterator]();\n  const next = restore(() => iterator.next())();\n  if (!next.done) {\n    return findLoop(restore, iterator, restore(f), next.value);\n  }\n  return core.succeed(Option.none());\n}).traced(trace));\nconst findLoop = (restore, iterator, f, value) => core.flatMap(f(value), result => {\n  if (result) {\n    return core.succeed(Option.some(value));\n  }\n  const next = restore(() => iterator.next())();\n  if (!next.done) {\n    return findLoop(restore, iterator, f, next.value);\n  }\n  return core.succeed(Option.none());\n});\n/* @internal */\nexport const firstSuccessOf = /*#__PURE__*/Debug.methodWithTrace(trace => effects => core.suspendSucceed(() => {\n  const list = Chunk.fromIterable(effects);\n  if (!Chunk.isNonEmpty(list)) {\n    return core.dieSync(() => internalCause.IllegalArgumentException(`Received an empty collection of effects`));\n  }\n  return Chunk.reduce(Chunk.headNonEmpty(list), (left, right) => core.orElse(left, () => right))(Chunk.tailNonEmpty(list));\n}).traced(trace));\n/* @internal */\nexport const flattenErrorOption = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, fallback) => core.mapError(self, Option.getOrElse(() => fallback)).traced(trace));\n/* @internal */\nexport const flipWith = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.flip(restore(f)(core.flip(self))).traced(trace));\n/* @internal */\nexport const match = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, onFailure, onSuccess) => core.matchEffect(self, e => core.succeed(restore(onFailure)(e)), a => core.succeed(restore(onSuccess)(a))).traced(trace));\n/* @internal */\nexport const forAll = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => core.suspendSucceed(() => forAllLoop(restore, elements[Symbol.iterator](), restore(f))).traced(trace));\nconst forAllLoop = (restore, iterator, f) => {\n  const next = restore(() => iterator.next())();\n  return next.done ? core.succeed(true) : core.flatMap(b => b ? forAllLoop(restore, iterator, f) : core.succeed(b))(f(next.value));\n};\n/* @internal */\nexport const forEachEffect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.matchCauseEffect(self, () => core.succeed(Option.none()), a => core.map(restore(f)(a), Option.some)).traced(trace));\n/* @internal */\nexport const forEachOption = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (option, f) => {\n  switch (option._tag) {\n    case \"None\":\n      {\n        return core.succeed(Option.none()).traced(trace);\n      }\n    case \"Some\":\n      {\n        return core.map(restore(f)(option.value), Option.some).traced(trace);\n      }\n  }\n});\n/* @internal */\nexport const forEachWithIndex = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => core.suspendSucceed(() => {\n  let index = 0;\n  const acc = [];\n  return core.map(() => Chunk.unsafeFromArray(acc))(core.forEachDiscard(elements, a => core.map(restore(f)(a, index), b => {\n    acc.push(b);\n    index++;\n  })));\n}).traced(trace));\n/* @internal */\nexport const forever = /*#__PURE__*/Debug.methodWithTrace(trace => self => {\n  const loop = core.flatMap(() => loop)(core.flatMap(self, () => core.yieldNow()));\n  return loop.traced(trace);\n});\n/* @internal */\nexport const fromEitherCause = /*#__PURE__*/Debug.methodWithTrace(trace => either => {\n  switch (either._tag) {\n    case \"Left\":\n      {\n        return core.failCause(either.left).traced(trace);\n      }\n    case \"Right\":\n      {\n        return core.succeed(either.right).traced(trace);\n      }\n  }\n});\n/** @internal */\nclass EffectGen {\n  constructor(value) {\n    this.value = value;\n  }\n  [Symbol.iterator]() {\n    return new SingleShotGen.SingleShotGen(this);\n  }\n}\n/**\n * Inspired by https://github.com/tusharmath/qio/pull/22 (revised)\n  @internal */\nexport const gen = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => f => core.suspendSucceed(() => {\n  const iterator = restore(() => f(self => new EffectGen(self)))();\n  const state = restore(() => iterator.next())();\n  const run = state => state.done ? core.succeed(state.value) : core.flatMap(val => run(restore(() => iterator.next(val))()))(state.value.value);\n  return run(state);\n}).traced(trace));\n/* @internal */\nexport const getFiberRefs = /*#__PURE__*/Debug.methodWithTrace(trace => () => core.withFiberRuntime(state => core.succeed(state.unsafeGetFiberRefs())).traced(trace));\n/* @internal */\nexport const getOrFail = /*#__PURE__*/Debug.methodWithTrace(trace => option => getOrFailWith(() => internalCause.NoSuchElementException())(option).traced(trace));\n/* @internal */\nexport const getOrFailDiscard = /*#__PURE__*/Debug.methodWithTrace(trace => option => getOrFailWith(option, constVoid).traced(trace));\n/* @internal */\nexport const getOrFailWith = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (option, error) => {\n  switch (option._tag) {\n    case \"None\":\n      {\n        return core.failSync(restore(error)).traced(trace);\n      }\n    case \"Some\":\n      {\n        return core.succeed(option.value).traced(trace);\n      }\n  }\n});\n/* @internal */\nexport const head = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => self => core.matchEffect(e => core.fail(Option.some(e)), as => {\n  const iterator = restore(() => as[Symbol.iterator]())();\n  const next = restore(() => iterator.next())();\n  if (next.done) {\n    return core.fail(Option.none());\n  }\n  return core.succeed(next.value);\n})(self).traced(trace));\n/* @internal */\nexport const ignore = /*#__PURE__*/Debug.methodWithTrace(trace => self => match(self, constVoid, constVoid).traced(trace));\n/* @internal */\nexport const ignoreLogged = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.matchCauseEffect(self, cause => logDebugCauseMessage(\"An error was silently ignored because it is not anticipated to be useful\", cause), () => core.unit()).traced(trace));\n/* @internal */\nexport const inheritFiberRefs = /*#__PURE__*/Debug.methodWithTrace(trace => childFiberRefs => updateFiberRefs((parentFiberId, parentFiberRefs) => FiberRefs.joinAs(parentFiberRefs, parentFiberId, childFiberRefs)).traced(trace));\n/* @internal */\nexport const isFailure = /*#__PURE__*/Debug.methodWithTrace(trace => self => match(self, constTrue, constFalse).traced(trace));\n/* @internal */\nexport const isSuccess = /*#__PURE__*/Debug.methodWithTrace(trace => self => match(self, constFalse, constTrue).traced(trace));\n/* @internal */\nexport const iterate = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (initial, cont, body) => core.suspendSucceed(() => {\n  if (restore(cont)(initial)) {\n    return core.flatMap(restore(body)(initial), z2 => iterate(z2, restore(cont), restore(body)));\n  }\n  return core.succeed(initial);\n}).traced(trace));\n/* @internal */\nexport const left = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.matchEffect(self, e => core.fail(Either.left(e)), either => {\n  switch (either._tag) {\n    case \"Left\":\n      {\n        return core.succeed(either.left);\n      }\n    case \"Right\":\n      {\n        return core.fail(Either.right(either.right));\n      }\n  }\n}).traced(trace));\n/* @internal */\nexport const leftWith = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.suspendSucceed(() => unleft(restore(f)(left(self)))).traced(trace));\n/** @internal */\nconst someFatal = /*#__PURE__*/Option.some(LogLevel.Fatal);\n/** @internal */\nconst someError = /*#__PURE__*/Option.some(LogLevel.Error);\n/** @internal */\nconst someWarning = /*#__PURE__*/Option.some(LogLevel.Warning);\n/** @internal */\nconst someTrace = /*#__PURE__*/Option.some(LogLevel.Trace);\n/** @internal */\nconst someInfo = /*#__PURE__*/Option.some(LogLevel.Info);\n/** @internal */\nconst someDebug = /*#__PURE__*/Option.some(LogLevel.Debug);\n/* @internal */\nexport const log = /*#__PURE__*/Debug.methodWithTrace(trace => message => core.withFiberRuntime(fiberState => {\n  fiberState.log(message, internalCause.empty, Option.none());\n  return core.unit();\n}).traced(trace));\n/* @internal */\nexport const logDebug = /*#__PURE__*/Debug.methodWithTrace(trace => message => core.withFiberRuntime(fiberState => {\n  fiberState.log(message, internalCause.empty, someDebug);\n  return core.unit();\n}).traced(trace));\n/* @internal */\nexport const logDebugCause = /*#__PURE__*/Debug.methodWithTrace(trace => cause => core.withFiberRuntime(fiberState => {\n  fiberState.log(\"\", cause, someDebug);\n  return core.unit();\n}).traced(trace));\n/* @internal */\nexport const logDebugCauseMessage = /*#__PURE__*/Debug.methodWithTrace(trace => (message, cause) => core.withFiberRuntime(fiberState => {\n  fiberState.log(message, cause, someDebug);\n  return core.unit();\n}).traced(trace));\n/* @internal */\nexport const logError = /*#__PURE__*/Debug.methodWithTrace(trace => message => core.withFiberRuntime(fiberState => {\n  fiberState.log(message, internalCause.empty, someError);\n  return core.unit();\n}).traced(trace));\n/* @internal */\nexport const logErrorCause = /*#__PURE__*/Debug.methodWithTrace(trace => cause => core.withFiberRuntime(fiberState => {\n  fiberState.log(\"\", cause, someError);\n  return core.unit();\n}).traced(trace));\n/* @internal */\nexport const logErrorCauseMessage = /*#__PURE__*/Debug.methodWithTrace(trace => (message, cause) => core.withFiberRuntime(fiberState => {\n  fiberState.log(message, cause, someError);\n  return core.unit();\n}).traced(trace));\n/* @internal */\nexport const logFatal = /*#__PURE__*/Debug.methodWithTrace(trace => message => core.withFiberRuntime(fiberState => {\n  fiberState.log(message, internalCause.empty, someFatal);\n  return core.unit();\n}).traced(trace));\n/* @internal */\nexport const logFatalCause = /*#__PURE__*/Debug.methodWithTrace(trace => cause => core.withFiberRuntime(fiberState => {\n  fiberState.log(\"\", cause, someFatal);\n  return core.unit();\n}).traced(trace));\n/* @internal */\nexport const logFatalCauseMessage = /*#__PURE__*/Debug.methodWithTrace(trace => (message, cause) => core.withFiberRuntime(fiberState => {\n  fiberState.log(message, cause, someFatal);\n  return core.unit();\n}).traced(trace));\n/* @internal */\nexport const logInfo = /*#__PURE__*/Debug.methodWithTrace(trace => message => core.withFiberRuntime(fiberState => {\n  fiberState.log(message, internalCause.empty, someInfo);\n  return core.unit();\n}).traced(trace));\n/* @internal */\nexport const logInfoCause = /*#__PURE__*/Debug.methodWithTrace(trace => cause => core.withFiberRuntime(fiberState => {\n  fiberState.log(\"\", cause, someInfo);\n  return core.unit();\n}).traced(trace));\n/* @internal */\nexport const logInfoCauseMessage = /*#__PURE__*/Debug.methodWithTrace(trace => (message, cause) => core.withFiberRuntime(fiberState => {\n  fiberState.log(message, cause, someInfo);\n  return core.unit();\n}).traced(trace));\n/* @internal */\nexport const logWarning = /*#__PURE__*/Debug.methodWithTrace(trace => message => core.withFiberRuntime(fiberState => {\n  fiberState.log(message, internalCause.empty, someWarning);\n  return core.unit();\n}).traced(trace));\n/* @internal */\nexport const logWarningCause = /*#__PURE__*/Debug.methodWithTrace(trace => cause => core.withFiberRuntime(fiberState => {\n  fiberState.log(\"\", cause, someWarning);\n  return core.unit();\n}).traced(trace));\n/* @internal */\nexport const logWarningCauseMessage = /*#__PURE__*/Debug.methodWithTrace(trace => (message, cause) => core.withFiberRuntime(fiberState => {\n  fiberState.log(message, cause, someWarning);\n  return core.unit();\n}).traced(trace));\n/* @internal */\nexport const logTrace = /*#__PURE__*/Debug.methodWithTrace(trace => message => core.withFiberRuntime(fiberState => {\n  fiberState.log(message, internalCause.empty, someTrace);\n  return core.unit();\n}).traced(trace));\n/* @internal */\nexport const logTraceCause = /*#__PURE__*/Debug.methodWithTrace(trace => cause => core.withFiberRuntime(fiberState => {\n  fiberState.log(\"\", cause, someTrace);\n  return core.unit();\n}).traced(trace));\n/* @internal */\nexport const logTraceCauseMessage = /*#__PURE__*/Debug.methodWithTrace(trace => (message, cause) => core.withFiberRuntime(fiberState => {\n  fiberState.log(message, cause, someTrace);\n  return core.unit();\n}).traced(trace));\n/* @internal */\nexport const logSpan = /*#__PURE__*/Debug.dualWithTrace(2, trace => (effect, label) => core.flatMap(core.fiberRefGet(core.currentLogSpan), stack => core.flatMap(Clock.currentTimeMillis(), now => core.suspendSucceed(() => {\n  const logSpan = LogSpan.make(label, now);\n  return core.fiberRefLocally(core.currentLogSpan, Chunk.prepend(logSpan)(stack))(effect);\n}))).traced(trace));\n/* @internal */\nexport const logAnnotate = /*#__PURE__*/Debug.dualWithTrace(3, trace => (effect, key, value) => core.flatMap(core.fiberRefGet(core.currentLogAnnotations), annotations => core.suspendSucceed(() => core.fiberRefLocally(core.currentLogAnnotations, HashMap.set(key, value)(annotations))(effect))).traced(trace));\n/* @internal */\nexport const logAnnotations = /*#__PURE__*/Debug.methodWithTrace(trace => () => core.fiberRefGet(core.currentLogAnnotations).traced(trace));\n/* @internal */\nexport const loop = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (initial, cont, inc, body) => loopInternal(initial, restore(cont), restore(inc), restore(body)).traced(trace));\nconst loopInternal = (initial, cont, inc, body) => {\n  return core.suspendSucceed(() => {\n    return cont(initial) ? core.flatMap(body(initial), a => core.map(loopInternal(inc(initial), cont, inc, body), Chunk.prepend(a))) : core.sync(() => Chunk.empty());\n  });\n};\n/* @internal */\nexport const loopDiscard = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (initial, cont, inc, body) => core.suspendSucceed(() => restore(cont)(initial) ? core.flatMap(restore(body)(initial), () => loopDiscard(restore(inc)(initial), restore(cont), restore(inc), restore(body))) : core.unit()).traced(trace));\n/* @internal */\nexport const mapAccum = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (elements, zero, f) => core.suspendSucceed(() => {\n  const iterator = restore(() => elements[Symbol.iterator]())();\n  const builder = [];\n  let result = core.succeed(zero);\n  let next;\n  while (!(next = iterator.next()).done) {\n    result = core.flatMap(state => core.map(([z, b]) => {\n      builder.push(b);\n      return z;\n    })(restore(f)(state, next.value)))(result);\n  }\n  return core.map(result, z => [z, Chunk.unsafeFromArray(builder)]);\n}).traced(trace));\n/* @internal */\nexport const mapBoth = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, f, g) => core.matchEffect(self, e => core.failSync(() => restore(f)(e)), a => core.sync(() => restore(g)(a))).traced(trace));\n/* @internal */\nexport const mapErrorCause = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.matchCauseEffect(self, c => core.failCauseSync(() => restore(f)(c)), core.succeed).traced(trace));\n/* @internal */\nexport const mapTryCatch = /*#__PURE__*/Debug.dualWithTrace(3, trace => (self, f, onThrow) => core.flatMap(self, a => tryCatch(() => f(a), onThrow)).traced(trace));\n/* @internal */\nexport const memoize = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.flatMap(deferred => core.map(complete => core.zipRight(core.flatMap(([patch, a]) => core.as(a)(patchFiberRefs(patch)))(core.deferredAwait(deferred)))(complete))(once(core.intoDeferred(deferred)(diffFiberRefs(self)))))(core.deferredMake()).traced(trace));\n/* @internal */\nexport const merge = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.matchEffect(e => core.succeed(e), core.succeed)(self).traced(trace));\n/* @internal */\nexport const mergeAll = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (elements, zero, f) => Array.from(elements).reduce((acc, a) => core.zipWith(acc, a, restore(f)), core.succeed(zero)).traced(trace));\n/* @internal */\nexport const negate = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.map(b => !b)(self).traced(trace));\n/* @internal */\nexport const none = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.matchEffect(e => core.fail(Option.some(e)), option => {\n  switch (option._tag) {\n    case \"None\":\n      {\n        return core.unit();\n      }\n    case \"Some\":\n      {\n        return core.fail(Option.none());\n      }\n  }\n})(self).traced(trace));\n/* @internal */\nexport const noneOrFail = /*#__PURE__*/Debug.methodWithTrace(trace => option => core.flip(getOrFailDiscard(option)).traced(trace));\n/* @internal */\nexport const noneOrFailWith = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (option, f) => core.mapError(restore(f))(core.flip(getOrFailDiscard(option))).traced(trace));\n/* @internal */\nexport const once = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.map(ref => core.asUnit(core.whenEffect(Ref.getAndSet(ref, false))(self)))(Ref.make(true)).traced(trace));\n/* @internal */\nexport const option = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.matchEffect(() => core.succeed(Option.none()), a => core.succeed(Option.some(a)))(self).traced(trace));\n/* @internal */\nexport const orElseEither = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, that) => core.tryOrElse(self, () => core.map(restore(that)(), Either.right), a => core.succeed(Either.left(a))).traced(trace));\n/* @internal */\nexport const orElseFail = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, evaluate) => core.orElse(self, () => core.failSync(restore(evaluate))).traced(trace));\n/* @internal */\nexport const orElseOptional = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, that) => core.catchAll(self, option => {\n  switch (option._tag) {\n    case \"None\":\n      {\n        return restore(that)();\n      }\n    case \"Some\":\n      {\n        return core.fail(Option.some(option.value));\n      }\n  }\n}).traced(trace));\n/* @internal */\nexport const orElseSucceed = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, evaluate) => core.orElse(self, () => core.sync(restore(evaluate))).traced(trace));\n/* @internal */\nexport const parallelErrors = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.matchCauseEffect(self, cause => {\n  const errors = Chunk.fromIterable(internalCause.failures(cause));\n  return errors.length === 0 ? core.failCause(cause) : core.fail(errors);\n}, core.succeed).traced(trace));\n/* @internal */\nexport const partition = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => core.map(chunk => core.partitionMap(chunk, identity))(core.forEach(elements, a => core.either(restore(f)(a)))).traced(trace));\n/* @internal */\nexport const patchFiberRefs = /*#__PURE__*/Debug.methodWithTrace(trace => patch => updateFiberRefs((fiberId, fiberRefs) => fiberRefsPatch.patch(fiberId, fiberRefs)(patch)).traced(trace));\n/* @internal */\nexport const promise = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => evaluate => core.async(resolve => {\n  restore(evaluate)().then(a => resolve(core.exitSucceed(a))).catch(e => resolve(core.exitDie(e)));\n}).traced(trace));\n/* @internal */\nexport const promiseInterrupt = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => evaluate => core.asyncInterruptEither(resolve => {\n  const controller = new AbortController();\n  restore(evaluate)(controller.signal).then(a => resolve(core.exitSucceed(a))).catch(e => resolve(core.exitDie(e)));\n  return Either.left(core.sync(() => controller.abort()));\n}).traced(trace));\n/* @internal */\nexport const provideService = /*#__PURE__*/Debug.dualWithTrace(3, trace => (self, tag, service) => provideServiceEffect(self, tag, core.succeed(service)).traced(trace));\n/* @internal */\nexport const provideServiceEffect = /*#__PURE__*/Debug.dualWithTrace(3, trace => (self, tag, effect) => core.contextWithEffect(env => core.flatMap(effect, service => core.provideContext(self, Context.add(tag, service)(env)))).traced(trace));\n/* @internal */\nexport const random = /*#__PURE__*/Debug.methodWithTrace(trace => () => randomWith(core.succeed).traced(trace));\n/* @internal */\nexport const randomWith = Random.randomWith;\n/* @internal */\nexport const reduce = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (elements, zero, f) => Array.from(elements).reduce((acc, el) => core.flatMap(acc, a => restore(f)(a, el)), core.succeed(zero)).traced(trace));\n/* @internal */\nexport const reduceAll = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (elements, zero, f) => Array.from(elements).reduce((acc, a) => core.zipWith(acc, a, restore(f)), zero).traced(trace));\n/* @internal */\nexport const reduceRight = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (elements, zero, f) => Array.from(elements).reduceRight((acc, el) => core.flatMap(acc, a => restore(f)(el, a)), core.succeed(zero)).traced(trace));\n/* @internal */\nexport const reduceWhile = /*#__PURE__*/Debug.dualWithTrace(4, (trace, restore) => (elements, zero, predicate, f) => core.flatMap(core.sync(restore(() => elements[Symbol.iterator]())), iterator => reduceWhileLoop(restore, iterator, zero, restore(predicate), restore(f))).traced(trace));\nconst reduceWhileLoop = (restore, iterator, state, predicate, f) => {\n  const next = restore(() => iterator.next())();\n  if (!next.done && predicate(state)) {\n    return core.flatMap(f(state, next.value), nextState => reduceWhileLoop(restore, iterator, nextState, predicate, f));\n  }\n  return core.succeed(state);\n};\n/* @internal */\nexport const refineOrDie = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, pf) => refineOrDieWith(self, pf, identity).traced(trace));\n/* @internal */\nexport const refineOrDieWith = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, pf, f) => core.catchAll(self, e => {\n  const option = restore(pf)(e);\n  switch (option._tag) {\n    case \"None\":\n      {\n        return core.die(restore(f)(e));\n      }\n    case \"Some\":\n      {\n        return core.fail(option.value);\n      }\n  }\n}).traced(trace));\n/* @internal */\nexport const reject = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, pf) => rejectEffect(self, a => Option.map(core.fail)(restore(pf)(a))).traced(trace));\n/* @internal */\nexport const rejectEffect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, pf) => core.flatMap(self, a => {\n  const option = restore(pf)(a);\n  switch (option._tag) {\n    case \"None\":\n      {\n        return core.succeed(a);\n      }\n    case \"Some\":\n      {\n        return core.flatMap(core.fail)(option.value);\n      }\n  }\n}).traced(trace));\n/* @internal */\nexport const repeatN = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, n) => core.suspendSucceed(() => repeatNLoop(self, n)).traced(trace));\n/* @internal */\nconst repeatNLoop = /*#__PURE__*/Debug.methodWithTrace(trace => (self, n) => core.flatMap(self, a => n <= 0 ? core.succeed(a) : core.zipRight(core.yieldNow(), repeatNLoop(self, n - 1))).traced(trace));\n/* @internal */\nexport const replicate = n => {\n  return self => {\n    return Chunk.unsafeFromArray(Array.from({\n      length: n\n    }, () => self));\n  };\n};\n/* @internal */\nexport const replicateEffect = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, n) => collectAll(replicate(n)(self)).traced(trace));\n/* @internal */\nexport const replicateEffectDiscard = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, n) => collectAllDiscard(replicate(n)(self)).traced(trace));\n/* @internal */\nexport const resurrect = /*#__PURE__*/Debug.methodWithTrace(trace => self => unrefineWith(self, Option.some, identity).traced(trace));\n/* @internal */\nexport const right = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.matchEffect(self, e => core.fail(Either.right(e)), either => {\n  switch (either._tag) {\n    case \"Left\":\n      {\n        return core.fail(Either.left(either.left));\n      }\n    case \"Right\":\n      {\n        return core.succeed(either.right);\n      }\n  }\n}).traced(trace));\n/* @internal */\nexport const rightWith = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.suspendSucceed(() => unright(restore(f)(right(self)))).traced(trace));\n/* @internal */\nexport const sandbox = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.matchCauseEffect(self, core.fail, core.succeed).traced(trace));\n/* @internal */\nexport const setFiberRefs = /*#__PURE__*/Debug.methodWithTrace(trace => fiberRefs => core.suspendSucceed(() => FiberRefs.setAll(fiberRefs)).traced(trace));\n/* @internal */\nexport const sleep = Clock.sleep;\n/* @internal */\nexport const someOrElse = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, orElse) => core.map(self, option => {\n  switch (option._tag) {\n    case \"None\":\n      {\n        return restore(orElse)();\n      }\n    case \"Some\":\n      {\n        return option.value;\n      }\n  }\n}).traced(trace));\n/* @internal */\nexport const someOrElseEffect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, orElse) => core.flatMap(self, option => Option.getOrElse(() => restore(orElse)())(Option.map(core.succeed)(option))).traced(trace));\n/* @internal */\nexport const someOrFail = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, orFail) => core.flatMap(self, option => {\n  switch (option._tag) {\n    case \"None\":\n      {\n        return core.flatMap(core.sync(restore(orFail)), core.fail);\n      }\n    case \"Some\":\n      {\n        return core.succeed(option.value);\n      }\n  }\n}).traced(trace));\n/* @internal */\nexport const someOrFailException = /*#__PURE__*/Debug.methodWithTrace(trace => self => someOrFail(self, () => internalCause.NoSuchElementException()).traced(trace));\n/* @internal */\nexport const succeedLeft = /*#__PURE__*/Debug.methodWithTrace(trace => value => core.succeed(Either.left(value)).traced(trace));\n/* @internal */\nexport const succeedNone = /*#__PURE__*/Debug.methodWithTrace(trace => () => core.succeed(Option.none()).traced(trace));\n/* @internal */\nexport const succeedRight = /*#__PURE__*/Debug.methodWithTrace(trace => value => core.succeed(Either.right(value)).traced(trace));\n/* @internal */\nexport const succeedSome = /*#__PURE__*/Debug.methodWithTrace(trace => value => core.succeed(Option.some(value)).traced(trace));\n/* @internal */\nexport const summarized = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, summary, f) => core.flatMap(summary, start => core.flatMap(self, value => core.map(summary, end => [restore(f)(start, end), value]))).traced(trace));\n/* @internal */\nexport const suspend = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => evaluate => core.flatMap(attempt(restore(evaluate)), identity).traced(trace));\n/* @internal */\nexport const struct = /*#__PURE__*/Debug.methodWithTrace(trace => r => core.map(values => {\n  const res = {};\n  for (const [k, v] of values) {\n    res[k] = v;\n  }\n  return res;\n})(core.forEach(Object.entries(r), ([_, e]) => core.map(e, a => [_, a]))).traced(trace));\n/* @internal */\nexport const tagged = /*#__PURE__*/Debug.dualWithTrace(3, trace => (self, key, value) => taggedWithLabels(self, [metricLabel.make(key, value)]).traced(trace));\n/* @internal */\nexport const taggedWithLabels = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, labels) => taggedWithLabelSet(self, HashSet.fromIterable(labels)).traced(trace));\n/* @internal */\nexport const taggedWithLabelSet = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, labels) => core.fiberRefLocallyWith(core.currentTags, set => HashSet.union(labels)(set))(self).traced(trace));\n/* @internal */\nexport const takeWhile = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, predicate) => core.suspendSucceed(() => {\n  const iterator = elements[Symbol.iterator]();\n  const builder = [];\n  let next;\n  let taking = core.succeed(true);\n  while ((next = iterator.next()) && !next.done) {\n    const a = next.value;\n    taking = core.flatMap(taking, taking => core.map(bool => {\n      if (bool) {\n        builder.push(a);\n      }\n      return bool;\n    })(taking ? restore(predicate)(a) : core.succeed(false)));\n  }\n  return core.map(taking, () => Chunk.unsafeFromArray(builder));\n}).traced(trace));\n/* @internal */\nexport const tapBoth = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, f, g) => core.matchCauseEffect(self, cause => {\n  const either = internalCause.failureOrCause(cause);\n  switch (either._tag) {\n    case \"Left\":\n      {\n        return core.zipRight(restore(f)(either.left), core.failCause(cause));\n      }\n    case \"Right\":\n      {\n        return core.failCause(cause);\n      }\n  }\n}, a => core.as(restore(g)(a), a)).traced(trace));\n/* @internal */\nexport const tapDefect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.catchAllCause(self, cause => Option.match(() => core.failCause(cause), a => core.zipRight(restore(f)(a), core.failCause(cause)))(internalCause.keepDefects(cause))).traced(trace));\n/* @internal */\nexport const tapEither = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.matchCauseEffect(self, cause => {\n  const either = internalCause.failureOrCause(cause);\n  switch (either._tag) {\n    case \"Left\":\n      {\n        return core.zipRight(restore(f)(either), core.failCause(cause));\n      }\n    case \"Right\":\n      {\n        return core.failCause(cause);\n      }\n  }\n}, a => core.as(restore(f)(Either.right(a)), a)).traced(trace));\n/* @internal */\nexport const tapError = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.matchCauseEffect(self, cause => {\n  const either = internalCause.failureOrCause(cause);\n  switch (either._tag) {\n    case \"Left\":\n      {\n        return core.zipRight(restore(f)(either.left), core.failCause(cause));\n      }\n    case \"Right\":\n      {\n        return core.failCause(cause);\n      }\n  }\n}, core.succeed).traced(trace));\n/* @internal */\nexport const tapErrorCause = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.matchCauseEffect(self, cause => core.zipRight(restore(f)(cause), core.failCause(cause)), core.succeed).traced(trace));\n/* @internal */\nexport const tapSome = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, pf) => core.tap(self, a => Option.getOrElse(() => core.unit())(Option.map(core.asUnit)(restore(pf)(a)))).traced(trace));\n/* @internal */\nexport const timed = /*#__PURE__*/Debug.methodWithTrace(trace => self => timedWith(self, Clock.currentTimeMillis()).traced(trace));\n/* @internal */\nexport const timedWith = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, milliseconds) => summarized(self, milliseconds, (start, end) => Duration.millis(end - start)).traced(trace));\n/* @internal */\nexport const tryCatch = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (attempt, onThrow) => core.sync(() => {\n  try {\n    return restore(attempt)();\n  } catch (error) {\n    throw core.makeEffectError(internalCause.fail(restore(onThrow)(error)));\n  }\n}).traced(trace));\n/* @internal */\nexport const tryCatchPromise = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (evaluate, onReject) => core.flatMap(tryCatch(restore(evaluate), restore(onReject)), promise => core.async(resolve => {\n  promise.then(a => resolve(core.exitSucceed(a))).catch(e => resolve(core.exitFail(restore(onReject)(e))));\n})).traced(trace));\n/* @internal */\nexport const tryCatchPromiseInterrupt = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (evaluate, onReject) => core.suspendSucceed(() => {\n  const controller = new AbortController();\n  return core.flatMap(promise => core.async(resolve => {\n    promise.then(a => resolve(core.exitSucceed(a))).catch(e => resolve(core.exitFail(restore(onReject)(e))));\n  }))(tryCatch(() => restore(evaluate)(controller.signal), restore(onReject)));\n}).traced(trace));\n/* @internal */\nexport const tryPromise = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => evaluate => core.flatMap(restore(attempt)(evaluate), promise => core.async(resolve => {\n  promise.then(a => resolve(core.exitSucceed(a))).catch(e => resolve(core.exitFail(e)));\n})).traced(trace));\n/* @internal */\nexport const tryPromiseInterrupt = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => evaluate => core.flatMap(([controller, promise]) => core.asyncInterruptEither(resolve => {\n  promise.then(a => resolve(core.exitSucceed(a))).catch(e => resolve(core.exitFail(e)));\n  return Either.left(core.sync(() => controller.abort()));\n}))(attempt(() => {\n  const controller = new AbortController();\n  return [controller, restore(evaluate)(controller.signal)];\n})).traced(trace));\n/* @internal */\nexport const tuple = /*#__PURE__*/Debug.methodWithTrace(trace => (...t) => core.map(collectAll(t), Chunk.toReadonlyArray).traced(trace));\n/* @internal */\nexport const uncause = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.flatMap(self, cause => internalCause.isEmpty(cause) ? core.unit() : core.failCause(cause)).traced(trace));\n/* @internal */\nexport const unfold = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (s, f) => core.map(unfoldLoop(s, restore(f), Chunk.empty()), Chunk.reverse).traced(trace));\n/* @internal */\nconst unfoldLoop = (s, f, builder) => core.flatMap(f(s), option => {\n  if (Option.isSome(option)) {\n    return unfoldLoop(option.value[1], f, Chunk.prepend(option.value[0])(builder));\n  } else {\n    return core.succeed(builder);\n  }\n});\n/* @internal */\nexport const unleft = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.matchEffect(self, either => {\n  switch (either._tag) {\n    case \"Left\":\n      {\n        return core.fail(either.left);\n      }\n    case \"Right\":\n      {\n        return core.succeed(either);\n      }\n  }\n}, a => core.succeed(Either.left(a))).traced(trace));\n/* @internal */\nexport const unless = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, predicate) => core.suspendSucceed(() => restore(predicate)() ? succeedNone() : asSome(self)).traced(trace));\n/* @internal */\nexport const unlessEffect = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, predicate) => core.flatMap(predicate, b => b ? succeedNone() : asSome(self)).traced(trace));\n/* @internal */\nexport const unrefine = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, pf) => unrefineWith(self, restore(pf), identity).traced(trace));\n/* @internal */\nexport const unrefineWith = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, pf, f) => core.catchAllCause(self, cause => {\n  const option = internalCause.find(cause => internalCause.isDieType(cause) ? restore(pf)(cause.defect) : Option.none())(cause);\n  switch (option._tag) {\n    case \"None\":\n      {\n        return core.failCause(internalCause.map(restore(f))(cause));\n      }\n    case \"Some\":\n      {\n        return core.fail(option.value);\n      }\n  }\n}).traced(trace));\n/* @internal */\nexport const unright = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.matchEffect(self, either => {\n  switch (either._tag) {\n    case \"Left\":\n      {\n        return core.succeed(Either.left(either.left));\n      }\n    case \"Right\":\n      {\n        return core.fail(either.right);\n      }\n  }\n}, a => core.succeed(Either.right(a))).traced(trace));\n/* @internal */\nexport const unsandbox = /*#__PURE__*/Debug.methodWithTrace(trace => self => mapErrorCause(self, internalCause.flatten).traced(trace));\n/* @internal */\nexport const updateFiberRefs = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => f => core.withFiberRuntime(state => {\n  state.setFiberRefs(restore(f)(state.id(), state.unsafeGetFiberRefs()));\n  return core.unit();\n}).traced(trace));\n/* @internal */\nexport const updateService = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, tag, f) => core.contramapContext(self, context => Context.add(tag, restore(f)(Context.unsafeGet(context, tag)))(context)).traced(trace));\n/* @internal */\nexport const validate = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => validateWith(self, that, (a, b) => [a, b]).traced(trace));\n/* @internal */\nexport const validateAll = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => core.flatMap(partition(elements, restore(f)), ([es, bs]) => Chunk.isEmpty(es) ? core.succeed(bs) : core.fail(es)).traced(trace));\n/* @internal */\nexport const validateAllDiscard = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => core.flatMap(partition(elements, restore(f)), ([es, _]) => Chunk.isEmpty(es) ? core.unit() : core.fail(es)).traced(trace));\n/* @internal */\nexport const validateFirst = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => core.flip(core.forEach(elements, a => core.flip(restore(f)(a)))).traced(trace));\n/* @internal */\nexport const validateWith = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, that, f) => core.flatten(core.zipWith(core.exit(self), core.exit(that), (ea, eb) => core.exitZipWith(eb, restore(f), (ca, cb) => internalCause.sequential(ca, cb))(ea))).traced(trace));\n/* @internal */\nexport const when = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, predicate) => core.suspendSucceed(() => restore(predicate)() ? core.map(self, Option.some) : core.succeed(Option.none())).traced(trace));\n/* @internal */\nexport const whenCase = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (evaluate, pf) => core.flatMap(core.sync(restore(evaluate)), a => Option.getOrElse(() => succeedNone())(Option.map(asSome)(restore(pf)(a)))).traced(trace));\n/* @internal */\nexport const whenCaseEffect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, pf) => core.flatMap(self, a => whenCase(() => a, restore(pf))).traced(trace));\n/* @internal */\nexport const whenFiberRef = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, fiberRef, predicate) => core.flatMap(core.fiberRefGet(fiberRef), s => restore(predicate)(s) ? core.map(self, a => [s, Option.some(a)]) : core.succeed([s, Option.none()])).traced(trace));\n/* @internal */\nexport const whenRef = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, ref, predicate) => core.flatMap(Ref.get(ref), s => restore(predicate)(s) ? core.map(self, a => [s, Option.some(a)]) : core.succeed([s, Option.none()])).traced(trace));\n/* @internal */\nexport const withMetric = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, metric) => metric(self).traced(trace));\n//# sourceMappingURL=effect.mjs.map","var _a, _b, _c;\nimport * as Equal from \"@fp-ts/data/Equal\";\nimport * as Hash from \"@fp-ts/data/Hash\";\nconst FiberStatusSymbolKey = \"@effect/io/Fiber/Status\";\n/** @internal */\nexport const FiberStatusTypeId = /*#__PURE__*/Symbol.for(FiberStatusSymbolKey);\n/** @internal */\nexport const OP_DONE = \"Done\";\n/** @internal */\nexport const OP_RUNNING = \"Running\";\n/** @internal */\nexport const OP_SUSPENDED = \"Suspended\";\n/** @internal */\nclass Done {\n  constructor() {\n    this[_a] = FiberStatusTypeId;\n    this._tag = OP_DONE;\n  }\n  [(_a = FiberStatusTypeId, Hash.symbol)]() {\n    return Hash.combine(Hash.hash(this._tag))(Hash.hash(FiberStatusSymbolKey));\n  }\n  [Equal.symbol](that) {\n    return isFiberStatus(that) && that._tag === OP_DONE;\n  }\n}\n/** @internal */\nclass Running {\n  constructor(runtimeFlags) {\n    this.runtimeFlags = runtimeFlags;\n    this[_b] = FiberStatusTypeId;\n    this._tag = OP_RUNNING;\n  }\n  [(_b = FiberStatusTypeId, Hash.symbol)]() {\n    return Hash.combine(Hash.hash(this.runtimeFlags))(Hash.combine(Hash.hash(this._tag))(Hash.hash(FiberStatusSymbolKey)));\n  }\n  [Equal.symbol](that) {\n    return isFiberStatus(that) && that._tag === OP_RUNNING && this.runtimeFlags === that.runtimeFlags;\n  }\n}\n/** @internal */\nclass Suspended {\n  constructor(runtimeFlags, blockingOn) {\n    this.runtimeFlags = runtimeFlags;\n    this.blockingOn = blockingOn;\n    this[_c] = FiberStatusTypeId;\n    this._tag = OP_SUSPENDED;\n  }\n  [(_c = FiberStatusTypeId, Hash.symbol)]() {\n    return Hash.combine(Hash.hash(this.blockingOn))(Hash.combine(Hash.hash(this.runtimeFlags))(Hash.combine(Hash.hash(this._tag))(Hash.hash(FiberStatusSymbolKey))));\n  }\n  [Equal.symbol](that) {\n    return isFiberStatus(that) && that._tag === OP_SUSPENDED && this.runtimeFlags === that.runtimeFlags && Equal.equals(this.blockingOn, that.blockingOn);\n  }\n}\n/** @internal */\nexport const done = /*#__PURE__*/new Done();\n/** @internal */\nexport const running = runtimeFlags => new Running(runtimeFlags);\n/** @internal */\nexport const suspended = (runtimeFlags, blockingOn) => new Suspended(runtimeFlags, blockingOn);\n/** @internal */\nexport const isFiberStatus = u => typeof u === \"object\" && u != null && FiberStatusTypeId in u;\n/** @internal */\nexport const isDone = self => self._tag === OP_DONE;\n/** @internal */\nexport const isRunning = self => self._tag === OP_RUNNING;\n/** @internal */\nexport const isSuspended = self => self._tag === OP_SUSPENDED;\n//# sourceMappingURL=fiberStatus.mjs.map","import * as internal from \"@effect/io/internal_effect_untraced/fiberStatus\";\n/**\n * @since 1.0.0\n * @category symbols\n */\nexport const FiberStatusTypeId = internal.FiberStatusTypeId;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const done = internal.done;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const running = internal.running;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const suspended = internal.suspended;\n/**\n * Returns `true` if the specified value is a `FiberStatus`, `false` otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexport const isFiberStatus = internal.isFiberStatus;\n/**\n * Returns `true` if the specified `FiberStatus` is `Done`, `false` otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexport const isDone = internal.isDone;\n/**\n * Returns `true` if the specified `FiberStatus` is `Running`, `false`\n * otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexport const isRunning = internal.isRunning;\n/**\n * Returns `true` if the specified `FiberStatus` is `Suspended`, `false`\n * otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexport const isSuspended = internal.isSuspended;\n//# sourceMappingURL=Status.mjs.map","/** @internal */\nexport const OP_INTERRUPT_SIGNAL = \"InterruptSignal\";\n/** @internal */\nexport const OP_STATEFUL = \"Stateful\";\n/** @internal */\nexport const OP_RESUME = \"Resume\";\n/** @internal */\nexport const OP_YIELD_NOW = \"YieldNow\";\n/** @internal */\nexport const interruptSignal = cause => ({\n  _tag: OP_INTERRUPT_SIGNAL,\n  cause\n});\n/** @internal */\nexport const stateful = onFiber => ({\n  _tag: OP_STATEFUL,\n  onFiber\n});\n/** @internal */\nexport const resume = effect => ({\n  _tag: OP_RESUME,\n  effect\n});\n/** @internal */\nexport const yieldNow = priority => ({\n  _tag: OP_YIELD_NOW,\n  priority\n});\n//# sourceMappingURL=fiberMessage.mjs.map","var _a, _b;\nimport * as FiberId from \"@effect/io/Fiber/Id\";\nimport * as FiberMessage from \"@effect/io/internal_effect_untraced/fiberMessage\";\n/** @internal */\nconst FiberScopeSymbolKey = \"@effect/io/Fiber/Scope\";\n/** @internal */\nexport const FiberScopeTypeId = /*#__PURE__*/Symbol.for(FiberScopeSymbolKey);\nconst globalFiberScopeURI = \"@effect/io/FiberScope/Global\";\n/** @internal */\nclass Global {\n  add(_runtimeFlags, child) {\n    this.roots.add(child);\n    child.unsafeAddObserver(() => {\n      this.roots.delete(child);\n    });\n  }\n  constructor() {\n    this[_a] = FiberScopeTypeId;\n    this.fiberId = FiberId.none;\n    this.roots = new Set();\n    if (typeof globalThis[globalFiberScopeURI] === \"undefined\") {\n      globalThis[globalFiberScopeURI] = this;\n    } else {\n      throw new Error(\"Bug: FiberScope.Global initialized twice (maybe coming from a duplicated module)\");\n    }\n  }\n}\n_a = FiberScopeTypeId;\n/** @internal */\nclass Local {\n  constructor(fiberId, parent) {\n    this.fiberId = fiberId;\n    this.parent = parent;\n    this[_b] = FiberScopeTypeId;\n  }\n  add(_runtimeFlags, child) {\n    this.parent.tell(FiberMessage.stateful(parentFiber => {\n      parentFiber.addChild(child);\n      child.unsafeAddObserver(() => {\n        parentFiber.removeChild(child);\n      });\n    }));\n  }\n}\n_b = FiberScopeTypeId;\n/** @internal */\nexport const unsafeMake = fiber => {\n  return new Local(fiber.id(), fiber);\n};\n/** @internal */\nexport const globalScope = /*#__PURE__*/new Global();\n//# sourceMappingURL=fiberScope.mjs.map","import * as Clock from \"@effect/io/Clock\";\nimport * as Debug from \"@effect/io/Debug\";\nimport * as Exit from \"@effect/io/Exit\";\nimport * as FiberId from \"@effect/io/Fiber/Id\";\nimport * as FiberStatus from \"@effect/io/Fiber/Status\";\nimport * as core from \"@effect/io/internal_effect_untraced/core\";\nimport * as fiberScope from \"@effect/io/internal_effect_untraced/fiberScope\";\nimport * as runtimeFlags from \"@effect/io/internal_effect_untraced/runtimeFlags\";\nimport * as Either from \"@fp-ts/core/Either\";\nimport * as number from \"@fp-ts/core/Number\";\nimport * as Option from \"@fp-ts/core/Option\";\nimport * as order from \"@fp-ts/core/typeclass/Order\";\nimport * as Chunk from \"@fp-ts/data/Chunk\";\nimport * as HashSet from \"@fp-ts/data/HashSet\";\n/** @internal */\nconst FiberSymbolKey = \"@effect/io/Fiber\";\n/** @internal */\nexport const FiberTypeId = /*#__PURE__*/Symbol.for(FiberSymbolKey);\n/** @internal */\nexport const fiberVariance = {\n  _E: _ => _,\n  _A: _ => _\n};\n/** @internal */\nconst RuntimeFiberSymbolKey = \"@effect/io/Fiber\";\n/** @internal */\nexport const RuntimeFiberTypeId = /*#__PURE__*/Symbol.for(RuntimeFiberSymbolKey);\n/** @internal */\nexport const Order = /*#__PURE__*/order.contramap(fiber => [fiber.id().startTimeMillis, fiber.id().id])( /*#__PURE__*/order.tuple(number.Order, number.Order));\n/** @internal */\nexport const isFiber = u => typeof u === \"object\" && u != null && FiberTypeId in u;\n/** @internal */\nexport const isRuntimeFiber = self => RuntimeFiberTypeId in self;\n/** @internal */\nexport const _await = /*#__PURE__*/Debug.methodWithTrace(trace => self => self.await().traced(trace));\n/** @internal */\nexport const children = /*#__PURE__*/Debug.methodWithTrace(trace => self => self.children().traced(trace));\n/** @internal */\nexport const done = exit => ({\n  [FiberTypeId]: fiberVariance,\n  id: () => FiberId.none,\n  await: Debug.methodWithTrace(trace => () => core.succeed(exit).traced(trace)),\n  children: Debug.methodWithTrace(trace => () => core.succeed(Chunk.empty()).traced(trace)),\n  inheritAll: Debug.methodWithTrace(trace => () => core.unit().traced(trace)),\n  poll: Debug.methodWithTrace(trace => () => core.succeed(Option.some(exit)).traced(trace)),\n  interruptAsFork: Debug.methodWithTrace(trace => () => core.unit().traced(trace))\n});\n/** @internal */\nexport const dump = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.map(self.status(), status => ({\n  id: self.id(),\n  status\n})).traced(trace));\n/** @internal */\nexport const dumpAll = /*#__PURE__*/Debug.methodWithTrace(trace => fibers => core.forEach(fibers, dump).traced(trace));\n/** @internal */\nexport const fail = error => {\n  return done(Exit.fail(error));\n};\n/** @internal */\nexport const failCause = cause => {\n  return done(Exit.failCause(cause));\n};\n/** @internal */\nexport const fromEffect = /*#__PURE__*/Debug.methodWithTrace(trace => effect => core.map(core.exit(effect), done).traced(trace));\n/** @internal */\nexport const id = self => {\n  return self.id();\n};\n/** @internal */\nexport const inheritAll = /*#__PURE__*/Debug.methodWithTrace(trace => self => self.inheritAll().traced(trace));\n/** @internal */\nexport const interrupted = fiberId => {\n  return done(Exit.interrupt(fiberId));\n};\n/** @internal */\nexport const interruptAll = /*#__PURE__*/Debug.methodWithTrace(trace => fibers => core.flatMap(core.fiberId(), fiberId => interruptAllWith(fiberId)(fibers)).traced(trace));\n/** @internal */\nexport const interruptAllWith = /*#__PURE__*/Debug.dualWithTrace(2, trace => (fibers, fiberId) => core.zipRight(core.forEachDiscard(_await)(fibers))(core.forEachDiscard(fibers, interruptAsFork(fiberId))).traced(trace));\n/** @internal */\nexport const interruptAsFork = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, fiberId) => self.interruptAsFork(fiberId).traced(trace));\n/** @internal */\nexport const join = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.zipLeft(core.flatten(self.await()), self.inheritAll()).traced(trace));\n/** @internal */\nexport const map = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => mapEffect(self, a => core.sync(() => restore(f)(a))));\n/** @internal */\nexport const mapEffect = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => ({\n  [FiberTypeId]: fiberVariance,\n  id: () => self.id(),\n  await: Debug.methodWithTrace(trace => () => core.flatMap(self.await(), Exit.forEachEffect(f)).traced(trace)),\n  children: Debug.methodWithTrace(trace => () => self.children().traced(trace)),\n  inheritAll: Debug.methodWithTrace(trace => () => self.inheritAll().traced(trace)),\n  poll: Debug.methodWithTrace(trace => () => core.flatMap(self.poll(), result => {\n    switch (result._tag) {\n      case \"None\":\n        {\n          return core.succeed(Option.none());\n        }\n      case \"Some\":\n        {\n          return core.map(Option.some)(Exit.forEachEffect(result.value, restore(f)));\n        }\n    }\n  }).traced(trace)),\n  interruptAsFork: Debug.methodWithTrace(trace => id => self.interruptAsFork(id).traced(trace))\n}));\n/** @internal */\nexport const mapFiber = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.map(self.await(), Exit.match(cause => failCause(cause), a => restore(f)(a))).traced(trace));\n/** @internal */\nexport const match = /*#__PURE__*/Debug.untracedDual(3, restore => (self, onFiber, onRuntimeFiber) => {\n  if (isRuntimeFiber(self)) {\n    return restore(onRuntimeFiber)(self);\n  }\n  return restore(onFiber)(self);\n});\n/** @internal */\nexport const never = () => ({\n  [FiberTypeId]: fiberVariance,\n  id: () => FiberId.none,\n  await: Debug.methodWithTrace(trace => () => core.never().traced(trace)),\n  children: Debug.methodWithTrace(trace => () => core.succeed(Chunk.empty()).traced(trace)),\n  inheritAll: Debug.methodWithTrace(trace => () => core.never().traced(trace)),\n  poll: Debug.methodWithTrace(trace => () => core.succeed(Option.none()).traced(trace)),\n  interruptAsFork: Debug.methodWithTrace(trace => () => core.never().traced(trace))\n});\n/** @internal */\nexport const orElse = /*#__PURE__*/Debug.dual(2, (self, that) => ({\n  [FiberTypeId]: fiberVariance,\n  id: () => FiberId.getOrElse(self.id(), that.id()),\n  await: Debug.methodWithTrace(trace => () => core.zipWith(self.await(), that.await(), (exit1, exit2) => Exit.isSuccess(exit1) ? exit1 : exit2).traced(trace)),\n  children: Debug.methodWithTrace(trace => () => self.children().traced(trace)),\n  inheritAll: Debug.methodWithTrace(trace => () => core.zipRight(that.inheritAll(), self.inheritAll()).traced(trace)),\n  poll: Debug.methodWithTrace(trace => () => core.zipWith(self.poll(), that.poll(), (option1, option2) => {\n    switch (option1._tag) {\n      case \"None\":\n        {\n          return Option.none();\n        }\n      case \"Some\":\n        {\n          return Exit.isSuccess(option1.value) ? option1 : option2;\n        }\n    }\n  }).traced(trace)),\n  interruptAsFork: Debug.methodWithTrace(trace => id => core.asUnit(core.zipRight(core.interruptAsFiber(id)(that))(core.interruptAsFiber(self, id))).traced(trace))\n}));\n/** @internal */\nexport const orElseEither = /*#__PURE__*/Debug.dual(2, (self, that) => orElse(map(self, Either.left), map(that, Either.right)));\n/** @internal */\nexport const poll = /*#__PURE__*/Debug.methodWithTrace(trace => self => self.poll().traced(trace));\n// forked from https://github.com/sindresorhus/parse-ms/blob/4da2ffbdba02c6e288c08236695bdece0adca173/index.js\n// MIT License\n// Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)\n/** @internal */\nconst parseMs = milliseconds => {\n  const roundTowardsZero = milliseconds > 0 ? Math.floor : Math.ceil;\n  return {\n    days: roundTowardsZero(milliseconds / 86400000),\n    hours: roundTowardsZero(milliseconds / 3600000) % 24,\n    minutes: roundTowardsZero(milliseconds / 60000) % 60,\n    seconds: roundTowardsZero(milliseconds / 1000) % 60,\n    milliseconds: roundTowardsZero(milliseconds) % 1000,\n    microseconds: roundTowardsZero(milliseconds * 1000) % 1000,\n    nanoseconds: roundTowardsZero(milliseconds * 1e6) % 1000\n  };\n};\n/** @internal */\nconst renderStatus = status => {\n  if (FiberStatus.isDone(status)) {\n    return \"Done\";\n  }\n  if (FiberStatus.isRunning(status)) {\n    return \"Running\";\n  }\n  const isInterruptible = runtimeFlags.interruptible(status.runtimeFlags) ? \"interruptible\" : \"uninterruptible\";\n  return `Suspended(${isInterruptible})`;\n};\n/** @internal */\nexport const pretty = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.flatMap(Clock.currentTimeMillis(), now => core.map(dump(self), dump => {\n  const time = now - dump.id.startTimeMillis;\n  const {\n    days,\n    hours,\n    milliseconds,\n    minutes,\n    seconds\n  } = parseMs(time);\n  const lifeMsg = (days === 0 ? \"\" : `${days}d`) + (days === 0 && hours === 0 ? \"\" : `${hours}h`) + (days === 0 && hours === 0 && minutes === 0 ? \"\" : `${minutes}m`) + (days === 0 && hours === 0 && minutes === 0 && seconds === 0 ? \"\" : `${seconds}s`) + `${milliseconds}ms`;\n  const waitMsg = FiberStatus.isSuspended(dump.status) ? (() => {\n    const ids = FiberId.ids(dump.status.blockingOn);\n    return HashSet.size(ids) > 0 ? `waiting on ` + Array.from(ids).map(id => `${id}`).join(\", \") : \"\";\n  })() : \"\";\n  const statusMsg = renderStatus(dump.status);\n  return `[Fiber](#${dump.id.id}) (${lifeMsg}) ${waitMsg}\\n   Status: ${statusMsg}`;\n})).traced(trace));\n/** @internal */\nexport const roots = /*#__PURE__*/Debug.methodWithTrace(trace => () => core.sync(unsafeRoots).traced(trace));\n/** @internal */\nexport const unsafeRoots = () => {\n  return Chunk.fromIterable(fiberScope.globalScope.roots);\n};\n/** @internal */\nexport const status = /*#__PURE__*/Debug.methodWithTrace(trace => self => self.status().traced(trace));\n/** @internal */\nexport const succeed = value => {\n  return done(Exit.succeed(value));\n};\n/** @internal */\nexport const unit = () => succeed(void 0);\n/** @internal */\nexport const currentFiberURI = \"@effect/io/Fiber/Current\";\n/** @internal */\nexport const getCurrentFiber = () => Option.fromNullable(global[currentFiberURI]);\n//# sourceMappingURL=fiber.mjs.map","import * as core from \"@effect/io/internal_effect_untraced/core\";\nimport * as internal from \"@effect/io/internal_effect_untraced/deferred\";\n/**\n * @since 1.0.0\n * @category symbols\n */\nexport const DeferredTypeId = internal.DeferredTypeId;\n/**\n * Creates a new `Deferred`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const make = core.deferredMake;\n/**\n * Creates a new `Deferred` from the specified `FiberId`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const makeAs = core.deferredMakeAs;\nconst _await = core.deferredAwait;\nexport {\n/**\n * Retrieves the value of the `Deferred`, suspending the fiber running the\n * workflow until the result is available.\n *\n * @since 1.0.0\n * @category getters\n */\n_await as await };\n/**\n * Completes the deferred with the result of the specified effect. If the\n * deferred has already been completed, the method will produce false.\n *\n * Note that `Deferred.completeWith` will be much faster, so consider using\n * that if you do not need to memoize the result of the specified effect.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const complete = core.deferredComplete;\n/**\n * Completes the deferred with the result of the specified effect. If the\n * deferred has already been completed, the method will produce false.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const completeWith = core.deferredCompleteWith;\n/**\n * Exits the `Deferred` with the specified `Exit` value, which will be\n * propagated to all fibers waiting on the value of the `Deferred`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const done = core.deferredDone;\n/**\n * Fails the `Deferred` with the specified error, which will be propagated to\n * all fibers waiting on the value of the `Deferred`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const fail = core.deferredFail;\n/**\n * Fails the `Deferred` with the specified error, which will be propagated to\n * all fibers waiting on the value of the `Deferred`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const failSync = core.deferredFailSync;\n/**\n * Fails the `Deferred` with the specified `Cause`, which will be propagated to\n * all fibers waiting on the value of the `Deferred`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const failCause = core.deferredFailCause;\n/**\n * Fails the `Deferred` with the specified `Cause`, which will be propagated to\n * all fibers waiting on the value of the `Deferred`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const failCauseSync = core.deferredFailCauseSync;\n/**\n * Kills the `Deferred` with the specified defect, which will be propagated to\n * all fibers waiting on the value of the `Deferred`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const die = core.deferredDie;\n/**\n * Kills the `Deferred` with the specified defect, which will be propagated to\n * all fibers waiting on the value of the `Deferred`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const dieSync = core.deferredDieSync;\n/**\n * Completes the `Deferred` with interruption. This will interrupt all fibers\n * waiting on the value of the `Deferred` with the `FiberId` of the fiber\n * calling this method.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const interrupt = core.deferredInterrupt;\n/**\n * Completes the `Deferred` with interruption. This will interrupt all fibers\n * waiting on the value of the `Deferred` with the specified `FiberId`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const interruptWith = core.deferredInterruptWith;\n/**\n * Returns `true` if this `Deferred` has already been completed with a value or\n * an error, `false` otherwise.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const isDone = core.deferredIsDone;\n/**\n * Returns a `Some<Effect<R, E, A>>` from the `Deferred` if this `Deferred` has\n * already been completed, `None` otherwise.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const poll = core.deferredPoll;\n/**\n * Completes the `Deferred` with the specified value.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const succeed = core.deferredSucceed;\n/**\n * Completes the `Deferred` with the specified value.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const sync = core.deferredSync;\n/**\n * Unsafely creates a new `Deferred` from the specified `FiberId`.\n *\n * @since 1.0.0\n * @category unsafe\n */\nexport const unsafeMake = core.deferredUnsafeMake;\n/**\n * Unsafely exits the `Deferred` with the specified `Exit` value, which will be\n * propagated to all fibers waiting on the value of the `Deferred`.\n *\n * @since 1.0.0\n * @category unsafe\n */\nexport const unsafeDone = core.deferredUnsafeDone;\n//# sourceMappingURL=Deferred.mjs.map","import * as Debug from \"@effect/io/Debug\";\nimport * as Exit from \"@effect/io/Exit\";\nimport * as Cause from \"@effect/io/internal_effect_untraced/cause\";\nimport * as Pretty from \"@effect/io/internal_effect_untraced/cause-pretty\";\nimport * as _fiberId from \"@effect/io/internal_effect_untraced/fiberId\";\nimport * as OpCodes from \"@effect/io/internal_effect_untraced/opCodes/effect\";\nimport * as _scheduler from \"@effect/io/internal_effect_untraced/scheduler\";\nimport * as LogSpan from \"@effect/io/Logger/Span\";\nimport { constVoid, identity } from \"@fp-ts/core/Function\";\nimport * as Option from \"@fp-ts/core/Option\";\nimport * as Chunk from \"@fp-ts/data/Chunk\";\nimport * as HashMap from \"@fp-ts/data/HashMap\";\n/** @internal */\nconst LoggerSymbolKey = \"@effect/io/Logger\";\n/** @internal */\nexport const LoggerTypeId = /*#__PURE__*/Symbol.for(LoggerSymbolKey);\n/** @internal */\nconst loggerVariance = {\n  _Message: _ => _,\n  _Output: _ => _\n};\n/** @internal */\nexport const makeLogger = log => ({\n  [LoggerTypeId]: loggerVariance,\n  log\n});\n/** @internal */\nexport const stringLogger = /*#__PURE__*/makeLogger((fiberId, logLevel, message, cause, _context, spans, annotations, runtime) => {\n  const now = new Date();\n  const nowMillis = now.getTime();\n  const outputArray = [`timestamp=${now.toISOString()}`, `level=${logLevel.label}`, `fiber=${_fiberId.threadName(fiberId)}`];\n  let output = outputArray.join(\" \");\n  if (message.length > 0) {\n    output = output + \" message=\";\n    output = appendQuoted(message, output);\n  }\n  if (cause != null && cause != Cause.empty) {\n    output = output + \" cause=\";\n    output = appendQuoted(unsafeRunSync(runtime)(Pretty.prettySafe(cause)), output);\n  }\n  if (Chunk.isNonEmpty(spans)) {\n    output = output + \" \";\n    let first = true;\n    for (const span of spans) {\n      if (first) {\n        first = false;\n      } else {\n        output = output + \" \";\n      }\n      output = output + LogSpan.render(nowMillis)(span);\n    }\n  }\n  if (HashMap.size(annotations) > 0) {\n    output = output + \" \";\n    let first = true;\n    for (const [key, value] of annotations) {\n      if (first) {\n        first = false;\n      } else {\n        output = output + \" \";\n      }\n      output = output + filterKeyName(key);\n      output = output + \"=\";\n      output = appendQuoted(value, output);\n    }\n  }\n  return output;\n});\n/** @internal */\nconst escapeDoubleQuotes = str => `\"${str.replace(/\\\\([\\s\\S])|(\")/g, \"\\\\$1$2\")}\"`;\nconst textOnly = /^[^\\s\"=]+$/;\n/** @internal */\nconst appendQuoted = (label, output) => output + (label.match(textOnly) ? label : escapeDoubleQuotes(label));\n/** @internal */\nexport const logfmtLogger = /*#__PURE__*/makeLogger((fiberId, logLevel, message, cause, _context, spans, annotations, runtime) => {\n  const now = new Date();\n  const nowMillis = now.getTime();\n  const outputArray = [`timestamp=${now.toISOString()}`, `level=${logLevel.label}`, `fiber=${_fiberId.threadName(fiberId)}`];\n  let output = outputArray.join(\" \");\n  if (message.length > 0) {\n    output = output + \" message=\";\n    output = appendQuotedLogfmt(message, output);\n  }\n  if (cause != null && cause != Cause.empty) {\n    output = output + \" cause=\";\n    output = appendQuotedLogfmt(unsafeRunSync(runtime)(Pretty.prettySafe(cause)), output);\n  }\n  if (Chunk.isNonEmpty(spans)) {\n    output = output + \" \";\n    let first = true;\n    for (const span of spans) {\n      if (first) {\n        first = false;\n      } else {\n        output = output + \" \";\n      }\n      output = output + renderLogSpanLogfmt(nowMillis)(span);\n    }\n  }\n  if (HashMap.size(annotations) > 0) {\n    output = output + \" \";\n    let first = true;\n    for (const [key, value] of annotations) {\n      if (first) {\n        first = false;\n      } else {\n        output = output + \" \";\n      }\n      output = output + filterKeyName(key);\n      output = output + \"=\";\n      output = appendQuotedLogfmt(value, output);\n    }\n  }\n  return output;\n});\n/** @internal */\nconst filterKeyName = key => key.replace(/[\\s=\"]/g, \"_\");\n/** @internal */\nconst escapeDoubleQuotesLogfmt = str => JSON.stringify(str);\n/** @internal */\nconst appendQuotedLogfmt = (label, output) => output + (label.match(textOnly) ? label : escapeDoubleQuotesLogfmt(label));\n/** @internal */\nconst renderLogSpanLogfmt = now => self => {\n  const label = filterKeyName(self.label);\n  return `${label}=${now - self.startTime}ms`;\n};\n/** @internal */\nexport const contramap = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => makeLogger((fiberId, logLevel, message, cause, context, spans, annotations, runtime) => self.log(fiberId, logLevel, restore(f)(message), cause, context, spans, annotations, runtime)));\n/** @internal */\nexport const filterLogLevel = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => makeLogger((fiberId, logLevel, message, cause, context, spans, annotations, runtime) => restore(f)(logLevel) ? Option.some(self.log(fiberId, logLevel, message, cause, context, spans, annotations, runtime)) : Option.none()));\n/** @internal */\nexport const map = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => makeLogger((fiberId, logLevel, message, cause, context, spans, annotations, runtime) => restore(f)(self.log(fiberId, logLevel, message, cause, context, spans, annotations, runtime))));\n/** @internal */\nexport const none = () => ({\n  [LoggerTypeId]: loggerVariance,\n  log: constVoid\n});\n/** @internal */\nexport const simple = log => ({\n  [LoggerTypeId]: loggerVariance,\n  log: (_fiberId, _logLevel, message, _cause, _context, _spans, _annotations) => {\n    return log(message);\n  }\n});\n/** @internal */\nexport const succeed = value => {\n  return simple(() => value);\n};\n/** @internal */\nexport const sync = evaluate => {\n  return simple(evaluate);\n};\n/** @internal */\nexport const zip = /*#__PURE__*/Debug.dual(2, (self, that) => makeLogger((fiberId, logLevel, message, cause, context, spans, annotations, runtime) => [self.log(fiberId, logLevel, message, cause, context, spans, annotations, runtime), that.log(fiberId, logLevel, message, cause, context, spans, annotations, runtime)]));\n/** @internal */\nexport const zipLeft = /*#__PURE__*/Debug.dual(2, (self, that) => map(zip(self, that), tuple => tuple[0]));\n/** @internal */\nexport const zipRight = /*#__PURE__*/Debug.dual(2, (self, that) => map(zip(self, that), tuple => tuple[1]));\n// circular with runtime\n/** @internal */\nexport const unsafeRunSyncExit = runtime => effect => {\n  const scheduler = new _scheduler.SyncScheduler();\n  const fiberRuntime = runtime.unsafeFork(effect, scheduler);\n  scheduler.flush();\n  const result = fiberRuntime.unsafePoll();\n  if (result) {\n    return result;\n  }\n  return Exit.die(new AsyncFiber(fiberRuntime));\n};\n/** @internal */\nexport class AsyncFiber {\n  constructor(fiber) {\n    this.fiber = fiber;\n    this._tag = \"AsyncFiber\";\n  }\n}\n/** @internal */\nexport const unsafeRunSync = runtime => effect => {\n  const exit = unsafeRunSyncExit(runtime)(effect);\n  if (exit._tag === OpCodes.OP_FAILURE) {\n    throw Cause.squashWith(identity)(exit.cause);\n  }\n  return exit.value;\n};\n//# sourceMappingURL=logger.mjs.map","/**\n * fork of https://github.com/astoilkov/main-thread-scheduling\n *\n * node compatibility\n * removal of visible priority\n * reversal of task order\n */\n/** @internal */\nfunction whenReady() {\n  const observers = [];\n  const promise = () => new Promise(resolve => observers.push(resolve));\n  return {\n    promise,\n    resolve: value => observers.forEach(observer => observer(value))\n  };\n}\n/** @internal */\nconst state = {\n  tasks: [],\n  idleDeadline: undefined,\n  frameTimeElapsed: false,\n  onIdleCallback: /*#__PURE__*/whenReady(),\n  onAnimationFrame: /*#__PURE__*/whenReady(),\n  frameWorkStartTime: undefined\n};\n/** @internal */\nfunction createTask() {\n  const wr = whenReady();\n  const item = {\n    ready: wr.promise,\n    resolve: wr.resolve\n  };\n  state.tasks.push(item);\n  if (state.tasks.length === 1) {\n    startTracking();\n  }\n  return item;\n}\nlet isTracking = false;\nlet idleCallbackId;\n/** @internal */\nfunction startTracking() {\n  if (isTracking) {\n    return;\n  }\n  isTracking = true;\n  const reset = () => {\n    state.idleDeadline = undefined;\n    state.frameTimeElapsed = false;\n    state.frameWorkStartTime = undefined;\n  };\n  const loop = () => {\n    // @ts-expect-error\n    if (typeof requestIdleCallback !== \"undefined\") {\n      // @ts-expect-error\n      idleCallbackId = requestIdleCallback(deadline => {\n        reset();\n        state.idleDeadline = deadline;\n        state.onIdleCallback.resolve();\n        state.onIdleCallback = whenReady();\n      });\n    }\n    const cb = () => {\n      reset();\n      state.onAnimationFrame.resolve();\n      state.onAnimationFrame = whenReady();\n      if (state.tasks.length === 0) {\n        isTracking = false;\n        if (typeof cancelIdleCallback !== \"undefined\") {\n          cancelIdleCallback(idleCallbackId);\n        }\n      } else {\n        loop();\n      }\n    };\n    // @ts-expect-error\n    if (typeof requestAnimationFrame !== \"undefined\") {\n      // @ts-expect-error\n      requestAnimationFrame(cb);\n    } else {\n      setTimeout(cb, 16);\n    }\n  };\n  loop();\n}\n/** @internal */\nfunction removeTask(task) {\n  const index = state.tasks.indexOf(task);\n  if (index !== -1) {\n    state.tasks.splice(index, 1);\n  }\n}\n/** @internal */\nfunction nextTask() {\n  if (state.tasks.length > 0) {\n    state.tasks[0].resolve();\n  }\n}\n/** @internal */\nlet lastCallTime = 0;\n/** @internal */\nlet lastResult = false;\n/** @internal */\nfunction isTimeToYield() {\n  const now = Date.now();\n  if (!lastResult && now - lastCallTime === 0) {\n    return lastResult;\n  }\n  lastCallTime = now;\n  lastResult = now >= calculateDeadline() ||\n  // @ts-expect-error\n  typeof navigator !== \"undefined\" && navigator.scheduling?.isInputPending?.() === true;\n  if (lastResult) {\n    state.frameTimeElapsed = true;\n  }\n  return lastResult;\n}\n/** @internal */\nfunction calculateDeadline() {\n  if (state.frameWorkStartTime === undefined) {\n    return -1;\n  }\n  const idleDeadline = state.idleDeadline === undefined ? Number.MAX_SAFE_INTEGER : Date.now() + state.idleDeadline.timeRemaining();\n  return Math.min(state.frameWorkStartTime + 5, idleDeadline);\n}\nlet globalId = 0;\nconst running = /*#__PURE__*/new Set();\n/** @internal */\nfunction requestPromiseEscape(callback) {\n  const id = globalId;\n  running.add(id);\n  Promise.resolve().then(() => {\n    Promise.resolve().then(() => {\n      if (running.has(id)) {\n        callback();\n        running.delete(id);\n      }\n    });\n  });\n  globalId += 1;\n  return id;\n}\n/** @internal */\nfunction cancelPromiseEscape(id) {\n  if (id !== undefined) {\n    running.delete(id);\n  }\n}\n/** @internal */\nlet callbacks = [];\n/** @internal */\nfunction requestNextTask(callback) {\n  if (callbacks.length === 0) {\n    const channel = new MessageChannel();\n    channel.port2.postMessage(undefined);\n    // @ts-expect-error\n    channel.port1.onmessage = () => {\n      channel.port1.close();\n      channel.port2.close();\n      const callbacksCopy = callbacks;\n      callbacks = [];\n      for (const callback of callbacksCopy) {\n        callback();\n      }\n    };\n  }\n  callbacks.push(callback);\n}\nlet promiseEscapeId;\n/** @internal */\nasync function yieldControl() {\n  cancelPromiseEscape(promiseEscapeId);\n  const task = createTask();\n  await schedule();\n  if (state.tasks[0] !== task) {\n    await task.ready();\n    if (isTimeToYield()) {\n      await schedule();\n    }\n  }\n  removeTask(task);\n  cancelPromiseEscape(promiseEscapeId);\n  promiseEscapeId = requestPromiseEscape(() => {\n    nextTask();\n  });\n}\nasync function schedule() {\n  if (state.frameTimeElapsed) {\n    await state.onAnimationFrame.promise();\n  }\n  // @ts-expect-error\n  if (typeof requestIdleCallback === \"undefined\") {\n    await new Promise(resolve => requestNextTask(resolve));\n    // @ts-expect-error\n    if (typeof navigator !== \"undefined\" && navigator.scheduling?.isInputPending?.() === true) {\n      await schedule();\n    } else if (state.frameWorkStartTime === undefined) {\n      state.frameWorkStartTime = Date.now();\n    }\n  } else {\n    await state.onIdleCallback.promise();\n    if (state.frameWorkStartTime === undefined) {\n      state.frameWorkStartTime = Date.now();\n    }\n  }\n}\n/** @internal */\nexport function yieldBackgroundOrContinue() {\n  if (isTimeToYield()) {\n    return yieldControl();\n  }\n  return Promise.resolve();\n}\n//# sourceMappingURL=main-thread.mjs.map","var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\nimport * as Equal from \"@fp-ts/data/Equal\";\nimport * as Hash from \"@fp-ts/data/Hash\";\n/** @internal */\nconst MetricKeyTypeSymbolKey = \"@effect/io/Metric/KeyType\";\n/** @internal */\nexport const MetricKeyTypeTypeId = /*#__PURE__*/Symbol.for(MetricKeyTypeSymbolKey);\n/** @internal */\nconst CounterKeyTypeSymbolKey = \"effect/io/Metric/KeyType/Counter\";\n/** @internal */\nexport const CounterKeyTypeTypeId = /*#__PURE__*/Symbol.for(CounterKeyTypeSymbolKey);\n/** @internal */\nconst FrequencyKeyTypeSymbolKey = \"effect/io/Metric/KeyType/Frequency\";\n/** @internal */\nexport const FrequencyKeyTypeTypeId = /*#__PURE__*/Symbol.for(FrequencyKeyTypeSymbolKey);\n/** @internal */\nconst GaugeKeyTypeSymbolKey = \"effect/io/Metric/KeyType/Gauge\";\n/** @internal */\nexport const GaugeKeyTypeTypeId = /*#__PURE__*/Symbol.for(GaugeKeyTypeSymbolKey);\n/** @internal */\nconst HistogramKeyTypeSymbolKey = \"effect/io/Metric/KeyType/Histogram\";\n/** @internal */\nexport const HistogramKeyTypeTypeId = /*#__PURE__*/Symbol.for(HistogramKeyTypeSymbolKey);\n/** @internal */\nconst SummaryKeyTypeSymbolKey = \"effect/io/Metric/KeyType/Summary\";\n/** @internal */\nexport const SummaryKeyTypeTypeId = /*#__PURE__*/Symbol.for(SummaryKeyTypeSymbolKey);\n/** @internal */\nconst metricKeyTypeVariance = {\n  _In: _ => _,\n  _Out: _ => _\n};\n/** @internal */\nclass CounterKeyType {\n  constructor() {\n    this[_a] = metricKeyTypeVariance;\n    this[_b] = CounterKeyTypeTypeId;\n  }\n  [(_a = MetricKeyTypeTypeId, _b = CounterKeyTypeTypeId, Hash.symbol)]() {\n    return Hash.hash(CounterKeyTypeSymbolKey);\n  }\n  [Equal.symbol](that) {\n    return isCounterKey(that);\n  }\n}\n/** @internal */\nclass FrequencyKeyType {\n  constructor() {\n    this[_c] = metricKeyTypeVariance;\n    this[_d] = FrequencyKeyTypeTypeId;\n  }\n  [(_c = MetricKeyTypeTypeId, _d = FrequencyKeyTypeTypeId, Hash.symbol)]() {\n    return Hash.hash(FrequencyKeyTypeSymbolKey);\n  }\n  [Equal.symbol](that) {\n    return isFrequencyKey(that);\n  }\n}\n/** @internal */\nclass GaugeKeyType {\n  constructor() {\n    this[_e] = metricKeyTypeVariance;\n    this[_f] = GaugeKeyTypeTypeId;\n  }\n  [(_e = MetricKeyTypeTypeId, _f = GaugeKeyTypeTypeId, Hash.symbol)]() {\n    return Hash.hash(GaugeKeyTypeSymbolKey);\n  }\n  [Equal.symbol](that) {\n    return isGaugeKey(that);\n  }\n}\n/**\n * @category model\n * @since 1.0.0\n */\nexport class HistogramKeyType {\n  constructor(boundaries) {\n    this.boundaries = boundaries;\n    this[_g] = metricKeyTypeVariance;\n    this[_h] = HistogramKeyTypeTypeId;\n  }\n  [(_g = MetricKeyTypeTypeId, _h = HistogramKeyTypeTypeId, Hash.symbol)]() {\n    return Hash.combine(Hash.hash(this.boundaries))(Hash.hash(HistogramKeyTypeSymbolKey));\n  }\n  [Equal.symbol](that) {\n    return isHistogramKey(that) && Equal.equals(this.boundaries, that.boundaries);\n  }\n}\n/** @internal */\nclass SummaryKeyType {\n  constructor(maxAge, maxSize, error, quantiles) {\n    this.maxAge = maxAge;\n    this.maxSize = maxSize;\n    this.error = error;\n    this.quantiles = quantiles;\n    this[_j] = metricKeyTypeVariance;\n    this[_k] = SummaryKeyTypeTypeId;\n  }\n  [(_j = MetricKeyTypeTypeId, _k = SummaryKeyTypeTypeId, Hash.symbol)]() {\n    return Hash.combine(Hash.hash(this.quantiles))(Hash.combine(Hash.hash(this.error))(Hash.combine(Hash.hash(this.maxSize))(Hash.combine(Hash.hash(this.maxAge))(Hash.hash(SummaryKeyTypeSymbolKey)))));\n  }\n  [Equal.symbol](that) {\n    return isSummaryKey(that) && Equal.equals(this.maxAge, that.maxAge) && this.maxSize === that.maxSize && this.error === that.error && Equal.equals(this.quantiles, that.quantiles);\n  }\n}\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const counter = /*#__PURE__*/new CounterKeyType();\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const frequency = /*#__PURE__*/new FrequencyKeyType();\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const gauge = /*#__PURE__*/new GaugeKeyType();\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const histogram = boundaries => {\n  return new HistogramKeyType(boundaries);\n};\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const summary = (maxAge, maxSize, error, quantiles) => {\n  return new SummaryKeyType(maxAge, maxSize, error, quantiles);\n};\n/**\n * @since 1.0.0\n * @category refinements\n */\nexport const isMetricKeyType = u => {\n  return typeof u === \"object\" && u != null && MetricKeyTypeTypeId in u;\n};\n/**\n * @since 1.0.0\n * @category refinements\n */\nexport const isCounterKey = u => {\n  return typeof u === \"object\" && u != null && CounterKeyTypeTypeId in u;\n};\n/**\n * @since 1.0.0\n * @category refinements\n */\nexport const isFrequencyKey = u => {\n  return typeof u === \"object\" && u != null && FrequencyKeyTypeTypeId in u;\n};\n/**\n * @since 1.0.0\n * @category refinements\n */\nexport const isGaugeKey = u => {\n  return typeof u === \"object\" && u != null && GaugeKeyTypeTypeId in u;\n};\n/**\n * @since 1.0.0\n * @category refinements\n */\nexport const isHistogramKey = u => {\n  return typeof u === \"object\" && u != null && HistogramKeyTypeTypeId in u;\n};\n/**\n * @since 1.0.0\n * @category refinements\n */\nexport const isSummaryKey = u => {\n  return typeof u === \"object\" && u != null && SummaryKeyTypeTypeId in u;\n};\n//# sourceMappingURL=keyType.mjs.map","var _a;\nimport * as Debug from \"@effect/io/Debug\";\nimport * as metricKeyType from \"@effect/io/internal_effect_untraced/metric/keyType\";\nimport * as metricLabel from \"@effect/io/internal_effect_untraced/metric/label\";\nimport * as Equal from \"@fp-ts/data/Equal\";\nimport * as Hash from \"@fp-ts/data/Hash\";\nimport * as HashSet from \"@fp-ts/data/HashSet\";\n/** @internal */\nconst MetricKeySymbolKey = \"@effect/io/Metric/Key\";\n/** @internal */\nexport const MetricKeyTypeId = /*#__PURE__*/Symbol.for(MetricKeySymbolKey);\n/** @internal */\nconst metricKeyVariance = {\n  _Type: _ => _\n};\n/** @internal */\nclass MetricKeyImpl {\n  constructor(name, keyType, tags = HashSet.empty()) {\n    this.name = name;\n    this.keyType = keyType;\n    this.tags = tags;\n    this[_a] = metricKeyVariance;\n  }\n  [(_a = MetricKeyTypeId, Hash.symbol)]() {\n    return Hash.combine(Hash.hash(this.tags))(Hash.combine(Hash.hash(this.keyType))(Hash.hash(this.name)));\n  }\n  [Equal.symbol](u) {\n    return isMetricKey(u) && this.name === u.name && Equal.equals(this.keyType, u.keyType) && Equal.equals(this.tags, u.tags);\n  }\n}\n/** @internal */\nexport const isMetricKey = u => {\n  return typeof u === \"object\" && u != null && MetricKeyTypeId in u;\n};\n/** @internal */\nexport const counter = name => {\n  return new MetricKeyImpl(name, metricKeyType.counter);\n};\n/** @internal */\nexport const frequency = name => {\n  return new MetricKeyImpl(name, metricKeyType.frequency);\n};\n/** @internal */\nexport const gauge = name => {\n  return new MetricKeyImpl(name, metricKeyType.gauge);\n};\n/** @internal */\nexport const histogram = (name, boundaries) => {\n  return new MetricKeyImpl(name, metricKeyType.histogram(boundaries));\n};\n/** @internal */\nexport const summary = (name, maxAge, maxSize, error, quantiles) => {\n  return new MetricKeyImpl(name, metricKeyType.summary(maxAge, maxSize, error, quantiles));\n};\n/** @internal */\nexport const tagged = /*#__PURE__*/Debug.dual(3, (self, key, value) => taggedWithLabelSet(self, HashSet.make(metricLabel.make(key, value))));\n/** @internal */\nexport const taggedWithLabels = /*#__PURE__*/Debug.dual(2, (self, extraTags) => taggedWithLabelSet(self, HashSet.fromIterable(extraTags)));\n/** @internal */\nexport const taggedWithLabelSet = /*#__PURE__*/Debug.dual(2, (self, extraTags) => HashSet.size(extraTags) === 0 ? self : new MetricKeyImpl(self.name, self.keyType, HashSet.union(extraTags)(self.tags)));\n//# sourceMappingURL=key.mjs.map","var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\nimport * as Equal from \"@fp-ts/data/Equal\";\nimport * as Hash from \"@fp-ts/data/Hash\";\n/** @internal */\nconst MetricStateSymbolKey = \"@effect/io/Metric/State\";\n/** @internal */\nexport const MetricStateTypeId = /*#__PURE__*/Symbol.for(MetricStateSymbolKey);\n/** @internal */\nconst CounterStateSymbolKey = \"effect/io/Metric/State/Counter\";\n/** @internal */\nexport const CounterStateTypeId = /*#__PURE__*/Symbol.for(CounterStateSymbolKey);\n/** @internal */\nconst FrequencyStateSymbolKey = \"effect/io/Metric/State/Frequency\";\n/** @internal */\nexport const FrequencyStateTypeId = /*#__PURE__*/Symbol.for(FrequencyStateSymbolKey);\n/** @internal */\nconst GaugeStateSymbolKey = \"effect/io/Metric/State/Gauge\";\n/** @internal */\nexport const GaugeStateTypeId = /*#__PURE__*/Symbol.for(GaugeStateSymbolKey);\n/** @internal */\nconst HistogramStateSymbolKey = \"effect/io/Metric/State/Histogram\";\n/** @internal */\nexport const HistogramStateTypeId = /*#__PURE__*/Symbol.for(HistogramStateSymbolKey);\n/** @internal */\nconst SummaryStateSymbolKey = \"effect/io/Metric/State/Summary\";\n/** @internal */\nexport const SummaryStateTypeId = /*#__PURE__*/Symbol.for(SummaryStateSymbolKey);\n/** @internal */\nconst metricStateVariance = {\n  _A: _ => _\n};\n/** @internal */\nclass CounterState {\n  constructor(count) {\n    this.count = count;\n    this[_a] = metricStateVariance;\n    this[_b] = CounterStateTypeId;\n  }\n  [(_a = MetricStateTypeId, _b = CounterStateTypeId, Hash.symbol)]() {\n    return Hash.combine(Hash.hash(this.count))(Hash.hash(CounterStateSymbolKey));\n  }\n  [Equal.symbol](that) {\n    return isCounterState(that) && this.count === that.count;\n  }\n}\n/** @internal */\nclass FrequencyState {\n  constructor(occurrences) {\n    this.occurrences = occurrences;\n    this[_c] = metricStateVariance;\n    this[_d] = FrequencyStateTypeId;\n  }\n  [(_c = MetricStateTypeId, _d = FrequencyStateTypeId, Hash.symbol)]() {\n    return Hash.combine(Hash.hash(this.occurrences))(Hash.hash(FrequencyStateSymbolKey));\n  }\n  [Equal.symbol](that) {\n    return isFrequencyState(that) && Equal.equals(this.occurrences, that.occurrences);\n  }\n}\n/** @internal */\nclass GaugeState {\n  constructor(value) {\n    this.value = value;\n    this[_e] = metricStateVariance;\n    this[_f] = GaugeStateTypeId;\n  }\n  [(_e = MetricStateTypeId, _f = GaugeStateTypeId, Hash.symbol)]() {\n    return Hash.combine(Hash.hash(this.value))(Hash.hash(GaugeStateSymbolKey));\n  }\n  [Equal.symbol](u) {\n    return isGaugeState(u) && this.value === u.value;\n  }\n}\n/** @internal */\nexport class HistogramState {\n  constructor(buckets, count, min, max, sum) {\n    this.buckets = buckets;\n    this.count = count;\n    this.min = min;\n    this.max = max;\n    this.sum = sum;\n    this[_g] = metricStateVariance;\n    this[_h] = HistogramStateTypeId;\n  }\n  [(_g = MetricStateTypeId, _h = HistogramStateTypeId, Hash.symbol)]() {\n    return Hash.combine(Hash.hash(this.sum))(Hash.combine(Hash.hash(this.max))(Hash.combine(Hash.hash(this.min))(Hash.combine(Hash.hash(this.count))(Hash.combine(Hash.hash(this.buckets))(Hash.hash(HistogramStateSymbolKey))))));\n  }\n  [Equal.symbol](that) {\n    return isHistogramState(that) && Equal.equals(this.buckets, that.buckets) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;\n  }\n}\n/** @internal */\nexport class SummaryState {\n  constructor(error, quantiles, count, min, max, sum) {\n    this.error = error;\n    this.quantiles = quantiles;\n    this.count = count;\n    this.min = min;\n    this.max = max;\n    this.sum = sum;\n    this[_j] = metricStateVariance;\n    this[_k] = SummaryStateTypeId;\n  }\n  [(_j = MetricStateTypeId, _k = SummaryStateTypeId, Hash.symbol)]() {\n    return Hash.combine(Hash.hash(this.sum))(Hash.combine(Hash.hash(this.max))(Hash.combine(Hash.hash(this.min))(Hash.combine(Hash.hash(this.count))(Hash.combine(Hash.hash(this.quantiles))(Hash.combine(Hash.hash(this.error))(Hash.hash(SummaryStateSymbolKey)))))));\n  }\n  [Equal.symbol](that) {\n    return isSummaryState(that) && this.error === that.error && Equal.equals(this.quantiles, that.quantiles) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;\n  }\n}\n/** @internal */\nexport const counter = count => {\n  return new CounterState(count);\n};\n/** @internal */\nexport const frequency = occurrences => {\n  return new FrequencyState(occurrences);\n};\n/** @internal */\nexport const gauge = value => {\n  return new GaugeState(value);\n};\n/** @internal */\nexport const histogram = (buckets, count, min, max, sum) => {\n  return new HistogramState(buckets, count, min, max, sum);\n};\n/** @internal */\nexport const summary = (error, quantiles, count, min, max, sum) => {\n  return new SummaryState(error, quantiles, count, min, max, sum);\n};\n/** @internal */\nexport const isMetricState = u => {\n  return typeof u === \"object\" && u != null && MetricStateTypeId in u;\n};\n/** @internal */\nexport const isCounterState = u => {\n  return typeof u === \"object\" && u != null && CounterStateTypeId in u;\n};\n/**\n * @since 1.0.0\n * @category refinements\n */\nexport const isFrequencyState = u => {\n  return typeof u === \"object\" && u != null && FrequencyStateTypeId in u;\n};\n/**\n * @since 1.0.0\n * @category refinements\n */\nexport const isGaugeState = u => {\n  return typeof u === \"object\" && u != null && GaugeStateTypeId in u;\n};\n/**\n * @since 1.0.0\n * @category refinements\n */\nexport const isHistogramState = u => {\n  return typeof u === \"object\" && u != null && HistogramStateTypeId in u;\n};\n/**\n * @since 1.0.0\n * @category refinements\n */\nexport const isSummaryState = u => {\n  return typeof u === \"object\" && u != null && SummaryStateTypeId in u;\n};\n//# sourceMappingURL=state.mjs.map","import * as Debug from \"@effect/io/Debug\";\nimport * as metricState from \"@effect/io/internal_effect_untraced/metric/state\";\nimport * as number from \"@fp-ts/core/Number\";\nimport * as Option from \"@fp-ts/core/Option\";\nimport * as Chunk from \"@fp-ts/data/Chunk\";\nimport * as Duration from \"@fp-ts/data/Duration\";\nimport * as HashMap from \"@fp-ts/data/HashMap\";\n/** @internal */\nconst MetricHookSymbolKey = \"@effect/io/Metric/Hook\";\n/** @internal */\nexport const MetricHookTypeId = /*#__PURE__*/Symbol.for(MetricHookSymbolKey);\n/** @internal */\nconst metricHookVariance = {\n  _In: _ => _,\n  _Out: _ => _\n};\n/** @internal */\nexport const make = (get, update) => {\n  return {\n    [MetricHookTypeId]: metricHookVariance,\n    update,\n    get\n  };\n};\n/** @internal */\nexport const onUpdate = /*#__PURE__*/Debug.dual(2, (self, f) => ({\n  [MetricHookTypeId]: metricHookVariance,\n  get: self.get,\n  update: input => {\n    self.update(input);\n    return f(input);\n  }\n}));\n/** @internal */\nexport const counter = _key => {\n  let sum = 0;\n  return make(() => metricState.counter(sum), value => {\n    sum = sum + value;\n  });\n};\n/** @internal */\nexport const frequency = _key => {\n  let count = 0;\n  const values = new Map();\n  const update = word => {\n    count = count + 1;\n    const slotCount = values.get(word) ?? 0;\n    values.set(word, slotCount + 1);\n  };\n  const snapshot = () => HashMap.fromIterable(Array.from(values.entries()).map(([k, v]) => [k, v]));\n  return make(() => metricState.frequency(snapshot()), update);\n};\n/** @internal */\nexport const gauge = (_key, startAt) => {\n  let value = startAt;\n  return make(() => metricState.gauge(value), v => {\n    value = v;\n  });\n};\n/** @internal */\nexport const histogram = key => {\n  const bounds = key.keyType.boundaries.values;\n  const size = bounds.length;\n  const values = Array(size + 1);\n  const boundaries = Array(size);\n  let count = 0;\n  let sum = 0;\n  let min = Number.MAX_VALUE;\n  let max = Number.MIN_VALUE;\n  Chunk.mapWithIndex((i, n) => {\n    boundaries[i] = n;\n  })(Chunk.sort(number.Order)(bounds));\n  // Insert the value into the right bucket with a binary search\n  const update = value => {\n    let from = 0;\n    let to = size;\n    while (from !== to) {\n      const mid = Math.floor(from + (to - from) / 2);\n      const boundary = boundaries[mid];\n      if (value <= boundary) {\n        to = mid;\n      } else {\n        from = mid;\n      }\n      // The special case when to / from have a distance of one\n      if (to === from + 1) {\n        if (value <= boundaries[from]) {\n          to = from;\n        } else {\n          from = to;\n        }\n      }\n    }\n    values[from] = values[from] + 1;\n    count = count + 1;\n    sum = sum + value;\n    if (value < min) {\n      min = value;\n    }\n    if (value > max) {\n      max = value;\n    }\n  };\n  const getBuckets = () => {\n    const builder = [];\n    let i = 0;\n    let cumulated = 0;\n    while (i != size) {\n      const boundary = boundaries[i];\n      const value = values[i];\n      cumulated = cumulated + value;\n      builder.push([boundary, cumulated]);\n      i = i + 1;\n    }\n    return Chunk.fromIterable(builder);\n  };\n  return make(() => metricState.histogram(getBuckets(), count, min, max, sum), update);\n};\n/** @internal */\nexport const summary = key => {\n  const {\n    error,\n    maxAge,\n    maxSize,\n    quantiles\n  } = key.keyType;\n  const sortedQuantiles = Chunk.sort(number.Order)(quantiles);\n  const values = Array(maxSize);\n  let head = 0;\n  let count = 0;\n  let sum = 0;\n  let min = Number.MAX_VALUE;\n  let max = Number.MIN_VALUE;\n  // Just before the snapshot we filter out all values older than maxAge\n  const snapshot = now => {\n    const builder = [];\n    // If the buffer is not full yet it contains valid items at the 0..last\n    // indices and null values at the rest of the positions.\n    //\n    // If the buffer is already full then all elements contains a valid\n    // measurement with timestamp.\n    //\n    // At any given point in time we can enumerate all the non-null elements in\n    // the buffer and filter them by timestamp to get a valid view of a time\n    // window.\n    //\n    // The order does not matter because it gets sorted before passing to\n    // `calculateQuantiles`.\n    let i = 0;\n    while (i !== maxSize - 1) {\n      const item = values[i];\n      if (item != null) {\n        const [t, v] = item;\n        const age = Duration.millis(now - t);\n        if (age.millis >= 0 && age <= maxAge) {\n          builder.push(v);\n        }\n      }\n      i = i + 1;\n    }\n    return calculateQuantiles(error, sortedQuantiles, Chunk.sort(number.Order)(Chunk.fromIterable(builder)));\n  };\n  const observe = (value, timestamp) => {\n    if (maxSize > 0) {\n      head = head + 1;\n      const target = head % maxSize;\n      values[target] = [timestamp, value];\n    }\n    count = count + 1;\n    sum = sum + value;\n    if (value < min) {\n      min = value;\n    }\n    if (value > max) {\n      max = value;\n    }\n  };\n  return make(() => metricState.summary(error, snapshot(Date.now()), count, min, max, sum), ([value, timestamp]) => observe(value, timestamp));\n};\n/** @internal */\nconst calculateQuantiles = (error, sortedQuantiles, sortedSamples) => {\n  // The number of samples examined\n  const sampleCount = sortedSamples.length;\n  if (Chunk.isEmpty(sortedQuantiles)) {\n    return Chunk.empty();\n  }\n  const head = Chunk.unsafeHead(sortedQuantiles);\n  const tail = Chunk.drop(1)(sortedQuantiles);\n  const resolved = Chunk.reduce(Chunk.of(resolveQuantile(error, sampleCount, Option.none(), 0, head, sortedSamples)), (accumulator, quantile) => {\n    const h = Chunk.unsafeHead(accumulator);\n    return Chunk.append(resolveQuantile(error, sampleCount, h.value, h.consumed, quantile, h.rest))(accumulator);\n  })(tail);\n  return Chunk.map(rq => [rq.quantile, rq.value])(resolved);\n};\n/** @internal */\nconst resolveQuantile = (error, sampleCount, current, consumed, quantile, rest) => {\n  let error_1 = error;\n  let sampleCount_1 = sampleCount;\n  let current_1 = current;\n  let consumed_1 = consumed;\n  let quantile_1 = quantile;\n  let rest_1 = rest;\n  let error_2 = error;\n  let sampleCount_2 = sampleCount;\n  let current_2 = current;\n  let consumed_2 = consumed;\n  let quantile_2 = quantile;\n  let rest_2 = rest;\n  // eslint-disable-next-line no-constant-condition\n  while (1) {\n    // If the remaining list of samples is empty, there is nothing more to resolve\n    if (Chunk.isEmpty(rest_1)) {\n      return {\n        quantile: quantile_1,\n        value: Option.none(),\n        consumed: consumed_1,\n        rest: Chunk.empty()\n      };\n    }\n    // If the quantile is the 100% quantile, we can take the maximum of all the\n    // remaining values as the result\n    if (quantile_1 === 1) {\n      return {\n        quantile: quantile_1,\n        value: Option.some(Chunk.unsafeLast(rest_1)),\n        consumed: consumed_1 + rest_1.length,\n        rest: Chunk.empty()\n      };\n    }\n    // Split into two chunks - the first chunk contains all elements of the same\n    // value as the chunk head\n    const sameHead = Chunk.splitWhere(n => n > Chunk.unsafeHead(rest_1))(rest_1);\n    // How many elements do we want to accept for this quantile\n    const desired = quantile_1 * sampleCount_1;\n    // The error margin\n    const allowedError = error_1 / 2 * desired;\n    // Taking into account the elements consumed from the samples so far and the\n    // number of same elements at the beginning of the chunk, calculate the number\n    // of elements we would have if we selected the current head as result\n    const candConsumed = consumed_1 + sameHead[0].length;\n    const candError = Math.abs(candConsumed - desired);\n    // If we haven't got enough elements yet, recurse\n    if (candConsumed < desired - allowedError) {\n      error_2 = error_1;\n      sampleCount_2 = sampleCount_1;\n      current_2 = Chunk.head(rest_1);\n      consumed_2 = candConsumed;\n      quantile_2 = quantile_1;\n      rest_2 = sameHead[1];\n      error_1 = error_2;\n      sampleCount_1 = sampleCount_2;\n      current_1 = current_2;\n      consumed_1 = consumed_2;\n      quantile_1 = quantile_2;\n      rest_1 = rest_2;\n      continue;\n    }\n    // If we have too many elements, select the previous value and hand back the\n    // the rest as leftover\n    if (candConsumed > desired + allowedError) {\n      return {\n        quantile: quantile_1,\n        value: current_1,\n        consumed: consumed_1,\n        rest: rest_1\n      };\n    }\n    // If we are in the target interval, select the current head and hand back the leftover after dropping all elements\n    // from the sample chunk that are equal to the current head\n    switch (current_1._tag) {\n      case \"None\":\n        {\n          error_2 = error_1;\n          sampleCount_2 = sampleCount_1;\n          current_2 = Chunk.head(rest_1);\n          consumed_2 = candConsumed;\n          quantile_2 = quantile_1;\n          rest_2 = sameHead[1];\n          error_1 = error_2;\n          sampleCount_1 = sampleCount_2;\n          current_1 = current_2;\n          consumed_1 = consumed_2;\n          quantile_1 = quantile_2;\n          rest_1 = rest_2;\n          continue;\n        }\n      case \"Some\":\n        {\n          const prevError = Math.abs(desired - current_1.value);\n          if (candError < prevError) {\n            error_2 = error_1;\n            sampleCount_2 = sampleCount_1;\n            current_2 = Chunk.head(rest_1);\n            consumed_2 = candConsumed;\n            quantile_2 = quantile_1;\n            rest_2 = sameHead[1];\n            error_1 = error_2;\n            sampleCount_1 = sampleCount_2;\n            current_1 = current_2;\n            consumed_1 = consumed_2;\n            quantile_1 = quantile_2;\n            rest_1 = rest_2;\n            continue;\n          }\n          return {\n            quantile: quantile_1,\n            value: Option.some(current_1.value),\n            consumed: consumed_1,\n            rest: rest_1\n          };\n        }\n    }\n  }\n  throw new Error(\"BUG: MetricHook.resolveQuantiles - please report an issue at https://github.com/Effect-TS/io/issues\");\n};\n//# sourceMappingURL=hook.mjs.map","/** @internal */\nconst MetricPairSymbolKey = \"@effect/io/Metric/Pair\";\n/** @internal */\nexport const MetricPairTypeId = /*#__PURE__*/Symbol.for(MetricPairSymbolKey);\n/** @internal */\nconst metricPairVariance = {\n  _Type: _ => _\n};\n/** @internal */\nexport const make = (metricKey, metricState) => {\n  return {\n    [MetricPairTypeId]: metricPairVariance,\n    metricKey,\n    metricState\n  };\n};\n/** @internal */\nexport const unsafeMake = (metricKey, metricState) => {\n  return {\n    [MetricPairTypeId]: metricPairVariance,\n    metricKey,\n    metricState\n  };\n};\n//# sourceMappingURL=pair.mjs.map","/**\n * @since 1.0.0\n */\nimport * as Option from \"@fp-ts/core/Option\";\nimport * as Dual from \"@fp-ts/data/Dual\";\nimport * as Equal from \"@fp-ts/data/Equal\";\nimport * as Hash from \"@fp-ts/data/Hash\";\nconst TypeId = /*#__PURE__*/Symbol.for(\"@fp-ts/data/MutableHashMap\");\n/** @internal */\nclass Node {\n  constructor(k, v, next) {\n    this.k = k;\n    this.v = v;\n    this.next = next;\n  }\n  [Symbol.iterator]() {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let c = this;\n    let n = 0;\n    return {\n      next: () => {\n        if (c) {\n          const kv = [c.k, c.v];\n          c = c.next;\n          n++;\n          return {\n            value: kv,\n            done: false\n          };\n        } else {\n          return {\n            value: n,\n            done: true\n          };\n        }\n      }\n    };\n  }\n}\n/** @internal */\nclass MutableHashMapImpl {\n  constructor() {\n    this._id = TypeId;\n    this.backingMap = new Map();\n    this.length = 0;\n  }\n  [Symbol.iterator]() {\n    return Array.from(this.backingMap.values()).flatMap(node => {\n      const arr = [[node.k, node.v]];\n      let next = node.next;\n      while (next) {\n        arr.push([next.k, next.v]);\n        next = next.next;\n      }\n      return arr;\n    })[Symbol.iterator]();\n  }\n  toString() {\n    return `MutableHashMap(${Array.from(this).map(([k, v]) => `[${String(k)}, ${String(v)}]`).join(\", \")})`;\n  }\n  toJSON() {\n    return {\n      _tag: \"MutableHashMap\",\n      values: Array.from(this)\n    };\n  }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return this.toJSON();\n  }\n}\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const empty = () => new MutableHashMapImpl();\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const make = (...entries) => fromIterable(entries);\n/**\n * @since 1.0.0\n * @category conversions\n */\nexport const fromIterable = entries => {\n  const map = empty();\n  for (const entry of entries) {\n    set(map, entry[0], entry[1]);\n  }\n  return map;\n};\n/**\n * @since 1.0.0\n * @category elements\n */\nexport const get = /*#__PURE__*/Dual.dual(2, (self, key) => {\n  const hash = Hash.hash(key);\n  const arr = self.backingMap.get(hash);\n  if (arr === undefined) {\n    return Option.none();\n  }\n  let c = arr;\n  while (c !== undefined) {\n    if (Equal.equals(key, c.k)) {\n      return Option.some(c.v);\n    }\n    c = c.next;\n  }\n  return Option.none();\n});\n/**\n * @since 1.0.0\n * @category elements\n */\nexport const has = /*#__PURE__*/Dual.dual(2, (self, key) => Option.isSome(get(self, key)));\n/**\n * Updates the value of the specified key within the `MutableHashMap` if it exists.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const modify = /*#__PURE__*/Dual.dual(3, (self, key, f) => {\n  const hash = Hash.hash(key);\n  const arr = self.backingMap.get(hash);\n  if (arr === undefined) {\n    return self;\n  }\n  let c = arr;\n  while (c !== undefined) {\n    if (Equal.equals(key, c.k)) {\n      c.v = f(c.v);\n      return self;\n    }\n    c = c.next;\n  }\n  return self;\n});\n/**\n * Set or remove the specified key in the `MutableHashMap` using the specified\n * update function.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const modifyAt = /*#__PURE__*/Dual.dual(3, (self, key, f) => {\n  const result = f(get(self, key));\n  if (Option.isSome(result)) {\n    set(self, key, result.value);\n  } else {\n    remove(self, key);\n  }\n  return self;\n});\n/**\n * @since 1.0.0\n * @category mutations\n */\nexport const remove = /*#__PURE__*/Dual.dual(2, (self, key) => {\n  const hash = Hash.hash(key);\n  const arr = self.backingMap.get(hash);\n  if (arr === undefined) {\n    return self;\n  }\n  if (Equal.equals(key, arr.k)) {\n    if (arr.next !== undefined) {\n      self.backingMap.set(hash, arr.next);\n    } else {\n      self.backingMap.delete(hash);\n    }\n    self.length = self.length - 1;\n    return self;\n  }\n  let next = arr.next;\n  let curr = arr;\n  while (next !== undefined) {\n    if (Equal.equals(key, next.k)) {\n      curr.next = next.next;\n      self.length = self.length - 1;\n      return self;\n    }\n    curr = next;\n    next = next.next;\n  }\n  return self;\n});\n/**\n * @since 1.0.0\n * @category mutations\n */\nexport const set = /*#__PURE__*/Dual.dual(3, (self, key, value) => {\n  const hash = Hash.hash(key);\n  const arr = self.backingMap.get(hash);\n  if (arr === undefined) {\n    self.backingMap.set(hash, new Node(key, value));\n    self.length = self.length + 1;\n    return self;\n  }\n  let c = arr;\n  let l = arr;\n  while (c !== undefined) {\n    if (Equal.equals(key, c.k)) {\n      c.v = value;\n      return self;\n    }\n    l = c;\n    c = c.next;\n  }\n  self.length = self.length + 1;\n  l.next = new Node(key, value);\n  return self;\n});\n/**\n * @since 1.0.0\n * @category elements\n */\nexport const size = self => self.length;\n//# sourceMappingURL=MutableHashMap.mjs.map","var _a;\nimport * as metricHook from \"@effect/io/internal_effect_untraced/metric/hook\";\nimport * as metricKeyType from \"@effect/io/internal_effect_untraced/metric/keyType\";\nimport * as metricPair from \"@effect/io/internal_effect_untraced/metric/pair\";\nimport * as Option from \"@fp-ts/core/Option\";\nimport * as HashSet from \"@fp-ts/data/HashSet\";\nimport * as MutableHashMap from \"@fp-ts/data/MutableHashMap\";\n/** @internal */\nconst MetricRegistrySymbolKey = \"@effect/io/Metric/Registry\";\n/** @internal */\nexport const MetricRegistryTypeId = /*#__PURE__*/Symbol.for(MetricRegistrySymbolKey);\n/** @internal */\nclass MetricRegistryImpl {\n  constructor() {\n    this[_a] = MetricRegistryTypeId;\n    this.map = MutableHashMap.empty();\n  }\n  snapshot() {\n    const result = [];\n    for (const [key, hook] of this.map) {\n      result.push(metricPair.unsafeMake(key, hook.get()));\n    }\n    return HashSet.fromIterable(result);\n  }\n  get(key) {\n    const hook = Option.getOrUndefined(MutableHashMap.get(key)(this.map));\n    if (hook == null) {\n      if (metricKeyType.isCounterKey(key.keyType)) {\n        return this.getCounter(key);\n      }\n      if (metricKeyType.isGaugeKey(key.keyType)) {\n        return this.getGauge(key);\n      }\n      if (metricKeyType.isFrequencyKey(key.keyType)) {\n        return this.getFrequency(key);\n      }\n      if (metricKeyType.isHistogramKey(key.keyType)) {\n        return this.getHistogram(key);\n      }\n      if (metricKeyType.isSummaryKey(key.keyType)) {\n        return this.getSummary(key);\n      }\n      throw new Error(\"BUG: MetricRegistry.get - unknown MetricKeyType - please report an issue at https://github.com/Effect-TS/io/issues\");\n    } else {\n      return hook;\n    }\n  }\n  getCounter(key) {\n    let value = Option.getOrUndefined(MutableHashMap.get(key)(this.map));\n    if (value == null) {\n      const counter = metricHook.counter(key);\n      if (!MutableHashMap.has(key)(this.map)) {\n        MutableHashMap.set(key, counter)(this.map);\n      }\n      value = counter;\n    }\n    return value;\n  }\n  getFrequency(key) {\n    let value = Option.getOrUndefined(MutableHashMap.get(key)(this.map));\n    if (value == null) {\n      const frequency = metricHook.frequency(key);\n      if (!MutableHashMap.has(key)(this.map)) {\n        MutableHashMap.set(key, frequency)(this.map);\n      }\n      value = frequency;\n    }\n    return value;\n  }\n  getGauge(key) {\n    let value = Option.getOrUndefined(MutableHashMap.get(key)(this.map));\n    if (value == null) {\n      const gauge = metricHook.gauge(key, 0);\n      if (!MutableHashMap.has(key)(this.map)) {\n        MutableHashMap.set(key, gauge)(this.map);\n      }\n      value = gauge;\n    }\n    return value;\n  }\n  getHistogram(key) {\n    let value = Option.getOrUndefined(MutableHashMap.get(key)(this.map));\n    if (value == null) {\n      const histogram = metricHook.histogram(key);\n      if (!MutableHashMap.has(key)(this.map)) {\n        MutableHashMap.set(key, histogram)(this.map);\n      }\n      value = histogram;\n    }\n    return value;\n  }\n  getSummary(key) {\n    let value = Option.getOrUndefined(MutableHashMap.get(key)(this.map));\n    if (value == null) {\n      const summary = metricHook.summary(key);\n      if (!MutableHashMap.has(key)(this.map)) {\n        MutableHashMap.set(key, summary)(this.map);\n      }\n      value = summary;\n    }\n    return value;\n  }\n}\n_a = MetricRegistryTypeId;\n/** @internal */\nexport const make = () => {\n  return new MetricRegistryImpl();\n};\n//# sourceMappingURL=registry.mjs.map","import * as Debug from \"@effect/io/Debug\";\nimport * as Cause from \"@effect/io/internal_effect_untraced/cause\";\nimport * as core from \"@effect/io/internal_effect_untraced/core\";\nimport * as _effect from \"@effect/io/internal_effect_untraced/effect\";\nimport * as metricBoundaries from \"@effect/io/internal_effect_untraced/metric/boundaries\";\nimport * as metricKey from \"@effect/io/internal_effect_untraced/metric/key\";\nimport * as metricLabel from \"@effect/io/internal_effect_untraced/metric/label\";\nimport * as metricRegistry from \"@effect/io/internal_effect_untraced/metric/registry\";\nimport { constVoid, identity } from \"@fp-ts/core/Function\";\nimport * as Chunk from \"@fp-ts/data/Chunk\";\nimport * as Duration from \"@fp-ts/data/Duration\";\nimport * as HashSet from \"@fp-ts/data/HashSet\";\n/** @internal */\nconst MetricSymbolKey = \"@effect/io/Metric\";\n/** @internal */\nexport const MetricTypeId = /*#__PURE__*/Symbol.for(MetricSymbolKey);\n/** @internal */\nconst metricVariance = {\n  _Type: _ => _,\n  _In: _ => _,\n  _Out: _ => _\n};\n/** @internal */\nexport const globalMetricRegistry = /*#__PURE__*/metricRegistry.make();\n/** @internal */\nexport const make = function (keyType, unsafeUpdate, unsafeValue) {\n  const metric = Object.assign(Debug.methodWithTrace((trace, restore) => effect => core.tap(effect, a => core.sync(() => restore(unsafeUpdate)(a, HashSet.empty()))).traced(trace)), {\n    [MetricTypeId]: metricVariance,\n    keyType,\n    unsafeUpdate,\n    unsafeValue\n  });\n  return metric;\n};\n/** @internal */\nexport const contramap = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => make(self.keyType, (input, extraTags) => self.unsafeUpdate(restore(f)(input), extraTags), self.unsafeValue));\n/** @internal */\nexport const counter = name => fromMetricKey(metricKey.counter(name));\n/** @internal */\nexport const frequency = name => fromMetricKey(metricKey.frequency(name));\n/** @internal */\nexport const fromConst = /*#__PURE__*/Debug.untracedDual(2, restore => (self, input) => contramap(self, restore(input)));\n/** @internal */\nexport const fromMetricKey = key => {\n  const hook = extraTags => {\n    const fullKey = metricKey.taggedWithLabelSet(extraTags)(key);\n    return globalMetricRegistry.get(fullKey);\n  };\n  return make(key.keyType, (input, extraTags) => hook(extraTags).update(input), extraTags => hook(extraTags).get());\n};\n/** @internal */\nexport const gauge = name => fromMetricKey(metricKey.gauge(name));\n/** @internal */\nexport const histogram = (name, boundaries) => fromMetricKey(metricKey.histogram(name, boundaries));\n/* @internal */\nexport const increment = /*#__PURE__*/Debug.methodWithTrace(trace => self => update(self, 1).traced(trace));\n/* @internal */\nexport const incrementBy = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, amount) => update(self, amount).traced(trace));\n/** @internal */\nexport const map = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => make(self.keyType, self.unsafeUpdate, extraTags => restore(f)(self.unsafeValue(extraTags))));\n/** @internal */\nexport const mapType = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => make(restore(f)(self.keyType), self.unsafeUpdate, self.unsafeValue));\n/* @internal */\nexport const set = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, value) => update(self, value).traced(trace));\n/** @internal */\nexport const snapshot = /*#__PURE__*/Debug.methodWithTrace(trace => () => core.sync(unsafeSnapshot).traced(trace));\n/** @internal */\nexport const succeed = out => make(void 0, constVoid, () => out);\n/** @internal */\nexport const sync = evaluate => make(void 0, constVoid, evaluate);\n/** @internal */\nexport const summary = (name, maxAge, maxSize, error, quantiles) => withNow(summaryTimestamp(name, maxAge, maxSize, error, quantiles));\n/** @internal */\nexport const summaryTimestamp = (name, maxAge, maxSize, error, quantiles) => fromMetricKey(metricKey.summary(name, maxAge, maxSize, error, quantiles));\n/** @internal */\nexport const tagged = /*#__PURE__*/Debug.dual(3, (self, key, value) => taggedWithLabelSet(self, HashSet.make(metricLabel.make(key, value))));\n/** @internal */\nexport const taggedWith = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => map(make(self.keyType, (input, extraTags) => self.unsafeUpdate(input, HashSet.union(extraTags)(restore(f)(input))), self.unsafeValue), constVoid));\n/** @internal */\nexport const taggedWithLabels = /*#__PURE__*/Debug.dual(2, (self, extraTags) => taggedWithLabelSet(self, HashSet.fromIterable(extraTags)));\n/** @internal */\nexport const taggedWithLabelSet = /*#__PURE__*/Debug.dual(2, (self, extraTags) => make(self.keyType, (input, extraTags1) => self.unsafeUpdate(input, HashSet.union(extraTags1)(extraTags)), extraTags1 => self.unsafeValue(HashSet.union(extraTags1)(extraTags))));\n/** @internal */\nexport const timer = name => {\n  const boundaries = metricBoundaries.exponential(1, 2, 100);\n  const base = tagged(\"time_unit\", \"milliseconds\")(histogram(name, boundaries));\n  return contramap(duration => duration.millis)(base);\n};\n/** @internal */\nexport const timerWithBoundaries = (name, boundaries) => {\n  const base = tagged(\"time_unit\", \"milliseconds\")(histogram(name, metricBoundaries.fromChunk(boundaries)));\n  return contramap(base, duration => duration.millis);\n};\n/* @internal */\nexport const trackAll = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, input) => effect => Debug.untraced(() => core.matchCauseEffect(effect, cause => {\n  self.unsafeUpdate(input, HashSet.empty());\n  return core.failCause(cause);\n}, value => {\n  self.unsafeUpdate(input, HashSet.empty());\n  return core.succeed(value);\n}).traced(trace)));\n/* @internal */\nexport const trackDefect = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, metric) => trackDefectWith(self, metric, identity).traced(trace));\n/* @internal */\nexport const trackDefectWith = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, metric, f) => Debug.untraced(() => {\n  const updater = defect => metric.unsafeUpdate(restore(f)(defect), HashSet.empty());\n  return _effect.tapDefect(self, cause => core.sync(() => Chunk.forEach(updater)(Cause.defects(cause)))).traced(trace);\n}));\n/* @internal */\nexport const trackDuration = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, metric) => trackDurationWith(self, metric, identity).traced(trace));\n/* @internal */\nexport const trackDurationWith = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, metric, f) => Debug.untraced(() => core.suspendSucceed(() => {\n  const startTime = Date.now();\n  return core.map(self, a => {\n    const endTime = Date.now();\n    const duration = Duration.millis(endTime - startTime);\n    metric.unsafeUpdate(restore(f)(duration), HashSet.empty());\n    return a;\n  });\n}).traced(trace)));\n/* @internal */\nexport const trackError = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, metric) => trackErrorWith(self, metric, a => a).traced(trace));\n/* @internal */\nexport const trackErrorWith = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, metric, f) => Debug.untraced(() => {\n  const updater = error => update(metric, restore(f)(error));\n  return _effect.tapError(self, updater).traced(trace);\n}));\n/* @internal */\nexport const trackSuccess = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, metric) => trackSuccessWith(self, metric, a => a).traced(trace));\n/* @internal */\nexport const trackSuccessWith = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, metric, f) => Debug.untraced(() => {\n  const updater = value => update(metric, restore(f)(value));\n  return core.tap(self, updater).traced(trace);\n}));\n/* @internal */\nexport const update = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, input) => core.fiberRefGetWith(core.currentTags, tags => core.sync(() => self.unsafeUpdate(input, tags))).traced(trace));\n/* @internal */\nexport const value = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.fiberRefGetWith(core.currentTags, tags => core.sync(() => self.unsafeValue(tags))).traced(trace));\n/** @internal */\nexport const withNow = self => contramap(self, input => [input, Date.now()]);\n/** @internal */\nexport const zip = /*#__PURE__*/Debug.dual(2, (self, that) => make([self.keyType, that.keyType], (input, extraTags) => {\n  const [l, r] = input;\n  self.unsafeUpdate(l, extraTags);\n  that.unsafeUpdate(r, extraTags);\n}, extraTags => [self.unsafeValue(extraTags), that.unsafeValue(extraTags)]));\n/** @internal */\nexport const unsafeSnapshot = () => globalMetricRegistry.snapshot();\n//# sourceMappingURL=metric.mjs.map","var _a;\nimport * as Chunk from \"@fp-ts/data/Chunk\";\nimport * as Equal from \"@fp-ts/data/Equal\";\nimport * as Hash from \"@fp-ts/data/Hash\";\n/** @internal */\nconst MetricBoundariesSymbolKey = \"@effect/io/Metric/Boundaries\";\n/** @internal */\nexport const MetricBoundariesTypeId = /*#__PURE__*/Symbol.for(MetricBoundariesSymbolKey);\n/** @internal */\nclass MetricBoundariesImpl {\n  constructor(values) {\n    this.values = values;\n    this[_a] = MetricBoundariesTypeId;\n  }\n  [(_a = MetricBoundariesTypeId, Hash.symbol)]() {\n    return Hash.combine(Hash.hash(this.values))(Hash.hash(MetricBoundariesSymbolKey));\n  }\n  [Equal.symbol](u) {\n    return isMetricBoundaries(u) && Equal.equals(this.values, u.values);\n  }\n}\n/** @internal */\nexport const isMetricBoundaries = u => {\n  return typeof u === \"object\" && u != null && MetricBoundariesTypeId in u;\n};\n/** @internal */\nexport const fromChunk = chunk => {\n  const values = Chunk.dedupe(Chunk.concat(Chunk.of(Number.POSITIVE_INFINITY))(chunk));\n  return new MetricBoundariesImpl(values);\n};\n/** @internal */\nexport const linear = (start, width, count) => {\n  return fromChunk(Chunk.map(i => start + i * width)(Chunk.range(0, count - 1)));\n};\n/** @internal */\nexport const exponential = (start, factor, count) => {\n  return fromChunk(Chunk.map(i => start * Math.pow(factor, i))(Chunk.range(0, count - 1)));\n};\n//# sourceMappingURL=boundaries.mjs.map","var _a, _b, _c, _d, _e;\nimport * as Debug from \"@effect/io/Debug\";\nimport * as core from \"@effect/io/internal_effect_untraced/core\";\nimport * as Chunk from \"@fp-ts/data/Chunk\";\nimport * as MutableRef from \"@fp-ts/data/MutableRef\";\nimport * as SortedSet from \"@fp-ts/data/SortedSet\";\n/** @internal */\nconst SupervisorSymbolKey = \"@effect/io/Supervisor\";\n/** @internal */\nexport const SupervisorTypeId = /*#__PURE__*/Symbol.for(SupervisorSymbolKey);\n/** @internal */\nconst supervisorVariance = {\n  _T: _ => _\n};\n/** @internal */\nexport class ProxySupervisor {\n  constructor(underlying, value0) {\n    this.underlying = underlying;\n    this.value0 = value0;\n    this[_a] = supervisorVariance;\n  }\n  value() {\n    return Debug.bodyWithTrace(trace => this.value0().traced(trace));\n  }\n  onStart(context, effect, parent, fiber) {\n    this.underlying.onStart(context, effect, parent, fiber);\n  }\n  onEnd(value, fiber) {\n    this.underlying.onEnd(value, fiber);\n  }\n  onEffect(fiber, effect) {\n    this.underlying.onEffect(fiber, effect);\n  }\n  onSuspend(fiber) {\n    this.underlying.onSuspend(fiber);\n  }\n  onResume(fiber) {\n    this.underlying.onResume(fiber);\n  }\n  map(f) {\n    return new ProxySupervisor(this, () => core.map(f)(this.value()));\n  }\n  zip(right) {\n    return new Zip(this, right);\n  }\n}\n_a = SupervisorTypeId;\n/** @internal */\nexport class Zip {\n  constructor(left, right) {\n    this.left = left;\n    this.right = right;\n    this[_b] = supervisorVariance;\n  }\n  value() {\n    return Debug.bodyWithTrace(trace => core.zip(this.left.value(), this.right.value()).traced(trace));\n  }\n  onStart(context, effect, parent, fiber) {\n    this.left.onStart(context, effect, parent, fiber);\n    this.right.onStart(context, effect, parent, fiber);\n  }\n  onEnd(value, fiber) {\n    this.left.onEnd(value, fiber);\n    this.right.onEnd(value, fiber);\n  }\n  onEffect(fiber, effect) {\n    this.left.onEffect(fiber, effect);\n    this.right.onEffect(fiber, effect);\n  }\n  onSuspend(fiber) {\n    this.left.onSuspend(fiber);\n    this.right.onSuspend(fiber);\n  }\n  onResume(fiber) {\n    this.left.onResume(fiber);\n    this.right.onResume(fiber);\n  }\n  map(f) {\n    return new ProxySupervisor(this, () => core.map(f)(this.value()));\n  }\n  zip(right) {\n    return new Zip(this, right);\n  }\n}\n_b = SupervisorTypeId;\nexport class Track {\n  constructor() {\n    this[_c] = supervisorVariance;\n    this.fibers = new Set();\n  }\n  value() {\n    return Debug.bodyWithTrace(trace => core.sync(() => Chunk.fromIterable(this.fibers)).traced(trace));\n  }\n  onStart(_context, _effect, _parent, fiber) {\n    this.fibers.add(fiber);\n  }\n  onEnd(_value, fiber) {\n    this.fibers.delete(fiber);\n  }\n  onEffect(_fiber, _effect) {\n    //\n  }\n  onSuspend(_fiber) {\n    //\n  }\n  onResume(_fiber) {\n    //\n  }\n  map(f) {\n    return new ProxySupervisor(this, () => core.map(f)(this.value()));\n  }\n  zip(right) {\n    return new Zip(this, right);\n  }\n}\n_c = SupervisorTypeId;\nexport class Const {\n  constructor(effect) {\n    this.effect = effect;\n    this[_d] = supervisorVariance;\n  }\n  value() {\n    return Debug.bodyWithTrace(trace => this.effect.traced(trace));\n  }\n  onStart(_context, _effect, _parent, _fiber) {\n    //\n  }\n  onEnd(_value, _fiber) {\n    //\n  }\n  onEffect(_fiber, _effect) {\n    //\n  }\n  onSuspend(_fiber) {\n    //\n  }\n  onResume(_fiber) {\n    //\n  }\n  map(f) {\n    return new ProxySupervisor(this, () => core.map(f)(this.value()));\n  }\n  zip(right) {\n    return new Zip(this, right);\n  }\n}\n_d = SupervisorTypeId;\nclass FibersIn {\n  constructor(ref) {\n    this.ref = ref;\n    this[_e] = supervisorVariance;\n  }\n  value() {\n    return Debug.bodyWithTrace(trace => core.sync(() => MutableRef.get(this.ref)).traced(trace));\n  }\n  onStart(_context, _effect, _parent, fiber) {\n    MutableRef.set(SortedSet.add(fiber)(MutableRef.get(this.ref)))(this.ref);\n  }\n  onEnd(_value, fiber) {\n    MutableRef.set(SortedSet.remove(fiber)(MutableRef.get(this.ref)))(this.ref);\n  }\n  onEffect(_fiber, _effect) {\n    //\n  }\n  onSuspend(_fiber) {\n    //\n  }\n  onResume(_fiber) {\n    //\n  }\n  map(f) {\n    return new ProxySupervisor(this, () => core.map(f)(this.value()));\n  }\n  zip(right) {\n    return new Zip(this, right);\n  }\n}\n_e = SupervisorTypeId;\n/** @internal */\nexport const unsafeTrack = () => {\n  return new Track();\n};\n/** @internal */\nexport const track = /*#__PURE__*/Debug.methodWithTrace(trace => () => core.sync(unsafeTrack).traced(trace));\n/** @internal */\nexport const fromEffect = effect => {\n  return new Const(effect);\n};\n/** @internal */\nexport const none = /*#__PURE__*/fromEffect( /*#__PURE__*/core.unit());\n/** @internal */\nexport const fibersIn = /*#__PURE__*/Debug.methodWithTrace(trace => ref => core.sync(() => new FibersIn(ref)).traced(trace));\n//# sourceMappingURL=supervisor.mjs.map","import * as supervisor from \"@effect/io/internal_effect_untraced/supervisor\";\nimport * as Chunk from \"@fp-ts/data/Chunk\";\nimport * as Differ from \"@fp-ts/data/Differ\";\nimport * as Equal from \"@fp-ts/data/Equal\";\nimport * as HashSet from \"@fp-ts/data/HashSet\";\n/** @internal */\nexport const OP_EMPTY = \"Empty\";\n/** @internal */\nexport const OP_ADD_SUPERVISOR = \"AddSupervisor\";\n/** @internal */\nexport const OP_REMOVE_SUPERVISOR = \"RemoveSupervisor\";\n/** @internal */\nexport const OP_AND_THEN = \"AndThen\";\n/**\n * The empty `SupervisorPatch`.\n *\n * @internal\n */\nexport const empty = {\n  _tag: OP_EMPTY\n};\n/**\n * Combines two patches to produce a new patch that describes applying the\n * updates from this patch and then the updates from the specified patch.\n *\n * @internal\n */\nexport const combine = (self, that) => {\n  return {\n    _tag: OP_AND_THEN,\n    first: self,\n    second: that\n  };\n};\n/**\n * Applies a `SupervisorPatch` to a `Supervisor` to produce a new `Supervisor`.\n *\n * @internal\n */\nexport const patch = (self, supervisor) => {\n  return patchLoop(supervisor, Chunk.of(self));\n};\n/** @internal */\nconst patchLoop = (_supervisor, _patches) => {\n  let supervisor = _supervisor;\n  let patches = _patches;\n  while (Chunk.isNonEmpty(patches)) {\n    const head = Chunk.headNonEmpty(patches);\n    switch (head._tag) {\n      case OP_EMPTY:\n        {\n          patches = Chunk.tailNonEmpty(patches);\n          break;\n        }\n      case OP_ADD_SUPERVISOR:\n        {\n          supervisor = supervisor.zip(head.supervisor);\n          patches = Chunk.tailNonEmpty(patches);\n          break;\n        }\n      case OP_REMOVE_SUPERVISOR:\n        {\n          supervisor = removeSupervisor(supervisor, head.supervisor);\n          patches = Chunk.tailNonEmpty(patches);\n          break;\n        }\n      case OP_AND_THEN:\n        {\n          patches = Chunk.prepend(head.first)(Chunk.prepend(head.second)(Chunk.tailNonEmpty(patches)));\n          break;\n        }\n    }\n  }\n  return supervisor;\n};\n/** @internal */\nconst removeSupervisor = (self, that) => {\n  if (Equal.equals(self, that)) {\n    return supervisor.none;\n  } else {\n    if (self instanceof supervisor.Zip) {\n      return removeSupervisor(self.left, that).zip(removeSupervisor(self.right, that));\n    } else {\n      return self;\n    }\n  }\n};\n/** @internal */\nconst toSet = self => {\n  if (Equal.equals(self, supervisor.none)) {\n    return HashSet.empty();\n  } else {\n    if (self instanceof supervisor.Zip) {\n      return HashSet.union(toSet(self.right))(toSet(self.left));\n    } else {\n      return HashSet.make(self);\n    }\n  }\n};\n/** @internal */\nexport const diff = (oldValue, newValue) => {\n  if (Equal.equals(oldValue, newValue)) {\n    return empty;\n  }\n  const oldSupervisors = toSet(oldValue);\n  const newSupervisors = toSet(newValue);\n  const added = HashSet.reduce(empty, (patch, supervisor) => combine(patch, {\n    _tag: OP_ADD_SUPERVISOR,\n    supervisor\n  }))(HashSet.difference(oldSupervisors)(newSupervisors));\n  const removed = HashSet.reduce(empty, (patch, supervisor) => combine(patch, {\n    _tag: OP_REMOVE_SUPERVISOR,\n    supervisor\n  }))(HashSet.difference(newSupervisors)(oldSupervisors));\n  return combine(added, removed);\n};\n/** @internal */\nexport const differ = /*#__PURE__*/Differ.make({\n  empty,\n  patch,\n  combine,\n  diff\n});\n//# sourceMappingURL=patch.mjs.map","/**\n * @since 1.0.0\n */\nimport * as Dual from \"@fp-ts/data/Dual\";\nconst TypeId = /*#__PURE__*/Symbol.for(\"@fp-ts/data/MutableList\");\n/** @internal */\nclass MutableListImpl {\n  constructor() {\n    this._id = TypeId;\n    this.head = undefined;\n    this.tail = undefined;\n    this._length = 0;\n  }\n  [Symbol.iterator]() {\n    let done = false;\n    let head = this.head;\n    return {\n      next() {\n        if (done) {\n          return this.return();\n        }\n        if (head == null) {\n          done = true;\n          return this.return();\n        }\n        const value = head.value;\n        head = head.right;\n        return {\n          done,\n          value\n        };\n      },\n      return(value) {\n        if (!done) {\n          done = true;\n        }\n        return {\n          done: true,\n          value\n        };\n      }\n    };\n  }\n  toString() {\n    return `MutableList(${Array.from(this).map(String).join(\", \")})`;\n  }\n  toJSON() {\n    return {\n      _tag: \"MutableList\",\n      values: Array.from(this)\n    };\n  }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return this.toJSON();\n  }\n}\n/** @internal */\nclass LinkedListNode {\n  constructor(value) {\n    this.value = value;\n    this.removed = false;\n    this.left = undefined;\n    this.right = undefined;\n  }\n}\n/**\n * Creates an empty `MutableList`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const empty = () => new MutableListImpl();\n/**\n * Creates a new `MutableList` from an `Iterable`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const from = iterable => {\n  const list = new MutableListImpl();\n  for (const element of iterable) {\n    append(list, element);\n  }\n  return list;\n};\n/**\n * Creates a new `MutableList` from the specified elements.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const make = (...elements) => from(elements);\n/**\n * Returns `true` if the list contains zero elements, `false`, otherwise.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const isEmpty = self => length(self) === 0;\n/**\n * Returns the length of the list.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const length = self => self._length;\n/**\n * Returns the last element of the list, if it exists.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const tail = self => self.tail === undefined ? undefined : self.tail.value;\n/**\n * Returns the first element of the list, if it exists.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const head = self => self.head === undefined ? undefined : self.head.value;\n/**\n * Executes the specified function `f` for each element in the list.\n *\n * @since 1.0.0\n * @category traversing\n */\nexport const forEach = /*#__PURE__*/Dual.dual(2, (self, f) => {\n  let current = self.head;\n  while (current !== undefined) {\n    f(current.value);\n    current = current.right;\n  }\n});\n/**\n * Removes all elements from the doubly-linked list.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const reset = self => {\n  ;\n  self._length = 0;\n  self.head = undefined;\n  self.tail = undefined;\n  return self;\n};\n/**\n * Appends the specified value to the end of the list.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const append = /*#__PURE__*/Dual.dual(2, (self, value) => {\n  const node = new LinkedListNode(value);\n  if (self._length === 0) {\n    self.head = node;\n  }\n  if (self.tail === undefined) {\n    self.tail = node;\n  } else {\n    self.tail.right = node;\n    node.left = self.tail;\n    self.tail = node;\n  }\n  ;\n  self._length += 1;\n  return self;\n});\n/**\n * Removes the first value from the list and returns it, if it exists.\n *\n * @since 0.0.1\n * @category mutations\n */\nexport const shift = self => {\n  const head = self.head;\n  if (head !== undefined) {\n    remove(self, head);\n    return head.value;\n  }\n  return undefined;\n};\n/**\n * Removes the last value from the list and returns it, if it exists.\n *\n * @since 0.0.1\n * @category mutations\n */\nexport const pop = self => {\n  const tail = self.tail;\n  if (tail !== undefined) {\n    remove(self, tail);\n    return tail.value;\n  }\n  return undefined;\n};\nconst remove = (self, node) => {\n  if (node.removed) {\n    return;\n  }\n  node.removed = true;\n  if (node.left !== undefined && node.right !== undefined) {\n    node.left.right = node.right;\n    node.right.left = node.left;\n  } else if (node.left !== undefined) {\n    self.tail = node.left;\n    node.left.right = undefined;\n  } else if (node.right !== undefined) {\n    self.head = node.right;\n    node.right.left = undefined;\n  } else {\n    self.tail = undefined;\n    self.head = undefined;\n  }\n  if (self._length > 0) {\n    ;\n    self._length -= 1;\n  }\n};\n//# sourceMappingURL=MutableList.mjs.map","/**\n * @since 1.0.0\n */\nimport * as Chunk from \"@fp-ts/data/Chunk\";\nimport * as Dual from \"@fp-ts/data/Dual\";\nimport * as MutableList from \"@fp-ts/data/MutableList\";\nconst TypeId = /*#__PURE__*/Symbol.for(\"@fp-ts/data/MutableQueue\");\n/**\n * @since 1.0.0\n * @category symbol\n */\nexport const EmptyMutableQueue = /*#__PURE__*/Symbol.for(\"@fp-ts/data/mutable/MutableQueue/Empty\");\n/** @internal */\nclass MutableQueueImpl {\n  constructor(capacity = undefined) {\n    this.capacity = capacity;\n    this._tag = \"Bounded\";\n    this._id = TypeId;\n    this.queue = MutableList.empty();\n  }\n  [Symbol.iterator]() {\n    return Array.from(this.queue)[Symbol.iterator]();\n  }\n  toString() {\n    return `MutableQueue(${Array.from(this).map(String).join(\", \")})`;\n  }\n  toJSON() {\n    return {\n      _tag: \"MutableQueue\",\n      values: Array.from(this)\n    };\n  }\n  [Symbol.for(\"nodejs.util.inspect.custom\")]() {\n    return this.toJSON();\n  }\n}\n/**\n * Creates a new bounded `MutableQueue`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const bounded = capacity => new MutableQueueImpl(capacity);\n/**\n * Creates a new unbounded `MutableQueue`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const unbounded = () => new MutableQueueImpl();\n/**\n * Returns the current number of elements in the queue.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const length = self => MutableList.length(self.queue);\n/**\n * Returns `true` if the queue is empty, `false` otherwise.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const isEmpty = self => MutableList.isEmpty(self.queue);\n/**\n * Returns `true` if the queue is full, `false` otherwise.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const isFull = self => self.capacity === undefined ? false : MutableList.length(self.queue) === self.capacity;\n/**\n * The **maximum** number of elements that a queue can hold.\n *\n * **Note**: unbounded queues can still implement this interface with\n * `capacity = Infinity`.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const capacity = self => self.capacity === undefined ? Infinity : self.capacity;\n/**\n * Offers an element to the queue.\n *\n * Returns whether the enqueue was successful or not.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const offer = /*#__PURE__*/Dual.dual(2, (self, value) => {\n  const queueLength = MutableList.length(self.queue);\n  if (self.capacity !== undefined && queueLength === self.capacity) {\n    return false;\n  }\n  MutableList.append(value)(self.queue);\n  return true;\n});\n/**\n * Enqueues a collection of values into the queue.\n *\n * Returns a `List` of the values that were **not** able to be enqueued.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const offerAll = /*#__PURE__*/Dual.dual(2, (self, values) => {\n  const iterator = values[Symbol.iterator]();\n  let next;\n  let remainder = Chunk.empty();\n  let offering = true;\n  while (offering && (next = iterator.next()) && !next.done) {\n    offering = offer(next.value)(self);\n  }\n  while (next != null && !next.done) {\n    remainder = Chunk.prepend(next.value)(remainder);\n    next = iterator.next();\n  }\n  return Chunk.reverse(remainder);\n});\n/**\n * Dequeues an element from the queue.\n *\n * Returns either an element from the queue, or the `def` param.\n *\n * **Note**: if there is no meaningful default for your type, you can always\n * use `poll(MutableQueue.EmptyMutableQueue)`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const poll = /*#__PURE__*/Dual.dual(2, (self, def) => {\n  if (MutableList.isEmpty(self.queue)) {\n    return def;\n  }\n  return MutableList.shift(self.queue);\n});\n/**\n * Dequeues up to `n` elements from the queue.\n *\n * Returns a `List` of up to `n` elements.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const pollUpTo = /*#__PURE__*/Dual.dual(2, (self, n) => {\n  let result = Chunk.empty();\n  let count = 0;\n  while (count < n) {\n    const element = poll(EmptyMutableQueue)(self);\n    if (element === EmptyMutableQueue) {\n      break;\n    }\n    result = Chunk.prepend(element)(result);\n    count += 1;\n  }\n  return Chunk.reverse(result);\n});\n//# sourceMappingURL=MutableQueue.mjs.map","var _a, _b;\nimport * as Debug from \"@effect/io/Debug\";\nimport * as Deferred from \"@effect/io/Deferred\";\nimport * as ExecutionStrategy from \"@effect/io/ExecutionStrategy\";\nimport * as FiberId from \"@effect/io/Fiber/Id\";\nimport * as RuntimeFlagsPatch from \"@effect/io/Fiber/Runtime/Flags/Patch\";\nimport * as FiberStatus from \"@effect/io/Fiber/Status\";\nimport * as internalCause from \"@effect/io/internal_effect_untraced/cause\";\nimport { StackAnnotation } from \"@effect/io/internal_effect_untraced/cause\";\nimport * as clock from \"@effect/io/internal_effect_untraced/clock\";\nimport { configProviderTag } from \"@effect/io/internal_effect_untraced/configProvider\";\nimport * as core from \"@effect/io/internal_effect_untraced/core\";\nimport * as defaultServices from \"@effect/io/internal_effect_untraced/defaultServices\";\nimport * as internalFiber from \"@effect/io/internal_effect_untraced/fiber\";\nimport * as FiberMessage from \"@effect/io/internal_effect_untraced/fiberMessage\";\nimport * as fiberRefs from \"@effect/io/internal_effect_untraced/fiberRefs\";\nimport * as fiberScope from \"@effect/io/internal_effect_untraced/fiberScope\";\nimport * as internalLogger from \"@effect/io/internal_effect_untraced/logger\";\nimport { yieldBackgroundOrContinue } from \"@effect/io/internal_effect_untraced/main-thread\";\nimport * as metric from \"@effect/io/internal_effect_untraced/metric\";\nimport * as metricBoundaries from \"@effect/io/internal_effect_untraced/metric/boundaries\";\nimport * as metricLabel from \"@effect/io/internal_effect_untraced/metric/label\";\nimport * as OpCodes from \"@effect/io/internal_effect_untraced/opCodes/effect\";\nimport * as _runtimeFlags from \"@effect/io/internal_effect_untraced/runtimeFlags\";\nimport * as supervisor from \"@effect/io/internal_effect_untraced/supervisor\";\nimport * as SupervisorPatch from \"@effect/io/internal_effect_untraced/supervisor/patch\";\nimport * as LogLevel from \"@effect/io/Logger/Level\";\nimport * as Ref from \"@effect/io/Ref\";\nimport { identity } from \"@fp-ts/core/Function\";\nimport * as Option from \"@fp-ts/core/Option\";\nimport * as Chunk from \"@fp-ts/data/Chunk\";\nimport * as Context from \"@fp-ts/data/Context\";\nimport * as HashSet from \"@fp-ts/data/HashSet\";\nimport * as MutableQueue from \"@fp-ts/data/MutableQueue\";\nconst fibersStarted = /*#__PURE__*/metric.counter(\"effect_fiber_started\");\nconst fiberSuccesses = /*#__PURE__*/metric.counter(\"effect_fiber_successes\");\nconst fiberFailures = /*#__PURE__*/metric.counter(\"effect_fiber_failures\");\nconst fiberLifetimes = /*#__PURE__*/metric.histogram(\"effect_fiber_lifetimes\", /*#__PURE__*/metricBoundaries.exponential(1.0, 2.0, 100));\n/** @internal */\nconst EvaluationSignalContinue = \"Continue\";\n/** @internal */\nconst EvaluationSignalDone = \"Done\";\n/** @internal */\nconst EvaluationSignalYieldNow = \"Yield\";\n/** @internal */\nconst EvaluationSignalYieldNowInBackground = \"YieldInBackground\";\n/** @internal */\nexport const runtimeFiberVariance = {\n  _E: _ => _,\n  _A: _ => _\n};\nconst absurd = _ => {\n  throw new Error(`BUG: FiberRuntime - ${JSON.stringify(_)} - please report an issue at https://github.com/Effect-TS/io/issues`);\n};\nconst contOpSuccess = {\n  [OpCodes.OP_ON_SUCCESS]: (_, cont, value) => {\n    return cont.successK(value);\n  },\n  [OpCodes.OP_ON_SUCCESS_AND_FAILURE]: (_, cont, value) => {\n    return cont.successK(value);\n  },\n  [OpCodes.OP_REVERT_FLAGS]: (self, cont, value) => {\n    self.patchRuntimeFlags(self._runtimeFlags, cont.patch);\n    if (_runtimeFlags.interruptible(self._runtimeFlags) && self.isInterrupted()) {\n      return core.exitFailCause(self.getInterruptedCause());\n    } else {\n      return core.exitSucceed(value);\n    }\n  },\n  [OpCodes.OP_WHILE]: (self, cont, value) => {\n    cont.process(value);\n    if (cont.check()) {\n      self.pushStack(cont);\n      return cont.body();\n    } else {\n      return core.unit();\n    }\n  }\n};\nconst drainQueueWhileRunningTable = {\n  [FiberMessage.OP_INTERRUPT_SIGNAL]: (self, runtimeFlags, cur, message) => {\n    self.processNewInterruptSignal(message.cause);\n    return _runtimeFlags.interruptible(runtimeFlags) ? core.exitFailCause(message.cause) : cur;\n  },\n  [FiberMessage.OP_RESUME]: (_self, _runtimeFlags, _cur, _message) => {\n    throw new Error(\"It is illegal to have multiple concurrent run loops in a single fiber\");\n  },\n  [FiberMessage.OP_STATEFUL]: (self, runtimeFlags, cur, message) => {\n    message.onFiber(self, FiberStatus.running(runtimeFlags));\n    return cur;\n  },\n  [FiberMessage.OP_YIELD_NOW]: (_self, _runtimeFlags, cur, _message) => {\n    return core.flatMap(() => cur)(core.yieldNow(_message.priority));\n  }\n};\nlet globalErrorSeq = 0;\n/** @internal */\nexport class FiberRuntime {\n  constructor(fiberId, fiberRefs0, runtimeFlags0, runtime) {\n    this.runtime = runtime;\n    this[_a] = internalFiber.fiberVariance;\n    this[_b] = runtimeFiberVariance;\n    this._queue = MutableQueue.unbounded();\n    this._children = null;\n    this._observers = new Array();\n    this._running = false;\n    this._stack = [];\n    this._asyncInterruptor = null;\n    this._asyncBlockingOn = null;\n    this._exitValue = null;\n    this._traceStack = [];\n    this.run = () => {\n      this.drainQueueOnCurrentThread();\n    };\n    this._runtimeFlags = runtimeFlags0;\n    this._fiberId = fiberId;\n    this._fiberRefs = fiberRefs0;\n    if (_runtimeFlags.runtimeMetrics(runtimeFlags0)) {\n      const tags = this.getFiberRef(core.currentTags);\n      fibersStarted.unsafeUpdate(1, tags);\n    }\n  }\n  /**\n   * The identity of the fiber.\n   */\n  id() {\n    return this._fiberId;\n  }\n  /**\n   * Begins execution of the effect associated with this fiber on in the\n   * background. This can be called to \"kick off\" execution of a fiber after\n   * it has been created.\n   */\n  resume(effect) {\n    this.tell(FiberMessage.resume(effect));\n  }\n  /**\n   * The status of the fiber.\n   */\n  status() {\n    return this.ask((_, status) => status);\n  }\n  /**\n   * Gets the fiber runtime flags.\n   */\n  runtimeFlags() {\n    return this.ask((state, status) => {\n      if (FiberStatus.isDone(status)) {\n        return state._runtimeFlags;\n      }\n      return status.runtimeFlags;\n    });\n  }\n  /**\n   * Returns the current `FiberScope` for the fiber.\n   */\n  scope() {\n    return fiberScope.unsafeMake(this);\n  }\n  /**\n   * Retrieves the immediate children of the fiber.\n   */\n  children() {\n    return this.ask(fiber => Chunk.fromIterable(fiber.getChildren()));\n  }\n  /**\n   * Gets the fiber's set of children.\n   */\n  getChildren() {\n    if (this._children === null) {\n      this._children = new Set();\n    }\n    return this._children;\n  }\n  /**\n   * Retrieves the current supervisor the fiber uses for supervising effects.\n   *\n   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked\n   * on this fiber, then values derived from the fiber's state (including the\n   * log annotations and log level) may not be up-to-date.\n   */\n  getSupervisor() {\n    return this.getFiberRef(currentSupervisor);\n  }\n  /**\n   * Retrieves the interrupted cause of the fiber, which will be `Cause.empty`\n   * if the fiber has not been interrupted.\n   *\n   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked\n   * on this fiber, then values derived from the fiber's state (including the\n   * log annotations and log level) may not be up-to-date.\n   */\n  getInterruptedCause() {\n    return this.getFiberRef(core.interruptedCause);\n  }\n  /**\n   * Retrieves the whole set of fiber refs.\n   */\n  fiberRefs() {\n    return this.ask(fiber => fiber.unsafeGetFiberRefs());\n  }\n  /**\n   * Returns an effect that will contain information computed from the fiber\n   * state and status while running on the fiber.\n   *\n   * This allows the outside world to interact safely with mutable fiber state\n   * without locks or immutable data.\n   */\n  ask(f) {\n    return Debug.untraced(() => core.suspendSucceed(() => {\n      const deferred = core.deferredUnsafeMake(this._fiberId);\n      this.tell(FiberMessage.stateful((fiber, status) => {\n        core.deferredUnsafeDone(deferred, core.sync(() => f(fiber, status)));\n      }));\n      return core.deferredAwait(deferred);\n    }));\n  }\n  /**\n   * Adds a message to be processed by the fiber on the fiber.\n   */\n  tell(message) {\n    MutableQueue.offer(message)(this._queue);\n    if (!this._running) {\n      this._running = true;\n      this.drainQueueLaterOnExecutor(\"normal\");\n    }\n  }\n  await() {\n    return Debug.untraced(() => core.asyncInterrupt(resume => {\n      const cb = exit => resume(core.succeed(exit));\n      this.tell(FiberMessage.stateful((fiber, _) => {\n        if (fiber._exitValue !== null) {\n          cb(this._exitValue);\n        } else {\n          fiber.unsafeAddObserver(cb);\n        }\n      }));\n      return core.sync(() => this.tell(FiberMessage.stateful((fiber, _) => {\n        fiber.unsafeRemoveObserver(cb);\n      })));\n    }, this.id()));\n  }\n  inheritAll() {\n    return Debug.untraced(() => core.withFiberRuntime((parentFiber, parentStatus) => {\n      const parentFiberId = parentFiber.id();\n      const parentFiberRefs = parentFiber.unsafeGetFiberRefs();\n      const parentRuntimeFlags = parentStatus.runtimeFlags;\n      const childFiberRefs = this.unsafeGetFiberRefs();\n      const updatedFiberRefs = fiberRefs.joinAs(parentFiberRefs, parentFiberId, childFiberRefs);\n      parentFiber.setFiberRefs(updatedFiberRefs);\n      const updatedRuntimeFlags = parentFiber.getFiberRef(currentRuntimeFlags);\n      const patch = RuntimeFlagsPatch.exclude(_runtimeFlags.WindDown)(\n      // Do not inherit WindDown or Interruption!\n      RuntimeFlagsPatch.exclude(_runtimeFlags.Interruption)(_runtimeFlags.diff(parentRuntimeFlags, updatedRuntimeFlags)));\n      return core.updateRuntimeFlags(patch);\n    }));\n  }\n  /**\n   * Tentatively observes the fiber, but returns immediately if it is not\n   * already done.\n   */\n  poll() {\n    return Debug.untraced(() => core.sync(() => Option.fromNullable(this._exitValue)));\n  }\n  /**\n   * Unsafely observes the fiber, but returns immediately if it is not\n   * already done.\n   */\n  unsafePoll() {\n    return this._exitValue;\n  }\n  /**\n   * In the background, interrupts the fiber as if interrupted from the specified fiber.\n   */\n  interruptAsFork(fiberId) {\n    return Debug.untraced(() => core.sync(() => this.tell(FiberMessage.interruptSignal(internalCause.interrupt(fiberId)))));\n  }\n  /**\n   * Adds an observer to the list of observers.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  unsafeAddObserver(observer) {\n    if (this._exitValue !== null) {\n      observer(this._exitValue);\n    } else {\n      this._observers.push(observer);\n    }\n  }\n  /**\n   * Removes the specified observer from the list of observers that will be\n   * notified when the fiber exits.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  unsafeRemoveObserver(observer) {\n    this._observers = this._observers.filter(o => o !== observer);\n  }\n  /**\n   * Retrieves all fiber refs of the fiber.\n   *\n   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked\n   * on this fiber, then values derived from the fiber's state (including the\n   * log annotations and log level) may not be up-to-date.\n   */\n  unsafeGetFiberRefs() {\n    this.setFiberRef(currentRuntimeFlags, this._runtimeFlags);\n    return this._fiberRefs;\n  }\n  /**\n   * Deletes the specified fiber ref.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  unsafeDeleteFiberRef(fiberRef) {\n    this._fiberRefs = fiberRefs.delete_(this._fiberRefs, fiberRef);\n  }\n  /**\n   * Retrieves the state of the fiber ref, or else its initial value.\n   *\n   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked\n   * on this fiber, then values derived from the fiber's state (including the\n   * log annotations and log level) may not be up-to-date.\n   */\n  getFiberRef(fiberRef) {\n    return fiberRefs.getOrDefault(this._fiberRefs, fiberRef);\n  }\n  /**\n   * Sets the fiber ref to the specified value.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  setFiberRef(fiberRef, value) {\n    this._fiberRefs = fiberRefs.updatedAs(this._fiberRefs, this._fiberId, fiberRef, value);\n  }\n  /**\n   * Wholesale replaces all fiber refs of this fiber.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  setFiberRefs(fiberRefs) {\n    this._fiberRefs = fiberRefs;\n  }\n  /**\n   * Adds a reference to the specified fiber inside the children set.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  addChild(child) {\n    this.getChildren().add(child);\n  }\n  /**\n   * Removes a reference to the specified fiber inside the children set.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  removeChild(child) {\n    this.getChildren().delete(child);\n  }\n  /**\n   * On the current thread, executes all messages in the fiber's inbox. This\n   * method may return before all work is done, in the event the fiber executes\n   * an asynchronous operation.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  drainQueueOnCurrentThread() {\n    let recurse = true;\n    while (recurse) {\n      let evaluationSignal = EvaluationSignalContinue;\n      const prev = globalThis[internalFiber.currentFiberURI];\n      globalThis[internalFiber.currentFiberURI] = this;\n      try {\n        while (evaluationSignal === EvaluationSignalContinue) {\n          evaluationSignal = MutableQueue.isEmpty(this._queue) ? EvaluationSignalDone : this.evaluateMessageWhileSuspended(MutableQueue.poll(null)(this._queue));\n        }\n      } finally {\n        this._running = false;\n        globalThis[internalFiber.currentFiberURI] = prev;\n      }\n      // Maybe someone added something to the queue between us checking, and us\n      // giving up the drain. If so, we need to restart the draining, but only\n      // if we beat everyone else to the restart:\n      if (!MutableQueue.isEmpty(this._queue) && !this._running) {\n        this._running = true;\n        if (evaluationSignal === EvaluationSignalYieldNow) {\n          this.drainQueueLaterOnExecutor(\"normal\");\n          recurse = false;\n        } else if (evaluationSignal === EvaluationSignalYieldNowInBackground) {\n          this.drainQueueLaterOnExecutor(\"background\");\n          recurse = false;\n        } else {\n          recurse = true;\n        }\n      } else {\n        recurse = false;\n      }\n    }\n  }\n  /**\n   * Schedules the execution of all messages in the fiber's inbox.\n   *\n   * This method will return immediately after the scheduling\n   * operation is completed, but potentially before such messages have been\n   * executed.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  drainQueueLaterOnExecutor(priority) {\n    if (priority === \"normal\") {\n      this.getFiberRef(core.currentScheduler).scheduleTask(this.run);\n    } else {\n      yieldBackgroundOrContinue().then(() => {\n        this.run();\n      });\n    }\n  }\n  /**\n   * Drains the fiber's message queue while the fiber is actively running,\n   * returning the next effect to execute, which may be the input effect if no\n   * additional effect needs to be executed.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  drainQueueWhileRunning(runtimeFlags, cur0) {\n    let cur = cur0;\n    while (!MutableQueue.isEmpty(this._queue)) {\n      const message = MutableQueue.poll(void 0)(this._queue);\n      // @ts-expect-error\n      cur = drainQueueWhileRunningTable[message._tag](this, runtimeFlags, cur, message);\n    }\n    return cur;\n  }\n  /**\n   * Determines if the fiber is interrupted.\n   *\n   * **NOTE**: This method is safe to invoke on any fiber, but if not invoked\n   * on this fiber, then values derived from the fiber's state (including the\n   * log annotations and log level) may not be up-to-date.\n   */\n  isInterrupted() {\n    return !internalCause.isEmpty(this.getFiberRef(core.interruptedCause));\n  }\n  /**\n   * Adds an interruptor to the set of interruptors that are interrupting this\n   * fiber.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  addInterruptedCause(cause) {\n    const oldSC = this.getFiberRef(core.interruptedCause);\n    this.setFiberRef(core.interruptedCause, internalCause.sequential(oldSC, cause));\n  }\n  /**\n   * Processes a new incoming interrupt signal.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  processNewInterruptSignal(cause) {\n    this.addInterruptedCause(cause);\n    this.sendInterruptSignalToAllChildren();\n  }\n  /**\n   * Interrupts all children of the current fiber, returning an effect that will\n   * await the exit of the children. This method will return null if the fiber\n   * has no children.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  sendInterruptSignalToAllChildren() {\n    if (this._children === null || this._children.size === 0) {\n      return false;\n    }\n    let told = false;\n    for (const child of this._children) {\n      child.tell(FiberMessage.interruptSignal(internalCause.interrupt(this.id())));\n      told = true;\n    }\n    return told;\n  }\n  /**\n   * Interrupts all children of the current fiber, returning an effect that will\n   * await the exit of the children. This method will return null if the fiber\n   * has no children.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  interruptAllChildren() {\n    if (this.sendInterruptSignalToAllChildren()) {\n      const it = this._children.values();\n      this._children = null;\n      let isDone = false;\n      const body = () => {\n        const next = it.next();\n        if (!next.done) {\n          return core.asUnit(next.value.await());\n        } else {\n          return core.sync(() => {\n            isDone = true;\n          });\n        }\n      };\n      return core.whileLoop(() => !isDone, () => body(), () => {\n        //\n      });\n    }\n    return null;\n  }\n  reportExitValue(exit) {\n    if (_runtimeFlags.runtimeMetrics(this._runtimeFlags)) {\n      const tags = this.getFiberRef(core.currentTags);\n      switch (exit._tag) {\n        case OpCodes.OP_SUCCESS:\n          {\n            fiberSuccesses.unsafeUpdate(1, tags);\n            break;\n          }\n        case OpCodes.OP_FAILURE:\n          {\n            fiberFailures.unsafeUpdate(1, tags);\n            break;\n          }\n      }\n    }\n  }\n  setExitValue(exit) {\n    this._exitValue = exit;\n    if (_runtimeFlags.runtimeMetrics(this._runtimeFlags)) {\n      const tags = this.getFiberRef(core.currentTags);\n      const startTimeMillis = this.id().startTimeMillis;\n      const endTimeMillis = new Date().getTime();\n      fiberLifetimes.unsafeUpdate((endTimeMillis - startTimeMillis) / 1000.0, tags);\n    }\n    this.reportExitValue(exit);\n    for (let i = this._observers.length - 1; i >= 0; i--) {\n      this._observers[i](exit);\n    }\n  }\n  getLoggers() {\n    return this.getFiberRef(currentLoggers);\n  }\n  log(message, cause, overrideLogLevel) {\n    const logLevel = Option.isSome(overrideLogLevel) ? overrideLogLevel.value : this.getFiberRef(core.currentLogLevel);\n    const spans = this.getFiberRef(core.currentLogSpan);\n    const annotations = this.getFiberRef(core.currentLogAnnotations);\n    const loggers = this.getLoggers();\n    const contextMap = this.unsafeGetFiberRefs();\n    HashSet.forEach(logger => {\n      logger.log(this.id(), logLevel, message, cause, contextMap, spans, annotations, this.runtime);\n    })(loggers);\n  }\n  /**\n   * Evaluates a single message on the current thread, while the fiber is\n   * suspended. This method should only be called while evaluation of the\n   * fiber's effect is suspended due to an asynchronous operation.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  evaluateMessageWhileSuspended(message) {\n    switch (message._tag) {\n      case FiberMessage.OP_YIELD_NOW:\n        {\n          return message.priority === \"background\" ? EvaluationSignalYieldNowInBackground : EvaluationSignalYieldNow;\n        }\n      case FiberMessage.OP_INTERRUPT_SIGNAL:\n        {\n          this.processNewInterruptSignal(message.cause);\n          if (this._asyncInterruptor !== null) {\n            this._asyncInterruptor(core.exitFailCause(message.cause));\n            this._asyncInterruptor = null;\n          }\n          return EvaluationSignalContinue;\n        }\n      case FiberMessage.OP_RESUME:\n        {\n          this._asyncInterruptor = null;\n          this._asyncBlockingOn = null;\n          this.evaluateEffect(message.effect);\n          return EvaluationSignalContinue;\n        }\n      case FiberMessage.OP_STATEFUL:\n        {\n          message.onFiber(this, this._exitValue !== null ? FiberStatus.done : FiberStatus.suspended(this._runtimeFlags, this._asyncBlockingOn));\n          return EvaluationSignalContinue;\n        }\n      default:\n        {\n          return absurd(message);\n        }\n    }\n  }\n  /**\n   * Evaluates an effect until completion, potentially asynchronously.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  evaluateEffect(effect0) {\n    this.getSupervisor().onResume(this);\n    try {\n      let effect = _runtimeFlags.interruptible(this._runtimeFlags) && this.isInterrupted() ? core.exitFailCause(this.getInterruptedCause()) : effect0;\n      while (effect !== null) {\n        try {\n          const exit = this.runLoop(effect);\n          this._runtimeFlags = _runtimeFlags.enable(_runtimeFlags.WindDown)(this._runtimeFlags);\n          const interruption = this.interruptAllChildren();\n          if (interruption !== null) {\n            effect = Debug.untraced(() => core.flatMap(interruption, () => exit));\n          } else {\n            if (MutableQueue.isEmpty(this._queue)) {\n              // No more messages to process, so we will allow the fiber to end life:\n              this.setExitValue(exit);\n            } else {\n              // There are messages, possibly added by the final op executed by\n              // the fiber. To be safe, we should execute those now before we\n              // allow the fiber to end life:\n              this.tell(FiberMessage.resume(exit));\n            }\n            effect = null;\n          }\n        } catch (e) {\n          if (core.isEffect(e)) {\n            if (e._tag === OpCodes.OP_YIELD) {\n              if (_runtimeFlags.cooperativeYielding(this._runtimeFlags)) {\n                this.tell(FiberMessage.yieldNow(e.priority));\n                this.tell(FiberMessage.resume(core.exitUnit()));\n                effect = null;\n              } else {\n                effect = core.exitUnit();\n              }\n            } else if (e._tag === OpCodes.OP_ASYNC) {\n              // Terminate this evaluation, async resumption will continue evaluation:\n              effect = null;\n            }\n          } else {\n            throw e;\n          }\n        }\n      }\n    } finally {\n      this.getSupervisor().onSuspend(this);\n    }\n  }\n  /**\n   * Begins execution of the effect associated with this fiber on the current\n   * thread. This can be called to \"kick off\" execution of a fiber after it has\n   * been created, in hopes that the effect can be executed synchronously.\n   *\n   * This is not the normal way of starting a fiber, but it is useful when the\n   * express goal of executing the fiber is to synchronously produce its exit.\n   */\n  start(effect) {\n    if (!this._running) {\n      this._running = true;\n      const prev = globalThis[internalFiber.currentFiberURI];\n      globalThis[internalFiber.currentFiberURI] = this;\n      try {\n        this.evaluateEffect(effect);\n      } finally {\n        this._running = false;\n        globalThis[internalFiber.currentFiberURI] = prev;\n        // Because we're special casing `start`, we have to be responsible\n        // for spinning up the fiber if there were new messages added to\n        // the queue between the completion of the effect and the transition\n        // to the not running state.\n        if (!MutableQueue.isEmpty(this._queue)) {\n          this.drainQueueLaterOnExecutor(\"normal\");\n        }\n      }\n    } else {\n      this.tell(FiberMessage.resume(effect));\n    }\n  }\n  /**\n   * Begins execution of the effect associated with this fiber on in the\n   * background, and on the correct thread pool. This can be called to \"kick\n   * off\" execution of a fiber after it has been created, in hopes that the\n   * effect can be executed synchronously.\n   */\n  startFork(effect) {\n    this.tell(FiberMessage.resume(effect));\n  }\n  /**\n   * Takes the current runtime flags, patches them to return the new runtime\n   * flags, and then makes any changes necessary to fiber state based on the\n   * specified patch.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  patchRuntimeFlags(oldRuntimeFlags, patch) {\n    const newRuntimeFlags = _runtimeFlags.patch(oldRuntimeFlags, patch);\n    globalThis[internalFiber.currentFiberURI] = this;\n    this._runtimeFlags = newRuntimeFlags;\n    return newRuntimeFlags;\n  }\n  /**\n   * Initiates an asynchronous operation, by building a callback that will\n   * resume execution, and then feeding that callback to the registration\n   * function, handling error cases and repeated resumptions appropriately.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  initiateAsync(runtimeFlags, asyncRegister) {\n    let alreadyCalled = false;\n    const callback = effect => {\n      if (!alreadyCalled) {\n        alreadyCalled = true;\n        this.tell(FiberMessage.resume(effect));\n      }\n    };\n    if (_runtimeFlags.interruptible(runtimeFlags)) {\n      this._asyncInterruptor = callback;\n    }\n    try {\n      asyncRegister(callback);\n    } catch (e) {\n      callback(core.failCause(internalCause.die(e)));\n    }\n  }\n  pushStack(cont) {\n    this._stack.push(cont);\n    if (\"trace\" in cont && cont.trace) {\n      this._traceStack.push(cont.trace);\n    }\n  }\n  popStack() {\n    const item = this._stack.pop();\n    if (item) {\n      if (\"trace\" in item && item.trace) {\n        this._traceStack.pop();\n      }\n      return item;\n    }\n    return;\n  }\n  getNextSuccessCont() {\n    let frame = this.popStack();\n    while (frame) {\n      if (frame._tag !== OpCodes.OP_ON_FAILURE && frame._tag !== OpCodes.OP_TRACED) {\n        return frame;\n      }\n      frame = this.popStack();\n    }\n  }\n  getNextFailCont() {\n    let frame = this.popStack();\n    while (frame) {\n      if (frame._tag !== OpCodes.OP_ON_SUCCESS && frame._tag !== OpCodes.OP_WHILE && frame._tag !== OpCodes.OP_TRACED) {\n        return frame;\n      }\n      frame = this.popStack();\n    }\n  }\n  [(_a = internalFiber.FiberTypeId, _b = internalFiber.RuntimeFiberTypeId, OpCodes.OP_SYNC)](op) {\n    const value = op.evaluate();\n    const cont = this.getNextSuccessCont();\n    if (cont !== undefined) {\n      if (!(cont._tag in contOpSuccess)) {\n        // @ts-expect-error\n        absurd(cont);\n      }\n      // @ts-expect-error\n      return contOpSuccess[cont._tag](this, cont, value);\n    } else {\n      throw core.exitSucceed(value);\n    }\n  }\n  [OpCodes.OP_SUCCESS](op) {\n    const oldCur = op;\n    const cont = this.getNextSuccessCont();\n    if (cont !== undefined) {\n      if (!(cont._tag in contOpSuccess)) {\n        // @ts-expect-error\n        absurd(cont);\n      }\n      // @ts-expect-error\n      return contOpSuccess[cont._tag](this, cont, oldCur.value);\n    } else {\n      throw oldCur;\n    }\n  }\n  [OpCodes.OP_FAILURE](op) {\n    let cause = op.cause;\n    if (internalCause.isAnnotatedType(cause) && internalCause.isStackAnnotation(cause.annotation)) {\n      const stack = cause.annotation.stack;\n      const currentStack = this.stackToLines();\n      cause = internalCause.annotated(cause.cause, new StackAnnotation(Chunk.take(Debug.runtimeDebug.traceStackLimit)(Chunk.dedupeAdjacent(stack.length === 0 ? currentStack : currentStack.length === 0 ? stack : Chunk.unsafeLast(stack) === Chunk.unsafeLast(currentStack) ? stack : Chunk.concat(currentStack)(stack))), cause.annotation.seq));\n    } else {\n      cause = internalCause.annotated(op.cause, new StackAnnotation(this.stackToLines(), globalErrorSeq++));\n    }\n    const cont = this.getNextFailCont();\n    if (cont !== undefined) {\n      switch (cont._tag) {\n        case OpCodes.OP_ON_FAILURE:\n        case OpCodes.OP_ON_SUCCESS_AND_FAILURE:\n          {\n            if (!(_runtimeFlags.interruptible(this._runtimeFlags) && this.isInterrupted())) {\n              return cont.failK(cause);\n            } else {\n              return core.exitFailCause(internalCause.stripFailures(cause));\n            }\n          }\n        case OpCodes.OP_REVERT_FLAGS:\n          {\n            this.patchRuntimeFlags(this._runtimeFlags, cont.patch);\n            if (_runtimeFlags.interruptible(this._runtimeFlags) && this.isInterrupted()) {\n              return core.exitFailCause(internalCause.sequential(cause, this.getInterruptedCause()));\n            } else {\n              return core.exitFailCause(cause);\n            }\n          }\n        default:\n          {\n            absurd(cont);\n          }\n      }\n    } else {\n      throw core.exitFailCause(cause);\n    }\n  }\n  [OpCodes.OP_WITH_RUNTIME](op) {\n    return op.withRuntime(this, FiberStatus.running(this._runtimeFlags));\n  }\n  [OpCodes.OP_UPDATE_RUNTIME_FLAGS](op) {\n    if (op.scope === undefined) {\n      this.patchRuntimeFlags(this._runtimeFlags, op.update);\n      return core.exitUnit();\n    } else {\n      const updateFlags = op.update;\n      const oldRuntimeFlags = this._runtimeFlags;\n      const newRuntimeFlags = _runtimeFlags.patch(oldRuntimeFlags, updateFlags);\n      if (newRuntimeFlags === oldRuntimeFlags) {\n        // No change, short circuit\n        return op.scope(oldRuntimeFlags);\n      } else {\n        // One more chance to short circuit: if we're immediately going\n        // to interrupt. Interruption will cause immediate reversion of\n        // the flag, so as long as we \"peek ahead\", there's no need to\n        // set them to begin with.\n        if (_runtimeFlags.interruptible(newRuntimeFlags) && this.isInterrupted()) {\n          return core.exitFailCause(this.getInterruptedCause());\n        } else {\n          // Impossible to short circuit, so record the changes\n          this.patchRuntimeFlags(this._runtimeFlags, updateFlags);\n          // Since we updated the flags, we need to revert them\n          const revertFlags = _runtimeFlags.diff(newRuntimeFlags, oldRuntimeFlags);\n          this.pushStack(new core.RevertFlags(revertFlags));\n          return op.scope(oldRuntimeFlags);\n        }\n      }\n    }\n  }\n  [OpCodes.OP_ON_SUCCESS](op) {\n    this.pushStack(op);\n    return op.first;\n  }\n  [OpCodes.OP_TRACED](op) {\n    this.pushStack(op);\n    return op.self;\n  }\n  [OpCodes.OP_ON_FAILURE](op) {\n    this.pushStack(op);\n    return op.first;\n  }\n  [OpCodes.OP_ON_SUCCESS_AND_FAILURE](op) {\n    this.pushStack(op);\n    return op.first;\n  }\n  [OpCodes.OP_ASYNC](op) {\n    this._asyncBlockingOn = op.blockingOn;\n    this.initiateAsync(this._runtimeFlags, op.register);\n    throw op;\n  }\n  [OpCodes.OP_YIELD](op) {\n    throw op;\n  }\n  [OpCodes.OP_WHILE](op) {\n    const check = op.check;\n    const body = op.body;\n    if (check()) {\n      this.pushStack(op);\n      return body();\n    } else {\n      return core.exitUnit();\n    }\n  }\n  [OpCodes.OP_COMMIT](op) {\n    return op.commit();\n  }\n  /**\n   * The main run-loop for evaluating effects.\n   *\n   * **NOTE**: This method must be invoked by the fiber itself.\n   */\n  runLoop(effect0) {\n    let cur = effect0;\n    let ops = 0;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      if (_runtimeFlags.opSupervision(this._runtimeFlags)) {\n        this.getSupervisor().onEffect(this, cur);\n      }\n      cur = this.drainQueueWhileRunning(this._runtimeFlags, cur);\n      ops += 1;\n      if (ops >= 2048) {\n        ops = 0;\n        const oldCur = cur;\n        cur = core.flatMap(() => oldCur)(core.yieldNow());\n      }\n      try {\n        if (!(cur._tag in this)) {\n          // @ts-expect-error\n          absurd(cur);\n        }\n        // @ts-expect-error\n        cur = this[cur._tag](cur);\n      } catch (e) {\n        if (core.isEffect(e)) {\n          if (e._tag === OpCodes.OP_YIELD || e._tag === OpCodes.OP_ASYNC) {\n            throw e;\n          }\n          if (e._tag === OpCodes.OP_SUCCESS || e._tag === OpCodes.OP_FAILURE) {\n            return e;\n          }\n        } else {\n          if (core.isEffectError(e)) {\n            cur = core.exitFailCause(e.cause);\n          } else if (internalCause.isInterruptedException(e)) {\n            cur = core.exitFailCause(internalCause.sequential(internalCause.die(e), internalCause.interrupt(FiberId.none)));\n          } else {\n            cur = core.exitFailCause(internalCause.die(e));\n          }\n        }\n      }\n    }\n  }\n  stackToLines() {\n    if (this._traceStack.length === 0) {\n      return Chunk.empty();\n    }\n    const lines = [];\n    let current = this._stack.length - 1;\n    while (current >= 0 && lines.length < Debug.runtimeDebug.traceStackLimit) {\n      const value = this._stack[current];\n      switch (value._tag) {\n        case OpCodes.OP_TRACED:\n          {\n            if (value.trace) {\n              lines.push(value.trace);\n            }\n            break;\n          }\n      }\n      current = current - 1;\n    }\n    return Chunk.unsafeFromArray(lines);\n  }\n}\n// circular with Logger\n/** @internal */\nexport const currentMinimumLogLevel = /*#__PURE__*/core.fiberRefUnsafeMake( /*#__PURE__*/LogLevel.fromLiteral(Debug.runtimeDebug.minumumLogLevel));\n/** @internal */\nexport const defaultLogger = /*#__PURE__*/internalLogger.makeLogger((fiberId, logLevel, message, cause, context, spans, annotations, runtime) => {\n  const formatted = internalLogger.stringLogger.log(fiberId, logLevel, message, cause, context, spans, annotations, runtime);\n  const filter = fiberRefs.getOrDefault(context, currentMinimumLogLevel);\n  if (LogLevel.greaterThanEqual(filter)(logLevel)) {\n    globalThis.console.log(formatted);\n  }\n});\n/** @internal */\nexport const logFmtLogger = /*#__PURE__*/internalLogger.makeLogger((fiberId, logLevel, message, cause, context, spans, annotations, runtime) => {\n  const formatted = internalLogger.logfmtLogger.log(fiberId, logLevel, message, cause, context, spans, annotations, runtime);\n  const filter = fiberRefs.getOrDefault(context, currentMinimumLogLevel);\n  if (LogLevel.greaterThanEqual(filter)(logLevel)) {\n    globalThis.console.log(formatted);\n  }\n});\n/** @internal */\nexport const currentLoggers = /*#__PURE__*/core.fiberRefUnsafeMakeHashSet( /*#__PURE__*/HashSet.make(defaultLogger));\n// circular with Effect\n/* @internal */\nexport const acquireRelease = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (acquire, release) => core.uninterruptible(core.tap(acquire, a => addFinalizer(exit => restore(release)(a, exit)))).traced(trace));\n/* @internal */\nexport const addFinalizer = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => finalizer => core.flatMap(core.context(), context => core.flatMap(scope(), scope => core.scopeAddFinalizerExit(scope, exit => core.asUnit(core.provideContext(context)(restore(finalizer)(exit)))))).traced(trace));\n/* @internal */\nexport const collect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => core.map(Chunk.compact)(core.forEach(elements, a => unsome(restore(f)(a)))).traced(trace));\n/* @internal */\nexport const collectPar = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => core.map(Chunk.compact)(forEachPar(elements, a => unsome(restore(f)(a)))).traced(trace));\n/* @internal */\nexport const collectAllPar = /*#__PURE__*/Debug.methodWithTrace(trace => effects => forEachPar(effects, identity).traced(trace));\n/* @internal */\nexport const collectAllParDiscard = /*#__PURE__*/Debug.methodWithTrace(trace => effects => forEachParDiscard(effects, identity).traced(trace));\n/* @internal */\nexport const collectAllSuccessesPar = /*#__PURE__*/Debug.methodWithTrace(trace => elements => collectAllWithPar(Array.from(elements).map(core.exit), exit => core.exitIsSuccess(exit) ? Option.some(exit.value) : Option.none()).traced(trace));\n/* @internal */\nexport const collectAllWithPar = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, pf) => core.map(collectAllPar(elements), Chunk.filterMap(restore(pf))).traced(trace));\n/* @internal */\nexport const daemonChildren = /*#__PURE__*/Debug.methodWithTrace(trace => self => {\n  const forkScope = core.fiberRefLocally(core.forkScopeOverride, Option.some(fiberScope.globalScope));\n  return forkScope(self).traced(trace);\n});\n/** @internal */\nconst _existsParFound = /*#__PURE__*/Symbol(\"@effect/io/Effect/existsPar/found\");\n/* @internal */\nexport const existsPar = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => core.matchEffect(forEachPar(elements, a => core.ifEffect(restore(f)(a), core.fail(_existsParFound), core.unit())), e => e === _existsParFound ? core.succeed(true) : core.fail(e), () => core.succeed(false)).traced(trace));\n/* @internal */\nexport const filterPar = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => core.map(Chunk.compact)(forEachPar(elements, a => core.map(restore(f)(a), b => b ? Option.some(a) : Option.none()))).traced(trace));\n/* @internal */\nexport const filterNotPar = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => filterPar(elements, a => core.map(restore(f)(a), b => !b)).traced(trace));\n/* @internal */\nexport const forEachExec = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (elements, f, strategy) => core.suspendSucceed(() => ExecutionStrategy.match(() => core.forEach(restore(f))(elements), () => core.withParallelismUnbounded(forEachPar(restore(f))(elements)), parallelism => core.withParallelism(parallelism)(forEachPar(restore(f))(elements)))(strategy)).traced(trace));\n/* @internal */\nexport const forEachPar = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.fiberRefGetWith(core.currentParallelism, o => o._tag === \"None\" ? forEachParUnbounded(self, restore(f)) : forEachParN(self, o.value, f)).traced(trace));\n/* @internal */\nexport const forEachParDiscard = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.fiberRefGetWith(core.currentParallelism, o => o._tag === \"None\" ? forEachParUnboundedDiscard(self, restore(f)) : forEachParNDiscard(self, o.value, f)).traced(trace));\n/* @internal */\nconst forEachParUnbounded = (self, f) => core.suspendSucceed(() => {\n  const as = Array.from(self).map((v, i) => [v, i]);\n  const array = new Array(as.length);\n  const fn = ([a, i]) => core.flatMap(f(a), b => core.sync(() => array[i] = b));\n  return core.zipRight(forEachParUnboundedDiscard(as, fn), core.succeed(Chunk.unsafeFromArray(array)));\n});\n/* @internal */\nconst forEachParUnboundedDiscard = (self, f) => core.suspendSucceed(() => {\n  const as = Array.from(self);\n  const size = as.length;\n  if (size === 0) {\n    return core.unit();\n  } else if (size === 1) {\n    return core.asUnit(f(as[0]));\n  }\n  return core.uninterruptibleMask(restore => {\n    const deferred = core.deferredUnsafeMake(FiberId.none);\n    let ref = 0;\n    const process = core.transplant(graft => core.forEach(as, a => forkDaemon(graft(core.matchCauseEffect(cause => core.zipRight(core.deferredFail(deferred, void 0), core.failCause(cause)), () => {\n      if (ref + 1 === size) {\n        core.deferredUnsafeDone(deferred, core.unit());\n      } else {\n        ref = ref + 1;\n      }\n      return core.unit();\n    })(restore(core.suspendSucceed(() => f(a))))))));\n    return core.flatMap(process, fibers => core.matchCauseEffect(restore(core.deferredAwait(deferred)), cause => core.flatMap(forEachParUnbounded(fibers, core.interruptFiber), exits => {\n      const exit = core.exitCollectAllPar(exits);\n      if (exit._tag === \"Some\" && core.exitIsFailure(exit.value)) {\n        return core.failCause(internalCause.parallel(internalCause.stripFailures(cause), exit.value.cause));\n      } else {\n        return core.failCause(internalCause.stripFailures(cause));\n      }\n    }), () => core.forEachDiscard(fibers, f => f.inheritAll())));\n  });\n});\n/* @internal */\nconst forEachParN = (self, n, f) => core.suspendSucceed(() => {\n  const as = Array.from(self).map((v, i) => [v, i]);\n  const array = new Array(as.length);\n  const fn = ([a, i]) => core.map(f(a), b => array[i] = b);\n  return core.zipRight(forEachParNDiscard(as, n, fn), core.succeed(Chunk.unsafeFromArray(array)));\n});\n/* @internal */\nconst forEachParNDiscard = (self, n, f) => core.suspendSucceed(() => {\n  const iterator = self[Symbol.iterator]();\n  const worker = core.flatMap(core.sync(() => iterator.next()), next => next.done ? core.unit() : core.flatMap(core.asUnit(f(next.value)), () => worker));\n  const effects = [];\n  for (let i = 0; i < n; i++) {\n    effects.push(worker);\n  }\n  return forEachParUnboundedDiscard(effects, identity);\n});\n/* @internal */\nexport const forEachParWithIndex = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => core.suspendSucceed(() => core.flatMap(core.sync(() => []), array => core.map(forEachParDiscard(Array.from(elements).map((a, i) => [a, i]), ([a, i]) => core.flatMap(core.suspendSucceed(() => restore(f)(a, i)), b => core.sync(() => {\n  array[i] = b;\n}))), () => Chunk.unsafeFromArray(array)))).traced(trace));\n/* @internal */\nexport const fork = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.withFiberRuntime((state, status) => core.succeed(unsafeFork(self, state, status.runtimeFlags))).traced(trace));\n/* @internal */\nexport const forkAllDiscard = /*#__PURE__*/Debug.methodWithTrace(trace => effects => core.forEachDiscard(effects, fork).traced(trace));\n/* @internal */\nexport const forkDaemon = /*#__PURE__*/Debug.methodWithTrace(trace => self => forkWithScopeOverride(self, fiberScope.globalScope).traced(trace));\n/* @internal */\nexport const forkWithErrorHandler = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, handler) => fork(core.onError(self, cause => {\n  const either = internalCause.failureOrCause(cause);\n  switch (either._tag) {\n    case \"Left\":\n      {\n        return restore(handler)(either.left);\n      }\n    case \"Right\":\n      {\n        return core.failCause(either.right);\n      }\n  }\n})).traced(trace));\n/** @internal */\nexport const unsafeFork = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {\n  const childFiber = unsafeMakeChildFiber(effect, parentFiber, parentRuntimeFlags, overrideScope);\n  childFiber.resume(effect);\n  return childFiber;\n};\n/** @internal */\nexport const unsafeMakeChildFiber = (effect, parentFiber, parentRuntimeFlags, overrideScope = null) => {\n  const childId = FiberId.unsafeMake();\n  const parentFiberRefs = parentFiber.unsafeGetFiberRefs();\n  const childFiberRefs = fiberRefs.forkAs(parentFiberRefs, childId);\n  const childFiber = new FiberRuntime(childId, childFiberRefs, parentRuntimeFlags, parentFiber.runtime);\n  const childContext = fiberRefs.getOrDefault(childFiberRefs, core.currentContext);\n  const supervisor = childFiber.getSupervisor();\n  supervisor.onStart(childContext, effect, Option.some(parentFiber), childFiber);\n  childFiber.unsafeAddObserver(exit => supervisor.onEnd(exit, childFiber));\n  const parentScope = overrideScope !== null ? overrideScope : Option.getOrElse(() => parentFiber.scope())(parentFiber.getFiberRef(core.forkScopeOverride));\n  parentScope.add(parentRuntimeFlags, childFiber);\n  return childFiber;\n};\n/* @internal */\nconst forkWithScopeOverride = (self, scopeOverride) => core.withFiberRuntime((parentFiber, parentStatus) => core.succeed(unsafeFork(self, parentFiber, parentStatus.runtimeFlags, scopeOverride)));\n/* @internal */\nexport const mergeAllPar = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (elements, zero, f) => core.flatMap(Ref.make(zero), acc => core.flatMap(forEachParDiscard(elements, core.flatMap(a => Ref.update(acc, b => restore(f)(b, a)))), () => Ref.get(acc))).traced(trace));\n/* @internal */\nexport const onDone = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restoreTrace) => (self, onError, onSuccess) => core.uninterruptibleMask(restore => core.asUnit(forkDaemon(core.matchEffect(restore(self), e => restore(restoreTrace(onError)(e)), a => restore(restoreTrace(onSuccess)(a))))).traced(trace)));\n/* @internal */\nexport const onDoneCause = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restoreTrace) => (self, onCause, onSuccess) => core.uninterruptibleMask(restore => core.asUnit(forkDaemon(core.matchCauseEffect(restore(self), c => restore(restoreTrace(onCause)(c)), a => restore(restoreTrace(onSuccess)(a)))))).traced(trace));\n/* @internal */\nexport const partitionPar = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => core.map(chunk => core.partitionMap(chunk, identity))(forEachPar(elements, a => core.either(restore(f)(a)))).traced(trace));\n/* @internal */\nexport const raceAll = /*#__PURE__*/Debug.methodWithTrace(trace => all => {\n  const list = Chunk.fromIterable(all);\n  if (!Chunk.isNonEmpty(list)) {\n    return core.dieSync(() => internalCause.IllegalArgumentException(`Received an empty collection of effects`));\n  }\n  const self = Chunk.headNonEmpty(list);\n  const effects = Chunk.tailNonEmpty(list);\n  const inheritAll = res => core.as(res[0])(internalFiber.inheritAll(res[1]));\n  return core.flatMap(done => core.flatMap(fails => core.uninterruptibleMask(restore => core.flatMap(head => core.flatMap(fibers => core.onInterrupt(() => Chunk.reduce(core.unit(), (effect, fiber) => core.zipLeft(core.interruptFiber(fiber))(effect))(fibers))(restore(core.flatMap(inheritAll)(Deferred.await(done)))))(core.tap(fibers => Chunk.reduce(core.unit(), (effect, fiber) => core.zipRight(core.asUnit(fork(core.flatMap(raceAllArbiter(fibers, fiber, done, fails))(internalFiber._await(fiber)))))(effect))(fibers))(core.map(tail => Chunk.prepend(head)(tail))(core.forEach(effect => fork(core.interruptible(effect)))(effects)))))(fork(core.interruptible(self)))))(Ref.make(effects.length)))(core.deferredMake()).traced(trace);\n});\n/* @internal */\nconst raceAllArbiter = (fibers, winner, deferred, fails) => exit => core.exitMatchEffect(cause => core.flatten(Ref.modify(fails, fails => [fails === 0 ? core.asUnit(core.deferredFailCause(deferred, cause)) : core.unit(), fails - 1])), value => core.flatMap(set => set ? Chunk.reduce(core.unit(), (effect, fiber) => fiber === winner ? effect : core.zipLeft(core.interruptFiber(fiber))(effect))(fibers) : core.unit())(core.deferredSucceed(deferred, [value, winner])))(exit);\n/* @internal */\nexport const reduceAllPar = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (elements, zero, f) => core.suspendSucceed(() => core.map(option => {\n  switch (option._tag) {\n    case \"None\":\n      {\n        throw new Error(\"BUG: Effect.reduceAllPar - please report an issue at https://github.com/Effect-TS/io/issues\");\n      }\n    case \"Some\":\n      {\n        return option.value;\n      }\n  }\n})(mergeAllPar([zero, ...Array.from(elements)], Option.none(), (acc, elem) => {\n  switch (acc._tag) {\n    case \"None\":\n      {\n        return Option.some(elem);\n      }\n    case \"Some\":\n      {\n        return Option.some(restore(f)(acc.value, elem));\n      }\n  }\n}))).traced(trace));\n/* @internal */\nexport const parallelFinalizers = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.flatMap(scope(), outerScope => core.flatMap(scopeMake(ExecutionStrategy.parallel), innerScope => core.zipRight(scopeExtend(innerScope)(self))(outerScope.addFinalizer(exit => innerScope.close(exit))))).traced(trace));\n/* @internal */\nexport const scope = /*#__PURE__*/Debug.methodWithTrace(trace => () => core.service(scopeTag).traced(trace));\n/* @internal */\nexport const scopeWith = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => f => core.serviceWithEffect(scopeTag, restore(f)).traced(trace));\n/* @internal */\nexport const scopedEffect = /*#__PURE__*/Debug.methodWithTrace(trace => effect => core.flatMap(scopeMake(), scope => scopeUse(scope)(effect)).traced(trace));\n/* @internal */\nexport const sequentialFinalizers = /*#__PURE__*/Debug.methodWithTrace(trace => self => scopeWith(scope => core.flatMap(scope => scopeExtend(scope)(self))(core.scopeFork(scope, ExecutionStrategy.sequential))).traced(trace));\n/* @internal */\nexport const some = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.matchEffect(self, e => core.fail(Option.some(e)), option => {\n  switch (option._tag) {\n    case \"None\":\n      {\n        return core.fail(Option.none());\n      }\n    case \"Some\":\n      {\n        return core.succeed(option.value);\n      }\n  }\n}).traced(trace));\n/* @internal */\nexport const someWith = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.suspendSucceed(() => unsome(restore(f)(some(self)))).traced(trace));\n/* @internal */\nexport const structPar = /*#__PURE__*/Debug.methodWithTrace(trace => r => core.map(values => {\n  const res = {};\n  for (const [k, v] of values) {\n    res[k] = v;\n  }\n  return res;\n})(forEachPar(Object.entries(r), ([_, e]) => core.map(e, a => [_, a]))).traced(trace));\n/* @internal */\nexport const taggedScoped = /*#__PURE__*/Debug.methodWithTrace(trace => (key, value) => taggedScopedWithLabels([metricLabel.make(key, value)]).traced(trace));\n/* @internal */\nexport const taggedScopedWithLabels = /*#__PURE__*/Debug.methodWithTrace(trace => labels => taggedScopedWithLabelSet(HashSet.fromIterable(labels)).traced(trace));\n/* @internal */\nexport const taggedScopedWithLabelSet = /*#__PURE__*/Debug.methodWithTrace(trace => labels => fiberRefLocallyScopedWith(core.currentTags, set => HashSet.union(labels)(set)).traced(trace));\n/* @internal */\nexport const tuplePar = /*#__PURE__*/Debug.methodWithTrace(trace => (...t) => core.map(Chunk.toReadonlyArray)(collectAllPar(t)).traced(trace));\n/* @internal */\nexport const using = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, use) => core.acquireUseRelease(scopeMake(), scope => core.flatMap(restore(use))(scopeExtend(scope)(self)), (scope, exit) => core.scopeClose(scope, exit)).traced(trace));\n/* @internal */\nexport const unsome = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.matchEffect(self, option => {\n  switch (option._tag) {\n    case \"None\":\n      {\n        return core.succeed(Option.none());\n      }\n    case \"Some\":\n      {\n        return core.fail(option.value);\n      }\n  }\n}, a => core.succeed(Option.some(a))).traced(trace));\n/* @internal */\nexport const validateAllPar = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => core.flatMap(partitionPar(elements, restore(f)), ([es, bs]) => Chunk.isEmpty(es) ? core.succeed(bs) : core.fail(es)).traced(trace));\n/* @internal */\nexport const validateAllParDiscard = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => core.flatMap(partitionPar(elements, restore(f)), ([es, _]) => Chunk.isEmpty(es) ? core.unit() : core.fail(es)).traced(trace));\n/* @internal */\nexport const validateFirstPar = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (elements, f) => core.flip(forEachPar(elements, a => core.flip(restore(f)(a)))).traced(trace));\n/* @internal */\nexport const withClockScoped = /*#__PURE__*/Debug.methodWithTrace(trace => value => fiberRefLocallyScopedWith(defaultServices.currentServices, Context.add(clock.clockTag, value)).traced(trace));\n/* @internal */\nexport const withConfigProviderScoped = /*#__PURE__*/Debug.methodWithTrace(trace => value => fiberRefLocallyScopedWith(defaultServices.currentServices, Context.add(configProviderTag, value)).traced(trace));\n/* @internal */\nexport const withEarlyRelease = /*#__PURE__*/Debug.methodWithTrace(trace => self => scopeWith(parent => core.flatMap(core.scopeFork(parent, ExecutionStrategy.sequential), child => core.map(value => [core.fiberIdWith(fiberId => core.scopeClose(child, core.exitInterrupt(fiberId))), value])(scopeExtend(child)(self)))).traced(trace));\n/* @internal */\nexport const withRuntimeFlagsScoped = /*#__PURE__*/Debug.methodWithTrace(trace => update => {\n  if (update === RuntimeFlagsPatch.empty) {\n    return core.unit();\n  }\n  return core.uninterruptible(core.flatMap(runtimeFlags => {\n    const updatedRuntimeFlags = _runtimeFlags.patch(runtimeFlags, update);\n    const revertRuntimeFlags = _runtimeFlags.diff(updatedRuntimeFlags, runtimeFlags);\n    return core.asUnit(core.zipRight(addFinalizer(() => core.updateRuntimeFlags(revertRuntimeFlags)))(core.updateRuntimeFlags(update)));\n  })(core.runtimeFlags())).traced(trace);\n});\n// circular with ReleaseMap\n/* @internal */\nexport const releaseMapReleaseAll = (strategy, exit) => self => core.suspendSucceed(() => {\n  switch (self.state._tag) {\n    case \"Exited\":\n      {\n        return core.unit();\n      }\n    case \"Running\":\n      {\n        const finalizersMap = self.state.finalizers;\n        const update = self.state.update;\n        const finalizers = Array.from(finalizersMap.keys()).sort((a, b) => b - a).map(key => finalizersMap.get(key));\n        self.state = {\n          _tag: \"Exited\",\n          nextKey: self.state.nextKey,\n          exit,\n          update\n        };\n        return ExecutionStrategy.isSequential(strategy) ? core.flatMap(results => Option.getOrElse(() => core.exitUnit())(Option.map(core.exitAsUnit)(core.exitCollectAll(results))))(core.forEach(fin => core.exit(update(fin)(exit)))(finalizers)) : ExecutionStrategy.isParallel(strategy) ? core.flatMap(results => Option.getOrElse(() => core.exitUnit())(Option.map(core.exitAsUnit)(core.exitCollectAllPar(results))))(forEachPar(fin => core.exit(update(fin)(exit)))(finalizers)) : core.withParallelism(strategy.parallelism)(core.flatMap(results => Option.getOrElse(() => core.exitUnit())(Option.map(core.exitAsUnit)(core.exitCollectAllPar(results))))(forEachPar(fin => core.exit(update(fin)(exit)))(finalizers)));\n      }\n  }\n});\n// circular with Scope\n/** @internal */\nexport const scopeTag = /*#__PURE__*/Context.Tag();\n/* @internal */\nexport const scopeMake = /*#__PURE__*/Debug.methodWithTrace(trace => (strategy = ExecutionStrategy.sequential) => core.map(core.releaseMapMake(), rm => ({\n  [core.ScopeTypeId]: core.ScopeTypeId,\n  [core.CloseableScopeTypeId]: core.CloseableScopeTypeId,\n  fork: strategy => Debug.bodyWithTrace(trace => core.uninterruptible(core.flatMap(scope => core.as(scope)(core.tap(fin => core.scopeAddFinalizerExit(scope, fin))(core.releaseMapAdd(exit => core.scopeClose(scope, exit))(rm))))(scopeMake(strategy))).traced(trace)),\n  close: exit => Debug.bodyWithTrace(trace => core.asUnit(releaseMapReleaseAll(strategy, exit)(rm)).traced(trace)),\n  addFinalizer: fin => Debug.bodyWithTrace(trace => core.asUnit(core.releaseMapAdd(fin)(rm)).traced(trace))\n})).traced(trace));\n/* @internal */\nexport const scopeExtend = /*#__PURE__*/Debug.dualWithTrace(2, trace => (effect, scope) => core.contramapContext(effect,\n// @ts-expect-error\nContext.merge(Context.make(scopeTag, scope))).traced(trace));\n/* @internal */\nexport const scopeUse = /*#__PURE__*/Debug.dualWithTrace(2, trace => (effect, scope) => core.onExit(exit => scope.close(exit))(scopeExtend(scope)(effect)).traced(trace));\n// circular with Supervisor\n/** @internal */\nexport const fiberRefUnsafeMakeSupervisor = initial => core.fiberRefUnsafeMakePatch(initial, SupervisorPatch.differ, SupervisorPatch.empty);\n// circular with FiberRef\n/* @internal */\nexport const fiberRefLocallyScoped = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, value) => core.asUnit(acquireRelease(core.flatMap(oldValue => core.as(oldValue)(core.fiberRefSet(self, value)))(core.fiberRefGet(self)), oldValue => core.fiberRefSet(self, oldValue))).traced(trace));\n/* @internal */\nexport const fiberRefLocallyScopedWith = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.fiberRefGetWith(self, a => fiberRefLocallyScoped(self, restore(f)(a))).traced(trace));\n/* @internal */\nexport const fiberRefMake = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (initial, fork = identity, join = (_, a) => a) => fiberRefMakeWith(() => core.fiberRefUnsafeMake(initial, restore(fork), restore(join))).traced(trace));\n/* @internal */\nexport const fiberRefMakeWith = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => ref => acquireRelease(core.tap(core.sync(restore(ref)), ref => core.fiberRefUpdate(ref, identity)), fiberRef => core.fiberRefDelete(fiberRef)).traced(trace));\n/* @internal */\nexport const fiberRefMakeContext = /*#__PURE__*/Debug.methodWithTrace(trace => initial => fiberRefMakeWith(() => core.fiberRefUnsafeMakeContext(initial)).traced(trace));\n/* @internal */\nexport const fiberRefMakeRuntimeFlags = /*#__PURE__*/Debug.methodWithTrace(trace => initial => fiberRefMakeWith(() => core.fiberRefUnsafeMakeRuntimeFlags(initial)).traced(trace));\n/** @internal */\nexport const currentRuntimeFlags = /*#__PURE__*/core.fiberRefUnsafeMakeRuntimeFlags(_runtimeFlags.none);\n/** @internal */\nexport const currentSupervisor = /*#__PURE__*/fiberRefUnsafeMakeSupervisor(supervisor.none);\n// circular with Fiber\n/* @internal */\nexport const fiberAwaitAll = /*#__PURE__*/Debug.methodWithTrace(trace => fibers => core.asUnit(internalFiber._await(fiberCollectAll(fibers))).traced(trace));\n/** @internal */\nexport const fiberCollectAll = fibers => ({\n  [internalFiber.FiberTypeId]: internalFiber.fiberVariance,\n  id: () => Array.from(fibers).reduce((id, fiber) => FiberId.combine(id, fiber.id()), FiberId.none),\n  await: Debug.methodWithTrace(trace => () => core.exit(forEachPar(fibers, fiber => core.flatten(fiber.await()))).traced(trace)),\n  children: Debug.methodWithTrace(trace => () => core.map(forEachPar(fibers, fiber => fiber.children()), Chunk.flatten).traced(trace)),\n  inheritAll: Debug.methodWithTrace(trace => () => core.forEachDiscard(fibers, fiber => fiber.inheritAll()).traced(trace)),\n  poll: Debug.methodWithTrace(trace => () => core.map(core.forEach(fibers, fiber => fiber.poll()), Chunk.reduceRight(Option.some(core.exitSucceed(Chunk.empty())), (optionB, optionA) => {\n    switch (optionA._tag) {\n      case \"None\":\n        {\n          return Option.none();\n        }\n      case \"Some\":\n        {\n          switch (optionB._tag) {\n            case \"None\":\n              {\n                return Option.none();\n              }\n            case \"Some\":\n              {\n                return Option.some(core.exitZipWith(optionB.value, (a, chunk) => Chunk.prepend(a)(chunk), internalCause.parallel)(optionA.value));\n              }\n          }\n        }\n    }\n  })).traced(trace)),\n  interruptAsFork: Debug.methodWithTrace(trace => fiberId => core.forEachDiscard(fibers, fiber => fiber.interruptAsFork(fiberId)).traced(trace))\n});\n/* @internal */\nexport const fiberInterruptFork = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.asUnit(forkDaemon(core.interruptFiber(self))).traced(trace));\n/* @internal */\nexport const fiberJoinAll = /*#__PURE__*/Debug.methodWithTrace(trace => fibers => core.asUnit(internalFiber.join(fiberCollectAll(fibers))).traced(trace));\n/* @internal */\nexport const fiberScoped = /*#__PURE__*/Debug.methodWithTrace(trace => self => acquireRelease(core.succeed(self), core.interruptFiber).traced(trace));\n//# sourceMappingURL=fiberRuntime.mjs.map","import * as Debug from \"@effect/io/Debug\";\nimport * as Option from \"@fp-ts/core/Option\";\nimport * as Duration from \"@fp-ts/data/Duration\";\n/** @internal */\nconst IntervalSymbolKey = \"@effect/io/Schedule/Interval\";\n/** @internal */\nexport const IntervalTypeId = /*#__PURE__*/Symbol.for(IntervalSymbolKey);\n/** @internal */\nexport const empty = {\n  [IntervalTypeId]: IntervalTypeId,\n  startMillis: 0,\n  endMillis: 0\n};\n/** @internal */\nexport const make = (startMillis, endMillis) => {\n  if (startMillis > endMillis) {\n    return empty;\n  }\n  return {\n    [IntervalTypeId]: IntervalTypeId,\n    startMillis,\n    endMillis\n  };\n};\n/** @internal */\nexport const lessThan = /*#__PURE__*/Debug.dual(2, (self, that) => min(self, that) === self);\n/** @internal */\nexport const min = /*#__PURE__*/Debug.dual(2, (self, that) => {\n  if (self.endMillis <= that.startMillis) return self;\n  if (that.endMillis <= self.startMillis) return that;\n  if (self.startMillis < that.startMillis) return self;\n  if (that.startMillis < self.startMillis) return that;\n  if (self.endMillis <= that.endMillis) return self;\n  return that;\n});\n/** @internal */\nexport const max = /*#__PURE__*/Debug.dual(2, (self, that) => min(self, that) === self ? that : self);\n/** @internal */\nexport const isEmpty = self => {\n  return self.startMillis >= self.endMillis;\n};\n/** @internal */\nexport const isNonEmpty = self => {\n  return !isEmpty(self);\n};\n/** @internal */\nexport const intersect = /*#__PURE__*/Debug.dual(2, (self, that) => {\n  const start = Math.max(self.startMillis, that.startMillis);\n  const end = Math.min(self.endMillis, that.endMillis);\n  return make(start, end);\n});\n/** @internal */\nexport const size = self => {\n  return Duration.millis(self.endMillis - self.startMillis);\n};\n/** @internal */\nexport const union = /*#__PURE__*/Debug.dual(2, (self, that) => {\n  const start = Math.max(self.startMillis, that.startMillis);\n  const end = Math.min(self.endMillis, that.endMillis);\n  return start < end ? Option.none() : Option.some(make(start, end));\n});\n/** @internal */\nexport const after = startMilliseconds => {\n  return make(startMilliseconds, Number.POSITIVE_INFINITY);\n};\n/** @internal */\nexport const before = endMilliseconds => {\n  return make(Number.NEGATIVE_INFINITY, endMilliseconds);\n};\n//# sourceMappingURL=interval.mjs.map","/**\n * @since 1.0.0\n */\nimport * as internal from \"@effect/io/internal_effect_untraced/schedule/interval\";\n/**\n * @since 1.0.0\n * @category symbols\n */\nexport const IntervalTypeId = internal.IntervalTypeId;\n/**\n * Constructs a new interval from the two specified endpoints. If the start\n * endpoint greater than the end endpoint, then a zero size interval will be\n * returned.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const make = internal.make;\n/**\n * An `Interval` of zero-width.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const empty = internal.empty;\n/**\n * Returns `true` if this `Interval` is less than `that` interval, `false`\n * otherwise.\n *\n * @since 1.0.0\n * @category ordering\n */\nexport const lessThan = internal.lessThan;\n/**\n * Returns the minimum of two `Interval`s.\n *\n * @since 1.0.0\n * @category ordering\n */\nexport const min = internal.min;\n/**\n * Returns the maximum of two `Interval`s.\n *\n * @since 1.0.0\n * @category ordering\n */\nexport const max = internal.max;\n/**\n * Returns `true` if the specified `Interval` is empty, `false` otherwise.\n *\n * @since 1.0.0\n * @category ordering\n */\nexport const isEmpty = internal.isEmpty;\n/**\n * Returns `true` if the specified `Interval` is non-empty, `false` otherwise.\n *\n * @since 1.0.0\n * @category ordering\n */\nexport const isNonEmpty = internal.isNonEmpty;\n/**\n * Computes a new `Interval` which is the intersection of this `Interval` and\n * that `Interval`.\n *\n * @since 1.0.0\n * @category ordering\n */\nexport const intersect = internal.intersect;\n/**\n * Calculates the size of the `Interval` as the `Duration` from the start of the\n * interval to the end of the interval.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const size = internal.size;\n/**\n * Computes a new `Interval` which is the union of this `Interval` and that\n * `Interval` as a `Some`, otherwise returns `None` if the two intervals cannot\n * form a union.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const union = internal.union;\n/**\n * Construct an `Interval` that includes all time equal to and after the\n * specified start time.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const after = internal.after;\n/**\n * Construct an `Interval` that includes all time equal to and before the\n * specified end time.\n *\n * @category constructors\n * @since 1.0.0\n */\nexport const before = internal.before;\n//# sourceMappingURL=Interval.mjs.map","import * as Debug from \"@effect/io/Debug\";\nimport * as Interval from \"@effect/io/Schedule/Interval\";\nimport * as Option from \"@fp-ts/core/Option\";\nimport * as Chunk from \"@fp-ts/data/Chunk\";\n/** @internal */\nconst IntervalsSymbolKey = \"@effect/io/Schedule/Intervals\";\n/** @internal */\nexport const IntervalsTypeId = /*#__PURE__*/Symbol.for(IntervalsSymbolKey);\n/** @internal */\nexport const make = intervals => {\n  return {\n    [IntervalsTypeId]: IntervalsTypeId,\n    intervals\n  };\n};\n/** @internal */\nexport const empty = /*#__PURE__*/make( /*#__PURE__*/Chunk.empty());\n/** @internal */\nexport const fromIterable = intervals => Array.from(intervals).reduce((intervals, interval) => union(make(Chunk.of(interval)))(intervals), empty);\n/** @internal */\nexport const union = /*#__PURE__*/Debug.dual(2, (self, that) => {\n  if (!Chunk.isNonEmpty(that.intervals)) {\n    return self;\n  }\n  if (!Chunk.isNonEmpty(self.intervals)) {\n    return that;\n  }\n  if (Chunk.headNonEmpty(self.intervals).startMillis < Chunk.headNonEmpty(that.intervals).startMillis) {\n    return unionLoop(Chunk.tailNonEmpty(self.intervals), that.intervals, Chunk.headNonEmpty(self.intervals), Chunk.empty());\n  }\n  return unionLoop(self.intervals, Chunk.tailNonEmpty(that.intervals), Chunk.headNonEmpty(that.intervals), Chunk.empty());\n});\n/** @internal */\nconst unionLoop = (_self, _that, _interval, _acc) => {\n  let self = _self;\n  let that = _that;\n  let interval = _interval;\n  let acc = _acc;\n  while (Chunk.isNonEmpty(self) || Chunk.isNonEmpty(that)) {\n    if (!Chunk.isNonEmpty(self) && Chunk.isNonEmpty(that)) {\n      if (interval.endMillis < Chunk.headNonEmpty(that).startMillis) {\n        acc = Chunk.prepend(interval)(acc);\n        interval = Chunk.headNonEmpty(that);\n        that = Chunk.tailNonEmpty(that);\n        self = Chunk.empty();\n      } else {\n        interval = Interval.make(interval.startMillis, Chunk.headNonEmpty(that).endMillis);\n        that = Chunk.tailNonEmpty(that);\n        self = Chunk.empty();\n      }\n    } else if (Chunk.isNonEmpty(self) && Chunk.isEmpty(that)) {\n      if (interval.endMillis < Chunk.headNonEmpty(self).startMillis) {\n        acc = Chunk.prepend(interval)(acc);\n        interval = Chunk.headNonEmpty(self);\n        that = Chunk.empty();\n        self = Chunk.tailNonEmpty(self);\n      } else {\n        interval = Interval.make(interval.startMillis, Chunk.headNonEmpty(self).endMillis);\n        that = Chunk.empty();\n        self = Chunk.tailNonEmpty(self);\n      }\n    } else if (Chunk.isNonEmpty(self) && Chunk.isNonEmpty(that)) {\n      if (Chunk.headNonEmpty(self).startMillis < Chunk.headNonEmpty(that).startMillis) {\n        if (interval.endMillis < Chunk.headNonEmpty(self).startMillis) {\n          acc = Chunk.prepend(interval)(acc);\n          interval = Chunk.headNonEmpty(self);\n          self = Chunk.tailNonEmpty(self);\n        } else {\n          interval = Interval.make(interval.startMillis, Chunk.headNonEmpty(self).endMillis);\n          self = Chunk.tailNonEmpty(self);\n        }\n      } else if (interval.endMillis < Chunk.headNonEmpty(that).startMillis) {\n        acc = Chunk.prepend(interval)(acc);\n        interval = Chunk.headNonEmpty(that);\n        that = Chunk.tailNonEmpty(that);\n      } else {\n        interval = Interval.make(interval.startMillis, Chunk.headNonEmpty(that).endMillis);\n        that = Chunk.tailNonEmpty(that);\n      }\n    } else {\n      throw new Error(\"BUG: Intervals.unionLoop - please report an issue at https://github.com/Effect-TS/io/issues\");\n    }\n  }\n  return make(Chunk.reverse(Chunk.prepend(interval)(acc)));\n};\n/** @internal */\nexport const intersect = /*#__PURE__*/Debug.dual(2, (self, that) => intersectLoop(self.intervals, that.intervals, Chunk.empty()));\n/** @internal */\nconst intersectLoop = (_left, _right, _acc) => {\n  let left = _left;\n  let right = _right;\n  let acc = _acc;\n  while (Chunk.isNonEmpty(left) && Chunk.isNonEmpty(right)) {\n    const interval = Interval.intersect(Chunk.headNonEmpty(right))(Chunk.headNonEmpty(left));\n    const intervals = Interval.isEmpty(interval) ? acc : Chunk.prepend(interval)(acc);\n    if (Interval.lessThan(Chunk.headNonEmpty(right))(Chunk.headNonEmpty(left))) {\n      left = Chunk.tailNonEmpty(left);\n    } else {\n      right = Chunk.tailNonEmpty(right);\n    }\n    acc = intervals;\n  }\n  return make(Chunk.reverse(acc));\n};\n/** @internal */\nexport const start = self => {\n  return Option.getOrElse(() => Interval.empty)(Chunk.head(self.intervals)).startMillis;\n};\n/** @internal */\nexport const end = self => {\n  return Option.getOrElse(() => Interval.empty)(Chunk.head(self.intervals)).endMillis;\n};\n/** @internal */\nexport const lessThan = /*#__PURE__*/Debug.dual(2, (self, that) => start(self) < start(that));\n/** @internal */\nexport const isNonEmpty = self => {\n  return Chunk.isNonEmpty(self.intervals);\n};\n/** @internal */\nexport const max = /*#__PURE__*/Debug.dual(2, (self, that) => lessThan(self, that) ? that : self);\n//# sourceMappingURL=intervals.mjs.map","/**\n * @since 1.0.0\n */\nimport * as internal from \"@effect/io/internal_effect_untraced/schedule/intervals\";\n/**\n * @since 1.0.0\n * @category symbols\n */\nexport const IntervalsTypeId = internal.IntervalsTypeId;\n/**\n * Creates a new `Intervals` from a `List` of `Interval`s.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const make = internal.make;\n/**\n * Constructs an empty list of `Interval`s.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const empty = internal.empty;\n/**\n * Constructs `Intervals` from the specified `Iterable<Interval>`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const fromIterable = internal.fromIterable;\n/**\n * Computes the union of this `Intervals` and  that `Intervals`\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const union = internal.union;\n/**\n * Produces the intersection of this `Intervals` and that `Intervals`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const intersect = internal.intersect;\n/**\n * The start of the earliest interval in the specified `Intervals`.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const start = internal.start;\n/**\n * The end of the latest interval in the specified `Intervals`.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const end = internal.end;\n/**\n * Returns `true` if the start of this `Intervals` is before the start of that\n * `Intervals`, `false` otherwise.\n *\n * @since 1.0.0\n * @category ordering\n */\nexport const lessThan = internal.lessThan;\n/**\n * Returns `true` if this `Intervals` is non-empty, `false` otherwise.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const isNonEmpty = internal.isNonEmpty;\n/**\n * Returns the maximum of the two `Intervals` (i.e. which has the latest start).\n *\n * @since 1.0.0\n * @category ordering\n */\nexport const max = internal.max;\n//# sourceMappingURL=Intervals.mjs.map","import * as Intervals from \"@effect/io/Schedule/Intervals\";\nimport * as Chunk from \"@fp-ts/data/Chunk\";\n/** @internal */\nexport const OP_CONTINUE = \"Continue\";\n/** @internal */\nexport const OP_DONE = \"Done\";\n/** @internal */\nexport const _continue = intervals => {\n  return {\n    _tag: OP_CONTINUE,\n    intervals\n  };\n};\n/** @internal */\nexport const continueWith = interval => {\n  return {\n    _tag: OP_CONTINUE,\n    intervals: Intervals.make(Chunk.of(interval))\n  };\n};\n/** @internal */\nexport const done = {\n  _tag: OP_DONE\n};\n/** @internal */\nexport const isContinue = self => {\n  return self._tag === OP_CONTINUE;\n};\n/** @internal */\nexport const isDone = self => {\n  return self._tag === OP_DONE;\n};\n//# sourceMappingURL=decision.mjs.map","/**\n * @since 1.0.0\n */\nimport * as internal from \"@effect/io/internal_effect_untraced/schedule/decision\";\nconst _continue = internal._continue;\nexport {\n/**\n * @since 1.0.0\n * @category constructors\n */\n_continue as continue };\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const continueWith = internal.continueWith;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const done = internal.done;\n/**\n * @since 1.0.0\n * @category refinements\n */\nexport const isContinue = internal.isContinue;\n/**\n * @since 1.0.0\n * @category refinements\n */\nexport const isDone = internal.isDone;\n//# sourceMappingURL=Decision.mjs.map","var _a, _b;\nimport * as Clock from \"@effect/io/Clock\";\nimport * as Debug from \"@effect/io/Debug\";\nimport * as internalCause from \"@effect/io/internal_effect_untraced/cause\";\nimport * as core from \"@effect/io/internal_effect_untraced/core\";\nimport * as effect from \"@effect/io/internal_effect_untraced/effect\";\nimport * as Random from \"@effect/io/Random\";\nimport * as Ref from \"@effect/io/Ref\";\nimport * as ScheduleDecision from \"@effect/io/Schedule/Decision\";\nimport * as Interval from \"@effect/io/Schedule/Interval\";\nimport * as Intervals from \"@effect/io/Schedule/Intervals\";\nimport * as Either from \"@fp-ts/core/Either\";\nimport { constVoid } from \"@fp-ts/core/Function\";\nimport * as Option from \"@fp-ts/core/Option\";\nimport * as Chunk from \"@fp-ts/data/Chunk\";\nimport * as Context from \"@fp-ts/data/Context\";\nimport * as Duration from \"@fp-ts/data/Duration\";\nimport * as Equal from \"@fp-ts/data/Equal\";\n/** @internal */\nconst ScheduleSymbolKey = \"@effect/io/Schedule\";\n/** @internal */\nexport const ScheduleTypeId = /*#__PURE__*/Symbol.for(ScheduleSymbolKey);\n/** @internal */\nconst ScheduleDriverSymbolKey = \"@effect/io/Schedule/Driver\";\n/** @internal */\nexport const ScheduleDriverTypeId = /*#__PURE__*/Symbol.for(ScheduleDriverSymbolKey);\n/** @internal */\nconst scheduleVariance = {\n  _Env: _ => _,\n  _In: _ => _,\n  _Out: _ => _\n};\nconst scheduleDriverVariance = {\n  _Env: _ => _,\n  _In: _ => _,\n  _Out: _ => _\n};\n/** @internal */\nclass ScheduleImpl {\n  constructor(initial, step) {\n    this.initial = initial;\n    this.step = step;\n    this[_a] = scheduleVariance;\n  }\n}\n_a = ScheduleTypeId;\n/** @internal */\nclass ScheduleDriverImpl {\n  constructor(schedule, ref) {\n    this.schedule = schedule;\n    this.ref = ref;\n    this[_b] = scheduleDriverVariance;\n  }\n  state() {\n    return Debug.bodyWithTrace(trace => core.map(Ref.get(this.ref), tuple => tuple[1]).traced(trace));\n  }\n  last() {\n    return Debug.bodyWithTrace(trace => core.flatMap(Ref.get(this.ref), ([element, _]) => {\n      switch (element._tag) {\n        case \"None\":\n          {\n            return core.failSync(() => internalCause.NoSuchElementException());\n          }\n        case \"Some\":\n          {\n            return core.succeed(element.value);\n          }\n      }\n    }).traced(trace));\n  }\n  reset() {\n    return Debug.bodyWithTrace(trace => Ref.set(this.ref, [Option.none(), this.schedule.initial]).traced(trace));\n  }\n  next(input) {\n    return Debug.bodyWithTrace((trace, restore) => core.flatMap(state => core.flatMap(now => core.flatMap(([state, out, decision]) => ScheduleDecision.isDone(decision) ? core.zipRight(core.fail(Option.none()))(Ref.set(this.ref, [Option.some(out), state])) : core.as(out)(core.zipRight(effect.sleep(Duration.millis(Intervals.start(decision.intervals) - now)))(Ref.set(this.ref, [Option.some(out), state]))))(core.suspendSucceed(restore(() => this.schedule.step(now, input, state)))))(Clock.currentTimeMillis()))(core.map(Ref.get(this.ref), tuple => tuple[1])).traced(trace));\n  }\n}\n_b = ScheduleDriverTypeId;\n/** @internal */\nexport const makeWithState = /*#__PURE__*/Debug.untracedMethod(restore => (initial, step) => new ScheduleImpl(initial, restore(step)));\n/** @internal */\nexport const addDelay = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => addDelayEffect(self, out => core.sync(() => restore(f)(out))));\n/** @internal */\nexport const addDelayEffect = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => modifyDelayEffect(self, (out, duration) => core.map(restore(f)(out), delay => Duration.millis(duration.millis + delay.millis))));\n/** @internal */\nexport const andThen = /*#__PURE__*/Debug.untracedDual(2, () => (self, that) => map(Either.merge)(andThenEither(self, that)));\n/** @internal */\nexport const andThenEither = /*#__PURE__*/Debug.untracedDual(2, restore => (self, that) => makeWithState([self.initial, that.initial, true], (now, input, state) => state[2] ? core.flatMap(restore(self.step)(now, input, state[0]), ([lState, out, decision]) => {\n  if (ScheduleDecision.isDone(decision)) {\n    return core.map(that.step(now, input, state[1]), ([rState, out, decision]) => [[lState, rState, false], Either.right(out), decision]);\n  }\n  return core.succeed([[lState, state[1], true], Either.left(out), decision]);\n}) : core.map(that.step(now, input, state[1]), ([rState, out, decision]) => [[state[0], rState, false], Either.right(out), decision])));\n/** @internal */\nexport const as = /*#__PURE__*/Debug.untracedDual(2, () => (self, out) => map(self, () => out));\n/** @internal */\nexport const asUnit = /*#__PURE__*/Debug.untracedMethod(() => self => map(self, constVoid));\n/** @internal */\nexport const bothInOut = /*#__PURE__*/Debug.untracedDual(2, restore => (self, that) => makeWithState([self.initial, that.initial], (now, [in1, in2], state) => core.zipWith(restore(self.step)(now, in1, state[0]), restore(that.step)(now, in2, state[1]), ([lState, out, lDecision], [rState, out2, rDecision]) => {\n  if (ScheduleDecision.isContinue(lDecision) && ScheduleDecision.isContinue(rDecision)) {\n    const interval = Intervals.union(rDecision.intervals)(lDecision.intervals);\n    return [[lState, rState], [out, out2], ScheduleDecision.continue(interval)];\n  }\n  return [[lState, rState], [out, out2], ScheduleDecision.done];\n})));\n/** @internal */\nexport const check = /*#__PURE__*/Debug.untracedDual(2, restore => (self, test) => checkEffect(self, (input, out) => core.sync(() => restore(test)(input, out))));\n/** @internal */\nexport const checkEffect = /*#__PURE__*/Debug.untracedDual(2, restore => (self, test) => makeWithState(self.initial, (now, input, state) => core.flatMap(restore(self.step)(now, input, state), ([state, out, decision]) => {\n  if (ScheduleDecision.isDone(decision)) {\n    return core.succeed([state, out, ScheduleDecision.done]);\n  }\n  return core.map(restore(test)(input, out), cont => cont ? [state, out, decision] : [state, out, ScheduleDecision.done]);\n})));\n/** @internal */\nexport const choose = /*#__PURE__*/Debug.untracedDual(2, restore => (self, that) => makeWithState([self.initial, that.initial], (now, either, state) => {\n  switch (either._tag) {\n    case \"Left\":\n      {\n        return core.map(restore(self.step)(now, either.left, state[0]), ([lState, out, decision]) => [[lState, state[1]], Either.left(out), decision]);\n      }\n    case \"Right\":\n      {\n        return core.map(([rState, out2, decision]) => [[state[0], rState], Either.right(out2), decision])(that.step(now, either.right, state[1]));\n      }\n  }\n}));\n/** @internal */\nexport const chooseMerge = /*#__PURE__*/Debug.untracedDual(2, () => (self, that) => map(choose(self, that), Either.merge));\n/** @internal */\nexport const collectAllInputs = /*#__PURE__*/Debug.untracedMethod(() => () => collectAllOutputs(identity()));\n/** @internal */\nexport const collectAllOutputs = /*#__PURE__*/Debug.untracedMethod(() => self => reduce(self, Chunk.empty(), (outs, out) => Chunk.append(out)(outs)));\n/** @internal */\nexport const collectUntil = /*#__PURE__*/Debug.untracedMethod(restore => f => collectAllOutputs(recurUntil(restore(f))));\n/** @internal */\nexport const collectUntilEffect = /*#__PURE__*/Debug.untracedMethod(restore => f => collectAllOutputs(recurUntilEffect(restore(f))));\n/** @internal */\nexport const collectWhile = /*#__PURE__*/Debug.untracedMethod(restore => f => collectAllOutputs(recurWhile(restore(f))));\n/** @internal */\nexport const collectWhileEffect = /*#__PURE__*/Debug.untracedMethod(restore => f => collectAllOutputs(recurWhileEffect(restore(f))));\n/** @internal */\nexport const compose = /*#__PURE__*/Debug.untracedDual(2, restore => (self, that) => makeWithState([self.initial, that.initial], (now, input, state) => core.flatMap(restore(self.step)(now, input, state[0]), ([lState, out, lDecision]) => core.map(that.step(now, out, state[1]), ([rState, out2, rDecision]) => ScheduleDecision.isDone(lDecision) ? [[lState, rState], out2, ScheduleDecision.done] : ScheduleDecision.isDone(rDecision) ? [[lState, rState], out2, ScheduleDecision.done] : [[lState, rState], out2, ScheduleDecision.continue(Intervals.max(rDecision.intervals)(lDecision.intervals))]))));\n/** @internal */\nexport const contramap = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => contramapEffect(self, input2 => core.sync(() => restore(f)(input2))));\n/** @internal */\nexport const contramapContext = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => makeWithState(self.initial, (now, input, state) => core.contramapContext(restore(self.step)(now, input, state), restore(f))));\n/** @internal */\nexport const contramapEffect = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => makeWithState(self.initial, (now, input2, state) => core.flatMap(restore(f)(input2), input => restore(self.step)(now, input, state))));\n/** @internal */\nexport const count = /*#__PURE__*/Debug.untracedMethod(() => () => unfold(0, n => n + 1));\n/** @internal */\nexport const dayOfMonth = /*#__PURE__*/Debug.untracedMethod(() => day => {\n  return makeWithState([Number.NEGATIVE_INFINITY, 0], (now, _, state) => {\n    if (!Number.isInteger(day) || day < 1 || 31 < day) {\n      return core.dieSync(() => internalCause.IllegalArgumentException(`Invalid argument in: dayOfMonth(${day}). Must be in range 1...31`));\n    }\n    const n = state[1];\n    const initial = n === 0;\n    const day0 = nextDayOfMonth(now, day, initial);\n    const start = beginningOfDay(day0);\n    const end = endOfDay(day0);\n    const interval = Interval.make(start, end);\n    return core.succeed([[end, n + 1], n, ScheduleDecision.continueWith(interval)]);\n  });\n});\n/** @internal */\nexport const dayOfWeek = /*#__PURE__*/Debug.untracedMethod(() => day => {\n  return makeWithState([Number.MIN_SAFE_INTEGER, 0], (now, _, state) => {\n    if (!Number.isInteger(day) || day < 1 || 7 < day) {\n      return core.dieSync(() => internalCause.IllegalArgumentException(`Invalid argument in: dayOfWeek(${day}). Must be in range 1 (Monday)...7 (Sunday)`));\n    }\n    const n = state[1];\n    const initial = n === 0;\n    const day0 = nextDay(now, day, initial);\n    const start = beginningOfDay(day0);\n    const end = endOfDay(day0);\n    const interval = Interval.make(start, end);\n    return core.succeed([[end, n + 1], n, ScheduleDecision.continueWith(interval)]);\n  });\n});\n/** @internal */\nexport const delayed = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => delayedEffect(self, duration => core.sync(() => restore(f)(duration))));\n/** @internal */\nexport const delayedEffect = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => modifyDelayEffect(self, (_, delay) => restore(f)(delay)));\n/** @internal */\nexport const delayedSchedule = /*#__PURE__*/Debug.untracedMethod(() => schedule => addDelay(schedule, x => x));\n/** @internal */\nexport const delays = /*#__PURE__*/Debug.untracedMethod(restore => self => makeWithState(self.initial, (now, input, state) => core.flatMap(([state, _, decision]) => {\n  if (ScheduleDecision.isDone(decision)) {\n    return core.succeed([state, Duration.zero, decision]);\n  }\n  return core.succeed([state, Duration.millis(Intervals.start(decision.intervals) - now), decision]);\n})(restore(self.step)(now, input, state))));\n/** @internal */\nexport const dimap = /*#__PURE__*/Debug.untracedDual(3, restore => (self, f, g) => map(restore(g))(contramap(self, restore(f))));\n/** @internal */\nexport const dimapEffect = /*#__PURE__*/Debug.untracedDual(3, restore => (self, f, g) => mapEffect(restore(g))(contramapEffect(self, restore(f))));\n/** @internal */\nexport const driver = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.map(ref => new ScheduleDriverImpl(self, ref))(Ref.make([Option.none(), self.initial])).traced(trace));\n/** @internal */\nexport const duration = /*#__PURE__*/Debug.untracedMethod(() => duration => makeWithState(true, (now, _, state) => core.succeed(state ? [false, duration, ScheduleDecision.continueWith(Interval.after(now + duration.millis))] : [false, Duration.zero, ScheduleDecision.done])));\n/** @internal */\nexport const either = /*#__PURE__*/Debug.untracedDual(2, () => (self, that) => union(self, that));\n/** @internal */\nexport const eitherWith = /*#__PURE__*/Debug.untracedDual(3, restore => (self, that, f) => unionWith(self, that, restore(f)));\n/** @internal */\nexport const elapsed = /*#__PURE__*/Debug.untracedMethod(() => () => makeWithState(Option.none(), (now, _, state) => {\n  switch (state._tag) {\n    case \"None\":\n      {\n        return core.succeed([Option.some(now), Duration.zero, ScheduleDecision.continueWith(Interval.after(now))]);\n      }\n    case \"Some\":\n      {\n        return core.succeed([Option.some(state.value), Duration.millis(now - state.value), ScheduleDecision.continueWith(Interval.after(now))]);\n      }\n  }\n}));\n/** @internal */\nexport const ensuring = /*#__PURE__*/Debug.untracedDual(2, restore => (self, finalizer) => makeWithState(self.initial, (now, input, state) => core.flatMap(restore(self.step)(now, input, state), ([state, out, decision]) => ScheduleDecision.isDone(decision) ? core.as(finalizer, [state, out, decision]) : core.succeed([state, out, decision]))));\n/** @internal */\nexport const exponential = /*#__PURE__*/Debug.untracedMethod(() => (base, factor = 2.0) => delayedSchedule(map(i => Duration.millis(base.millis * Math.pow(factor, i)))(forever())));\n/** @internal */\nexport const fibonacci = /*#__PURE__*/Debug.untracedMethod(() => one => delayedSchedule(map(out => out[0])(unfold([one, one], ([a, b]) => [b, Duration.add(b)(a)]))));\n/** @internal */\nexport const fixed = /*#__PURE__*/Debug.untracedMethod(() => interval => makeWithState([Option.none(), 0], (now, _, [option, n]) => core.sync(() => {\n  const intervalMillis = interval.millis;\n  switch (option._tag) {\n    case \"None\":\n      {\n        return [[Option.some([now, now + intervalMillis]), n + 1], n, ScheduleDecision.continueWith(Interval.after(now + intervalMillis))];\n      }\n    case \"Some\":\n      {\n        const [startMillis, lastRun] = option.value;\n        const runningBehind = now > lastRun + intervalMillis;\n        const boundary = Equal.equals(interval, Duration.zero) ? interval : Duration.millis(intervalMillis - (now - startMillis) % intervalMillis);\n        const sleepTime = Equal.equals(boundary, Duration.zero) ? interval : boundary;\n        const nextRun = runningBehind ? now : now + sleepTime.millis;\n        return [[Option.some([startMillis, nextRun]), n + 1], n, ScheduleDecision.continueWith(Interval.after(nextRun))];\n      }\n  }\n})));\n/** @internal */\nexport const forever = /*#__PURE__*/Debug.untracedMethod(() => () => unfold(0, n => n + 1));\n/** @internal */\nexport const fromDelay = /*#__PURE__*/Debug.untracedMethod(() => delay => duration(delay));\n/** @internal */\nexport const fromDelays = /*#__PURE__*/Debug.untracedMethod(() => (delay, ...delays) => makeWithState([[delay, ...delays], true], (now, _, [durations, cont]) => core.sync(() => {\n  if (cont) {\n    const x = durations[0];\n    const interval = Interval.after(now + x.millis);\n    if (durations.length >= 2) {\n      return [[durations.slice(1), true], x, ScheduleDecision.continueWith(interval)];\n    }\n    const y = durations.slice(1);\n    return [[[x, ...y], false], x, ScheduleDecision.continueWith(interval)];\n  }\n  return [[durations, false], Duration.zero, ScheduleDecision.done];\n})));\n/** @internal */\nexport const fromFunction = /*#__PURE__*/Debug.untracedMethod(restore => f => map(restore(f))(identity()));\n/** @internal */\nexport const hourOfDay = /*#__PURE__*/Debug.untracedMethod(() => hour => makeWithState([Number.NEGATIVE_INFINITY, 0], (now, _, state) => {\n  if (!Number.isInteger(hour) || hour < 0 || 23 < hour) {\n    return core.dieSync(() => internalCause.IllegalArgumentException(`Invalid argument in: hourOfDay(${hour}). Must be in range 0...23`));\n  }\n  const n = state[1];\n  const initial = n === 0;\n  const hour0 = nextHour(now, hour, initial);\n  const start = beginningOfHour(hour0);\n  const end = endOfHour(hour0);\n  const interval = Interval.make(start, end);\n  return core.succeed([[end, n + 1], n, ScheduleDecision.continueWith(interval)]);\n}));\n/** @internal */\nexport const identity = /*#__PURE__*/Debug.untracedMethod(() => () => makeWithState(void 0, (now, input, state) => core.succeed([state, input, ScheduleDecision.continueWith(Interval.after(now))])));\n/** @internal */\nexport const intersect = /*#__PURE__*/Debug.untracedDual(2, () => (self, that) => intersectWith(self, that, (selfIntervals, thatIntervals) => Intervals.intersect(thatIntervals)(selfIntervals)));\n/** @internal */\nexport const intersectWith = /*#__PURE__*/Debug.untracedDual(3, restore => (self, that, f) => makeWithState([self.initial, that.initial], (now, input, state) => core.flatMap(([[lState, out, lDecision], [rState, out2, rDecision]]) => {\n  if (ScheduleDecision.isContinue(lDecision) && ScheduleDecision.isContinue(rDecision)) {\n    return intersectWithLoop(self, that, input, lState, out, lDecision.intervals, rState, out2, rDecision.intervals, restore(f));\n  }\n  return core.succeed([[lState, rState], [out, out2], ScheduleDecision.done]);\n})(core.zipWith(restore(self.step)(now, input, state[0]), restore(that.step)(now, input, state[1]), (a, b) => [a, b]))));\n/** @internal */\nconst intersectWithLoop = (self, that, input, lState, out, lInterval, rState, out2, rInterval, f) => {\n  const combined = f(lInterval, rInterval);\n  if (Intervals.isNonEmpty(combined)) {\n    return core.succeed([[lState, rState], [out, out2], ScheduleDecision.continue(combined)]);\n  }\n  if (Intervals.lessThan(rInterval)(lInterval)) {\n    return core.flatMap(self.step(Intervals.end(lInterval), input, lState), ([lState, out, decision]) => {\n      if (ScheduleDecision.isDone(decision)) {\n        return core.succeed([[lState, rState], [out, out2], ScheduleDecision.done]);\n      }\n      return intersectWithLoop(self, that, input, lState, out, decision.intervals, rState, out2, rInterval, f);\n    });\n  }\n  return core.flatMap(that.step(Intervals.end(rInterval), input, rState), ([rState, out2, decision]) => {\n    if (ScheduleDecision.isDone(decision)) {\n      return core.succeed([[lState, rState], [out, out2], ScheduleDecision.done]);\n    }\n    return intersectWithLoop(self, that, input, lState, out, lInterval, rState, out2, decision.intervals, f);\n  });\n};\n/** @internal */\nexport const jittered = /*#__PURE__*/Debug.untracedMethod(() => self => jitteredWith(self, {\n  min: 0.8,\n  max: 1.2\n}));\n/** @internal */\nexport const jitteredWith = /*#__PURE__*/Debug.untracedDual(2, () => (self, options) => {\n  const {\n    max,\n    min\n  } = Object.assign({\n    min: 0.8,\n    max: 1.2\n  }, options);\n  return delayedEffect(self, duration => core.map(Random.next(), random => {\n    const d = duration.millis;\n    const jittered = d * min * (1 - random) + d * max * random;\n    return Duration.millis(jittered);\n  }));\n});\n/** @internal */\nexport const left = /*#__PURE__*/Debug.untracedMethod(() => self => choose(self, identity()));\n/** @internal */\nexport const linear = /*#__PURE__*/Debug.untracedMethod(() => base => delayedSchedule(map(i => Duration.millis(base.millis * (i + 1)))(forever())));\n/** @internal */\nexport const map = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => mapEffect(self, out => core.sync(() => restore(f)(out))));\n/** @internal */\nexport const mapEffect = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => makeWithState(self.initial, (now, input, state) => core.flatMap(restore(self.step)(now, input, state), ([state, out, decision]) => core.map(restore(f)(out), out2 => [state, out2, decision]))));\n/** @internal */\nexport const minuteOfHour = /*#__PURE__*/Debug.untracedMethod(() => minute => makeWithState([Number.MIN_SAFE_INTEGER, 0], (now, _, state) => {\n  if (!Number.isInteger(minute) || minute < 0 || 59 < minute) {\n    return core.dieSync(() => internalCause.IllegalArgumentException(`Invalid argument in: minuteOfHour(${minute}). Must be in range 0...59`));\n  }\n  const n = state[1];\n  const initial = n === 0;\n  const minute0 = nextMinute(now, minute, initial);\n  const start = beginningOfMinute(minute0);\n  const end = endOfMinute(minute0);\n  const interval = Interval.make(start, end);\n  return core.succeed([[end, n + 1], n, ScheduleDecision.continueWith(interval)]);\n}));\n/** @internal */\nexport const modifyDelay = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => modifyDelayEffect(self, (out, duration) => core.sync(() => restore(f)(out, duration))));\n/** @internal */\nexport const modifyDelayEffect = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => makeWithState(self.initial, (now, input, state) => core.flatMap(restore(self.step)(now, input, state), ([state, out, decision]) => {\n  if (ScheduleDecision.isDone(decision)) {\n    return core.succeed([state, out, decision]);\n  }\n  const intervals = decision.intervals;\n  const delay = Interval.size(Interval.make(now, Intervals.start(intervals)));\n  return core.map(restore(f)(out, delay), duration => {\n    const oldStart = Intervals.start(intervals);\n    const newStart = now + duration.millis;\n    const delta = newStart - oldStart;\n    const newEnd = Math.min(Math.max(0, Intervals.end(intervals) + delta), Number.MAX_SAFE_INTEGER);\n    const newInterval = Interval.make(newStart, newEnd);\n    return [state, out, ScheduleDecision.continueWith(newInterval)];\n  });\n})));\n/** @internal */\nexport const onDecision = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => makeWithState(self.initial, (now, input, state) => core.flatMap(restore(self.step)(now, input, state), ([state, out, decision]) => core.as(restore(f)(out, decision), [state, out, decision]))));\n/** @internal */\nexport const once = /*#__PURE__*/Debug.untracedMethod(() => () => asUnit(recurs(1)));\n/** @internal */\nexport const passthrough = /*#__PURE__*/Debug.untracedMethod(restore => self => makeWithState(self.initial, (now, input, state) => core.map(([state, _, decision]) => [state, input, decision])(restore(self.step)(now, input, state))));\n/** @internal */\nexport const provideContext = /*#__PURE__*/Debug.untracedDual(2, restore => (self, context) => makeWithState(self.initial, (now, input, state) => core.provideContext(restore(self.step)(now, input, state), context)));\n/** @internal */\nexport const provideService = /*#__PURE__*/Debug.untracedDual(3, restore => (self, tag, service) => makeWithState(self.initial, (now, input, state) => core.contextWithEffect(env => core.provideContext(\n// @ts-expect-error\nrestore(self.step)(now, input, state), Context.add(tag, service)(env)))));\n/** @internal */\nexport const reconsider = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => reconsiderEffect(self, (out, decision) => core.sync(() => restore(f)(out, decision))));\n/** @internal */\nexport const reconsiderEffect = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => makeWithState(self.initial, (now, input, state) => core.flatMap(restore(self.step)(now, input, state), ([state, out, decision]) => ScheduleDecision.isDone(decision) ? core.map(restore(f)(out, decision), either => {\n  switch (either._tag) {\n    case \"Left\":\n      {\n        return [state, either.left, ScheduleDecision.done];\n      }\n    case \"Right\":\n      {\n        const [out2] = either.right;\n        return [state, out2, ScheduleDecision.done];\n      }\n  }\n}) : core.map(restore(f)(out, decision), either => {\n  switch (either._tag) {\n    case \"Left\":\n      {\n        return [state, either.left, ScheduleDecision.done];\n      }\n    case \"Right\":\n      {\n        const [out2, interval] = either.right;\n        return [state, out2, ScheduleDecision.continueWith(interval)];\n      }\n  }\n}))));\n/** @internal */\nexport const recurUntil = /*#__PURE__*/Debug.untracedMethod(restore => f => untilInput(identity(), restore(f)));\n/** @internal */\nexport const recurUntilEffect = /*#__PURE__*/Debug.untracedMethod(restore => f => untilInputEffect(identity(), restore(f)));\n/** @internal */\nexport const recurUntilEquals = /*#__PURE__*/Debug.untracedMethod(() => value => untilInput(identity(), input => Equal.equals(input, value)));\n/** @internal */\nexport const recurUntilOption = /*#__PURE__*/Debug.untracedMethod(restore => pf => untilOutput(Option.isSome)(map(restore(pf))(identity())));\n/** @internal */\nexport const recurUpTo = /*#__PURE__*/Debug.untracedMethod(() => duration => whileOutput(elapsed(), elapsed => Duration.lessThan(duration)(elapsed)));\n/** @internal */\nexport const recurWhile = /*#__PURE__*/Debug.untracedMethod(restore => f => whileInput(identity(), restore(f)));\n/** @internal */\nexport const recurWhileEffect = /*#__PURE__*/Debug.untracedMethod(restore => f => whileInputEffect(identity(), restore(f)));\n/** @internal */\nexport const recurWhileEquals = /*#__PURE__*/Debug.untracedMethod(() => value => whileInput(input => Equal.equals(input, value))(identity()));\n/** @internal */\nexport const recurs = /*#__PURE__*/Debug.untracedMethod(() => n => whileOutput(forever(), out => out < n));\n/** @internal */\nexport const reduce = /*#__PURE__*/Debug.untracedDual(3, restore => (self, zero, f) => reduceEffect(self, zero, (z, out) => core.sync(() => restore(f)(z, out))));\n/** @internal */\nexport const reduceEffect = /*#__PURE__*/Debug.untracedDual(3, restore => (self, zero, f) => makeWithState([self.initial, zero], (now, input, [s, z]) => core.flatMap(restore(self.step)(now, input, s), ([s, out, decision]) => ScheduleDecision.isDone(decision) ? core.succeed([[s, z], z, decision]) : core.map(restore(f)(z, out), z2 => [[s, z2], z, decision]))));\n/** @internal */\nexport const repeatForever = /*#__PURE__*/Debug.untracedMethod(restore => self => makeWithState(self.initial, (now, input, state) => {\n  const step = (now, input, state) => core.flatMap(restore(self.step)(now, input, state), ([state, out, decision]) => ScheduleDecision.isDone(decision) ? step(now, input, self.initial) : core.succeed([state, out, decision]));\n  return step(now, input, state);\n}));\n/** @internal */\nexport const repetitions = /*#__PURE__*/Debug.untracedMethod(() => self => reduce(self, 0, (n, _) => n + 1));\n/** @internal */\nexport const resetAfter = /*#__PURE__*/Debug.untracedDual(2, () => (self, duration) => map(out => out[0])(resetWhen(([, time]) => Duration.greaterThanOrEqualTo(duration)(time))(intersect(elapsed())(self))));\n/** @internal */\nexport const resetWhen = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => makeWithState(self.initial, (now, input, state) => core.flatMap(restore(self.step)(now, input, state), ([state, out, decision]) => restore(f)(out) ? restore(self.step)(now, input, self.initial) : core.succeed([state, out, decision]))));\n/** @internal */\nexport const right = /*#__PURE__*/Debug.untracedMethod(() => self => choose(identity(), self));\n/** @internal */\nexport const run = /*#__PURE__*/Debug.dualWithTrace(3, trace => (self, now, input) => core.map(list => Chunk.reverse(list))(runLoop(self, now, Chunk.fromIterable(input), self.initial, Chunk.empty())).traced(trace));\n/** @internal */\nconst runLoop = (self, now, inputs, state, acc) => {\n  if (!Chunk.isNonEmpty(inputs)) {\n    return core.succeed(acc);\n  }\n  const input = Chunk.headNonEmpty(inputs);\n  const nextInputs = Chunk.tailNonEmpty(inputs);\n  return core.flatMap(self.step(now, input, state), ([state, out, decision]) => {\n    if (ScheduleDecision.isDone(decision)) {\n      return core.sync(() => Chunk.prepend(out)(acc));\n    }\n    return runLoop(self, Intervals.start(decision.intervals), nextInputs, state, Chunk.prepend(out)(acc));\n  });\n};\n/** @internal */\nexport const secondOfMinute = /*#__PURE__*/Debug.untracedMethod(() => second => makeWithState([Number.NEGATIVE_INFINITY, 0], (now, _, state) => {\n  if (!Number.isInteger(second) || second < 0 || 59 < second) {\n    return core.dieSync(() => internalCause.IllegalArgumentException(`Invalid argument in: secondOfMinute(${second}). Must be in range 0...59`));\n  }\n  const n = state[1];\n  const initial = n === 0;\n  const second0 = nextSecond(now, second, initial);\n  const start = beginningOfSecond(second0);\n  const end = endOfSecond(second0);\n  const interval = Interval.make(start, end);\n  return core.succeed([[end, n + 1], n, ScheduleDecision.continueWith(interval)]);\n}));\n/** @internal */\nexport const spaced = /*#__PURE__*/Debug.untracedMethod(() => duration => addDelay(forever(), () => duration));\n/** @internal */\nexport const stop = /*#__PURE__*/Debug.untracedMethod(() => () => asUnit(recurs(0)));\n/** @internal */\nexport const succeed = /*#__PURE__*/Debug.untracedMethod(() => value => map(forever(), () => value));\n/** @internal */\nexport const sync = /*#__PURE__*/Debug.untracedMethod(restore => evaluate => map(forever(), restore(evaluate)));\n/** @internal */\nexport const tapInput = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => makeWithState(self.initial, (now, input, state) => core.zipRight(restore(f)(input), restore(self.step)(now, input, state))));\n/** @internal */\nexport const tapOutput = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => makeWithState(self.initial, (now, input, state) => core.tap(restore(self.step)(now, input, state), ([, out]) => restore(f)(out))));\n/** @internal */\nexport const unfold = /*#__PURE__*/Debug.untracedMethod(restore => (initial, f) => makeWithState(initial, (now, _, state) => core.sync(() => [restore(f)(state), state, ScheduleDecision.continueWith(Interval.after(now))])));\n/** @internal */\nexport const union = /*#__PURE__*/Debug.untracedDual(2, () => (self, that) => unionWith(self, that, (selfIntervals, thatIntervals) => Intervals.union(thatIntervals)(selfIntervals)));\n/** @internal */\nexport const unionWith = /*#__PURE__*/Debug.untracedDual(3, restore => (self, that, f) => makeWithState([self.initial, that.initial], (now, input, state) => core.zipWith(restore(self.step)(now, input, state[0]), restore(that.step)(now, input, state[1]), ([lState, l, lDecision], [rState, r, rDecision]) => {\n  if (ScheduleDecision.isDone(lDecision) && ScheduleDecision.isDone(rDecision)) {\n    return [[lState, rState], [l, r], ScheduleDecision.done];\n  }\n  if (ScheduleDecision.isDone(lDecision) && ScheduleDecision.isContinue(rDecision)) {\n    return [[lState, rState], [l, r], ScheduleDecision.continue(rDecision.intervals)];\n  }\n  if (ScheduleDecision.isContinue(lDecision) && ScheduleDecision.isDone(rDecision)) {\n    return [[lState, rState], [l, r], ScheduleDecision.continue(lDecision.intervals)];\n  }\n  if (ScheduleDecision.isContinue(lDecision) && ScheduleDecision.isContinue(rDecision)) {\n    const combined = restore(f)(lDecision.intervals, rDecision.intervals);\n    return [[lState, rState], [l, r], ScheduleDecision.continue(combined)];\n  }\n  throw new Error(\"BUG: Schedule.unionWith - please report an issue at https://github.com/Effect-TS/io/issues\");\n})));\n/** @internal */\nexport const untilInput = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => check(self, (input, _) => !restore(f)(input)));\n/** @internal */\nexport const untilInputEffect = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => checkEffect(self, (input, _) => effect.negate(restore(f)(input))));\n/** @internal */\nexport const untilOutput = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => check(self, (_, out) => !restore(f)(out)));\n/** @internal */\nexport const untilOutputEffect = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => checkEffect(self, (_, out) => effect.negate(restore(f)(out))));\n/** @internal */\nexport const upTo = /*#__PURE__*/Debug.untracedDual(2, () => (self, duration) => zipLeft(self, recurUpTo(duration)));\n/** @internal */\nexport const whileInput = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => check(self, (input, _) => restore(f)(input)));\n/** @internal */\nexport const whileInputEffect = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => checkEffect(self, (input, _) => restore(f)(input)));\n/** @internal */\nexport const whileOutput = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => check(self, (_, out) => restore(f)(out)));\n/** @internal */\nexport const whileOutputEffect = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => checkEffect(self, (_, out) => restore(f)(out)));\n/** @internal */\nexport const windowed = /*#__PURE__*/Debug.untracedMethod(() => interval => {\n  const millis = interval.millis;\n  return makeWithState([Option.none(), 0], (now, _, [option, n]) => {\n    switch (option._tag) {\n      case \"None\":\n        {\n          return core.succeed([[Option.some(now), n + 1], n, ScheduleDecision.continueWith(Interval.after(now + millis))]);\n        }\n      case \"Some\":\n        {\n          return core.succeed([[Option.some(option.value), n + 1], n, ScheduleDecision.continueWith(Interval.after(now + (millis - (now - option.value) % millis)))]);\n        }\n    }\n  });\n});\n/** @internal */\nexport const zipLeft = /*#__PURE__*/Debug.untracedDual(2, () => (self, that) => map(out => out[0])(intersect(self, that)));\n/** @internal */\nexport const zipRight = /*#__PURE__*/Debug.untracedDual(2, () => (self, that) => map(out => out[1])(intersect(self, that)));\n/** @internal */\nexport const zipWith = /*#__PURE__*/Debug.untracedDual(3, restore => (self, that, f) => map(([out, out2]) => restore(f)(out, out2))(intersect(self, that)));\n// -----------------------------------------------------------------------------\n// Seconds\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const beginningOfSecond = now => {\n  const date = new Date(now);\n  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), 0).getTime();\n};\n/** @internal */\nexport const endOfSecond = now => {\n  const date = new Date(beginningOfSecond(now));\n  return date.setSeconds(date.getSeconds() + 1);\n};\n/** @internal */\nexport const nextSecond = (now, second, initial) => {\n  const date = new Date(now);\n  if (date.getSeconds() === second && initial) {\n    return now;\n  }\n  if (date.getSeconds() < second) {\n    return date.setSeconds(second);\n  }\n  // Set seconds to the provided value and add one minute\n  const newDate = new Date(date.setSeconds(second));\n  return newDate.setTime(newDate.getTime() + 1000 * 60);\n};\n// -----------------------------------------------------------------------------\n// Minutes\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const beginningOfMinute = now => {\n  const date = new Date(now);\n  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), 0, 0).getTime();\n};\n/** @internal */\nexport const endOfMinute = now => {\n  const date = new Date(beginningOfMinute(now));\n  return date.setMinutes(date.getMinutes() + 1);\n};\n/** @internal */\nexport const nextMinute = (now, minute, initial) => {\n  const date = new Date(now);\n  if (date.getMinutes() === minute && initial) {\n    return now;\n  }\n  if (date.getMinutes() < minute) {\n    return date.setMinutes(minute);\n  }\n  // Set minutes to the provided value and add one hour\n  const newDate = new Date(date.setMinutes(minute));\n  return newDate.setTime(newDate.getTime() + 1000 * 60 * 60);\n};\n// -----------------------------------------------------------------------------\n// Hours\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const beginningOfHour = now => {\n  const date = new Date(now);\n  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), 0, 0, 0).getTime();\n};\n/** @internal */\nexport const endOfHour = now => {\n  const date = new Date(beginningOfHour(now));\n  return date.setHours(date.getHours() + 1);\n};\n/** @internal */\nexport const nextHour = (now, hour, initial) => {\n  const date = new Date(now);\n  if (date.getHours() === hour && initial) {\n    return now;\n  }\n  if (date.getHours() < hour) {\n    return date.setHours(hour);\n  }\n  // Set hours to the provided value and add one day\n  const newDate = new Date(date.setHours(hour));\n  return newDate.setTime(newDate.getTime() + 1000 * 60 * 60 * 24);\n};\n// -----------------------------------------------------------------------------\n// Days\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const beginningOfDay = now => {\n  const date = new Date(now);\n  return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0).getTime();\n};\n/** @internal */\nexport const endOfDay = now => {\n  const date = new Date(beginningOfDay(now));\n  return date.setDate(date.getDate() + 1);\n};\n/** @internal */\nexport const nextDay = (now, dayOfWeek, initial) => {\n  const date = new Date(now);\n  if (date.getDay() === dayOfWeek && initial) {\n    return now;\n  }\n  const nextDayOfWeek = (7 + dayOfWeek - date.getDay()) % 7;\n  return date.setDate(date.getDate() + (nextDayOfWeek === 0 ? 7 : nextDayOfWeek));\n};\n/** @internal */\nexport const nextDayOfMonth = (now, day, initial) => {\n  const date = new Date(now);\n  if (date.getDate() === day && initial) {\n    return now;\n  }\n  if (date.getDate() < day) {\n    return date.setDate(day);\n  }\n  return findNextMonth(now, day, 1);\n};\n/** @internal */\nexport const findNextMonth = (now, day, months) => {\n  const d = new Date(now);\n  const tmp1 = new Date(d.setDate(day));\n  const tmp2 = new Date(tmp1.setMonth(tmp1.getMonth() + months));\n  if (tmp2.getDate() === day) {\n    const d2 = new Date(now);\n    const tmp3 = new Date(d2.setDate(day));\n    return tmp3.setMonth(tmp3.getMonth() + months);\n  }\n  return findNextMonth(now, day, months + 1);\n};\n// circular with Effect\n/** @internal */\nexport const repeat_Effect = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, schedule) => repeatOrElse_Effect(self, schedule, (e, _) => core.fail(e)).traced(trace));\n/** @internal */\nexport const repeatOrElse_Effect = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, schedule, orElse) => core.map(repeatOrElseEither_Effect(self, schedule, restore(orElse)), Either.merge).traced(trace));\n/** @internal */\nexport const repeatOrElseEither_Effect = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, schedule, orElse) => core.flatMap(driver(schedule), driver => core.matchEffect(self, error => core.map(Either.left)(restore(orElse)(error, Option.none())), value => repeatOrElseEitherEffectLoop(self, driver, restore(orElse), value))).traced(trace));\n/** @internal */\nconst repeatOrElseEitherEffectLoop = (self, driver, orElse, value) => {\n  return core.matchEffect(() => core.map(Either.right)(core.orDie(driver.last())), b => core.matchEffect(error => core.map(Either.left)(orElse(error, Option.some(b))), value => repeatOrElseEitherEffectLoop(self, driver, orElse, value))(self))(driver.next(value));\n};\n/** @internal */\nexport const repeatUntil_Effect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => repeatUntilEffect_Effect(self, a => core.sync(() => restore(f)(a))).traced(trace));\n/** @internal */\nexport const repeatUntilEffect_Effect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.flatMap(self, a => core.flatMap(f(a), result => result ? core.succeed(a) : core.zipRight(core.yieldNow(), repeatUntilEffect_Effect(self, restore(f))))).traced(trace));\n/** @internal */\nexport const repeatUntilEquals_Effect = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, value) => repeatUntil_Effect(self, a => Equal.equals(a, value)).traced(trace));\n/** @internal */\nexport const repeatWhile_Effect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => repeatWhileEffect_Effect(self, a => core.sync(() => restore(f)(a))).traced(trace));\n/** @internal */\nexport const repeatWhileEffect_Effect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => repeatUntilEffect_Effect(self, a => effect.negate(restore(f)(a))).traced(trace));\n/** @internal */\nexport const repeatWhileEquals_Effect = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, value) => repeatWhile_Effect(self, a => Equal.equals(a, value)).traced(trace));\n/** @internal */\nexport const retry_Effect = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, policy) => retryOrElse_Effect(self, policy, (e, _) => core.fail(e)).traced(trace));\n/** @internal */\nexport const retryN_Effect = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, n) => retryN_EffectLoop(self, n).traced(trace));\n/** @internal */\nconst retryN_EffectLoop = (self, n) => {\n  return core.catchAll(self, e => n < 0 ? core.fail(e) : core.flatMap(core.yieldNow(), () => retryN_EffectLoop(self, n - 1)));\n};\n/** @internal */\nexport const retryOrElse_Effect = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, policy, orElse) => core.map(retryOrElseEither_Effect(self, policy, restore(orElse)), Either.merge).traced(trace));\n/** @internal */\nexport const retryOrElseEither_Effect = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, policy, orElse) => core.flatMap(driver(policy), driver => retryOrElseEither_EffectLoop(self, driver, restore(orElse))).traced(trace));\n/** @internal */\nconst retryOrElseEither_EffectLoop = (self, driver, orElse) => {\n  return core.catchAll(e => core.matchEffect(() => core.flatMap(out => core.map(Either.left)(orElse(e, out)))(core.orDie(driver.last())), () => retryOrElseEither_EffectLoop(self, driver, orElse))(driver.next(e)))(core.map(Either.right)(self));\n};\n/** @internal */\nexport const retryUntil_Effect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => retryUntilEffect_Effect(self, e => core.sync(() => restore(f)(e))).traced(trace));\n/** @internal */\nexport const retryUntilEffect_Effect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => core.catchAll(self, e => core.flatMap(restore(f)(e), b => b ? core.fail(e) : core.flatMap(core.yieldNow(), () => retryUntilEffect_Effect(self, restore(f))))).traced(trace));\n/** @internal */\nexport const retryUntilEquals_Effect = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, e) => retryUntil_Effect(self, _ => Equal.equals(_, e)).traced(trace));\n/** @internal */\nexport const retryWhile_Effect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => retryWhileEffect_Effect(self, e => core.sync(() => restore(f)(e))).traced(trace));\n/** @internal */\nexport const retryWhileEffect_Effect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => retryUntilEffect_Effect(self, e => effect.negate(restore(f)(e))).traced(trace));\n/** @internal */\nexport const retryWhileEquals_Effect = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, e) => retryWhile_Effect(self, err => Equal.equals(e, err)).traced(trace));\n/** @internal */\nexport const schedule_Effect = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, schedule) => scheduleFrom_Effect(self, void 0, schedule).traced(trace));\n/** @internal */\nexport const scheduleFrom_Effect = /*#__PURE__*/Debug.dualWithTrace(3, trace => (self, initial, schedule) => core.flatMap(driver(schedule), driver => scheduleFrom_EffectLoop(self, initial, driver)).traced(trace));\n/** @internal */\nconst scheduleFrom_EffectLoop = (self, initial, driver) => core.matchEffect(() => core.orDie(driver.last()), () => core.flatMap(a => scheduleFrom_EffectLoop(self, a, driver))(self))(driver.next(initial));\n//# sourceMappingURL=schedule.mjs.map","var _a, _b;\nimport * as Debug from \"@effect/io/Debug\";\nimport * as ExecutionStrategy from \"@effect/io/ExecutionStrategy\";\nimport * as Exit from \"@effect/io/Exit\";\nimport * as FiberId from \"@effect/io/Fiber/Id\";\nimport * as internalCause from \"@effect/io/internal_effect_untraced/cause\";\nimport * as core from \"@effect/io/internal_effect_untraced/core\";\nimport * as effect from \"@effect/io/internal_effect_untraced/effect\";\nimport * as internalFiber from \"@effect/io/internal_effect_untraced/fiber\";\nimport * as fiberRuntime from \"@effect/io/internal_effect_untraced/fiberRuntime\";\nimport * as OpCodes from \"@effect/io/internal_effect_untraced/opCodes/effect\";\nimport * as internalRef from \"@effect/io/internal_effect_untraced/ref\";\nimport * as _schedule from \"@effect/io/internal_effect_untraced/schedule\";\nimport * as supervisor from \"@effect/io/internal_effect_untraced/supervisor\";\nimport * as Either from \"@fp-ts/core/Either\";\nimport * as Option from \"@fp-ts/core/Option\";\nimport * as Equal from \"@fp-ts/data/Equal\";\nimport * as MutableHashMap from \"@fp-ts/data/MutableHashMap\";\nimport * as MutableRef from \"@fp-ts/data/MutableRef\";\n/** @internal */\nclass Semaphore {\n  constructor(permits) {\n    this.permits = permits;\n    this.waiters = new Array();\n    this.taken = 0;\n    this.take = n => Debug.bodyWithTrace(trace => core.asyncInterruptEither(resume => {\n      if (this.free < n) {\n        const observer = () => {\n          if (this.free >= n) {\n            const observerIndex = this.waiters.findIndex(cb => cb === observer);\n            if (observerIndex !== -1) {\n              this.waiters.splice(observerIndex, 1);\n            }\n            this.taken += n;\n            resume(core.succeed(n));\n          }\n        };\n        this.waiters.push(observer);\n        return Either.left(core.sync(() => {\n          const observerIndex = this.waiters.findIndex(cb => cb === observer);\n          if (observerIndex !== -1) {\n            this.waiters.splice(observerIndex, 1);\n          }\n        }));\n      }\n      this.taken += n;\n      return Either.right(core.succeed(n));\n    }).traced(trace));\n    this.release = n => Debug.bodyWithTrace(trace => core.withFiberRuntime(fiber => {\n      this.taken -= n;\n      fiber.getFiberRef(core.currentScheduler).scheduleTask(() => {\n        this.waiters.forEach(wake => wake());\n      });\n      return core.unit();\n    }).traced(trace));\n    this.withPermits = n => Debug.bodyWithTrace(trace => self => Debug.untraced(() => core.uninterruptibleMask(restore => core.flatMap(restore(this.take(n)), permits => ensuring(restore(self), this.release(permits))))).traced(trace));\n  }\n  get free() {\n    return this.permits - this.taken;\n  }\n}\n/** @internal */\nexport const unsafeMakeSemaphore = leases => {\n  return new Semaphore(leases);\n};\n/** @internal */\nexport const makeSemaphore = /*#__PURE__*/Debug.methodWithTrace(trace => permits => core.sync(() => unsafeMakeSemaphore(permits)).traced(trace));\n/** @internal */\nexport const acquireReleaseInterruptible = /*#__PURE__*/Debug.methodWithTrace((trace, restore) => (acquire, release) => ensuring(acquire, fiberRuntime.addFinalizer(restore(release))).traced(trace));\n/** @internal */\nexport const awaitAllChildren = /*#__PURE__*/Debug.methodWithTrace(trace => self => ensuringChildren(self, fiberRuntime.fiberAwaitAll).traced(trace));\n/** @internal */\nexport const cached = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, timeToLive) => core.map(cachedInvalidate(self, timeToLive), tuple => tuple[0]).traced(trace));\n/** @internal */\nexport const cachedInvalidate = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, timeToLive) => core.flatMap(core.context(), env => core.map(makeSynchronized(Option.none()), cache => [core.provideContext(getCachedValue(self, timeToLive, cache), env), invalidateCache(cache)])).traced(trace));\n/** @internal */\nconst computeCachedValue = (self, timeToLive, start) => core.map(deferred => Option.some([start + timeToLive.millis, deferred]))(core.tap(deferred => core.intoDeferred(self, deferred))(core.deferredMake()));\n/** @internal */\nconst getCachedValue = (self, timeToLive, cache) => core.uninterruptibleMask(restore => core.flatMap(option => Option.isNone(option) ? effect.dieMessage(\"BUG: Effect.cachedInvalidate - please report an issue at https://github.com/Effect-TS/io/issues\") : restore(core.deferredAwait(option.value[1])))(core.flatMap(time => updateSomeAndGetEffectSynchronized(cache, option => {\n  switch (option._tag) {\n    case \"None\":\n      {\n        return Option.some(computeCachedValue(self, timeToLive, time));\n      }\n    case \"Some\":\n      {\n        const [end] = option.value;\n        return end - time <= 0 ? Option.some(computeCachedValue(self, timeToLive, time)) : Option.none();\n      }\n  }\n}))(effect.clockWith(clock => clock.currentTimeMillis()))));\n/** @internal */\nconst invalidateCache = cache => internalRef.set(cache, Option.none());\n/** @internal */\nexport const disconnect = /*#__PURE__*/Debug.methodWithTrace(trace => self => core.uninterruptibleMask(restore => core.fiberIdWith(fiberId => core.flatMap(fiberRuntime.forkDaemon(restore(self)), fiber => core.onInterrupt(() => internalFiber.interruptAsFork(fiberId)(fiber))(restore(internalFiber.join(fiber)))))).traced(trace));\n/** @internal */\nexport const ensuring = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, finalizer) => core.uninterruptibleMask(restore => core.matchCauseEffect(restore(self), cause1 => core.matchCauseEffect(finalizer, cause2 => core.failCause(internalCause.sequential(cause1, cause2)), () => core.failCause(cause1)), a => core.as(finalizer, a))).traced(trace));\n/** @internal */\nexport const ensuringChild = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => ensuringChildren(self, children => restore(f)(fiberRuntime.fiberCollectAll(children))).traced(trace));\n/** @internal */\nexport const ensuringChildren = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, children) => core.flatMap(supervisor.track(), supervisor => ensuring(core.flatMap(supervisor.value(), restore(children)))(supervised(supervisor)(self))).traced(trace));\n/** @internal */\nexport const forkAll = /*#__PURE__*/Debug.methodWithTrace(trace => effects => core.map(core.forEach(effects, fiberRuntime.fork), fiberRuntime.fiberCollectAll).traced(trace));\n/** @internal */\nexport const forkIn = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, scope) => core.uninterruptibleMask(restore => core.flatMap(scope.fork(ExecutionStrategy.sequential), child => core.tap(fiber => child.addFinalizer(() => core.fiberIdWith(fiberId => Equal.equals(fiberId, fiber.id()) ? core.unit() : core.asUnit(core.interruptFiber(fiber)))))(fiberRuntime.forkDaemon(core.onExit(exit => child.close(exit))(restore(self)))))).traced(trace));\n/** @internal */\nexport const forkScoped = /*#__PURE__*/Debug.methodWithTrace(trace => self => fiberRuntime.scopeWith(scope => forkIn(self, scope)).traced(trace));\n/** @internal */\nexport const fromFiber = /*#__PURE__*/Debug.methodWithTrace(trace => fiber => internalFiber.join(fiber).traced(trace));\n/** @internal */\nexport const fromFiberEffect = /*#__PURE__*/Debug.methodWithTrace(trace => fiber => core.suspendSucceed(() => core.flatMap(fiber, internalFiber.join)).traced(trace));\n/** @internal */\nexport const memoizeFunction = /*#__PURE__*/Debug.methodWithTrace(trace => f => core.map(ref => a => core.flatMap(([patch, b]) => core.as(b)(effect.patchFiberRefs(patch)))(core.flatMap(core.deferredAwait)(ref.modifyEffect(map => {\n  const result = MutableHashMap.get(a)(map);\n  if (Option.isNone(result)) {\n    return core.map(deferred => [deferred, MutableHashMap.set(a, deferred)(map)])(core.tap(deferred => fiberRuntime.fork(core.intoDeferred(deferred)(effect.diffFiberRefs(f(a)))))(core.deferredMake()));\n  }\n  return core.succeed([result.value, map]);\n}))))(core.flatMap(makeSynchronized)(core.sync(() => {\n  return MutableHashMap.empty();\n}))).traced(trace));\n/** @internal */\nexport const race = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => core.checkInterruptible(isInterruptible => raceAwait(raceDisconnect(that, isInterruptible))(raceDisconnect(self, isInterruptible))).traced(trace));\n/** @internal */\nconst raceDisconnect = (self, isInterruptible) => isInterruptible ? disconnect(self) : core.interruptible(disconnect(core.uninterruptible(self)));\n/** @internal */\nexport const raceAwait = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => core.fiberIdWith(parentFiberId => raceWith(that, (exit, right) => core.exitMatchEffect(cause => effect.mapErrorCause(cause2 => internalCause.parallel(cause, cause2))(internalFiber.join(right)), value => core.as(value)(core.interruptAsFiber(parentFiberId)(right)))(exit), (exit, left) => core.exitMatchEffect(cause => effect.mapErrorCause(cause2 => internalCause.parallel(cause2, cause))(internalFiber.join(left)), value => core.as(value)(core.interruptAsFiber(parentFiberId)(left)))(exit))(self)).traced(trace));\n/** @internal */\nexport const raceEither = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => race(core.map(self, Either.left), core.map(that, Either.right)).traced(trace));\n/** @internal */\nexport const raceFirst = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => (effect => core.flatten(effect))(race(core.exit(that))(core.exit(self))).traced(trace));\n/** @internal */\nexport const raceFibersWith = /*#__PURE__*/Debug.dualWithTrace(4, (trace, restore) => (self, that, selfWins, thatWins) => core.withFiberRuntime((parentFiber, parentStatus) => {\n  const parentRuntimeFlags = parentStatus.runtimeFlags;\n  const raceIndicator = MutableRef.make(true);\n  const leftFiber = fiberRuntime.unsafeMakeChildFiber(self, parentFiber, parentRuntimeFlags);\n  const rightFiber = fiberRuntime.unsafeMakeChildFiber(that, parentFiber, parentRuntimeFlags);\n  leftFiber.startFork(self);\n  rightFiber.startFork(that);\n  leftFiber.setFiberRef(core.forkScopeOverride, Option.some(parentFiber.scope()));\n  rightFiber.setFiberRef(core.forkScopeOverride, Option.some(parentFiber.scope()));\n  return core.async(cb => {\n    leftFiber.unsafeAddObserver(() => completeRace(leftFiber, rightFiber, restore(selfWins), raceIndicator, cb));\n    rightFiber.unsafeAddObserver(() => completeRace(rightFiber, leftFiber, restore(thatWins), raceIndicator, cb));\n  }, FiberId.combine(rightFiber.id())(leftFiber.id()));\n}).traced(trace));\n/** @internal */\nconst completeRace = (winner, loser, cont, ab, cb) => {\n  if (MutableRef.compareAndSet(true, false)(ab)) {\n    cb(cont(winner, loser));\n  }\n};\n/** @internal */\nexport const raceWith = /*#__PURE__*/Debug.dualWithTrace(4, (trace, restore) => (self, that, leftDone, rightDone) => raceFibersWith(self, that, (winner, loser) => core.flatMap(winner.await(), exit => {\n  switch (exit._tag) {\n    case OpCodes.OP_SUCCESS:\n      {\n        return core.flatMap(winner.inheritAll(), () => restore(leftDone)(exit, loser));\n      }\n    case OpCodes.OP_FAILURE:\n      {\n        return restore(leftDone)(exit, loser);\n      }\n  }\n}), (winner, loser) => core.flatMap(winner.await(), exit => {\n  switch (exit._tag) {\n    case OpCodes.OP_SUCCESS:\n      {\n        return core.flatMap(winner.inheritAll(), () => restore(rightDone)(exit, loser));\n      }\n    case OpCodes.OP_FAILURE:\n      {\n        return restore(rightDone)(exit, loser);\n      }\n  }\n})).traced(trace));\n/** @internal */\nexport const scheduleForked = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, schedule) => forkScoped(_schedule.schedule_Effect(schedule)(self)).traced(trace));\n/** @internal */\nexport const supervised = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, supervisor) => {\n  const supervise = core.fiberRefLocallyWith(fiberRuntime.currentSupervisor, s => s.zip(supervisor));\n  return supervise(self).traced(trace);\n});\n/** @internal */\nexport const timeout = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, duration) => timeoutTo(self, Option.none(), Option.some, duration).traced(trace));\n/** @internal */\nexport const timeoutFail = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, evaluate, duration) => core.flatten(timeoutTo(self, core.failSync(restore(evaluate)), core.succeed, duration)).traced(trace));\n/** @internal */\nexport const timeoutFailCause = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, evaluate, duration) => core.flatten(timeoutTo(self, core.failCauseSync(restore(evaluate)), core.succeed, duration)).traced(trace));\n/** @internal */\nexport const timeoutTo = /*#__PURE__*/Debug.dualWithTrace(4, (trace, restore) => (self, def, f, duration) => raceFirst(core.map(self, restore(f)), core.interruptible(core.as(def)(effect.sleep(duration)))).traced(trace));\n/** @internal */\nexport const validatePar = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => validateWithPar(self, that, (a, b) => [a, b]).traced(trace));\n/** @internal */\nexport const validateWithPar = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, that, f) => core.flatten(zipWithPar(core.exit(self), core.exit(that), (ea, eb) => core.exitZipWith(eb, restore(f), (ca, cb) => internalCause.parallel(ca, cb))(ea))).traced(trace));\n/** @internal */\nexport const zipPar = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => zipWithPar(self, that, (a, b) => [a, b]).traced(trace));\n/** @internal */\nexport const zipParLeft = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => zipWithPar(self, that, (a, _) => a).traced(trace));\n/** @internal */\nexport const zipParRight = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, that) => zipWithPar(self, that, (_, b) => b).traced(trace));\n/** @internal */\nexport const zipWithPar = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restoreTrace) => (self, that, f) => core.uninterruptibleMask(restore => core.transplant(graft => {\n  const deferred = core.deferredUnsafeMake(FiberId.none);\n  const ref = MutableRef.make(false);\n  return core.flatMap(([left, right]) => core.matchCauseEffect(cause => core.zipRight(core.flatMap(([left, right]) => core.exitMatch(causes => core.failCause(internalCause.parallel(internalCause.stripFailures(cause), causes)), () => core.failCause(internalCause.stripFailures(cause)))(core.exitZipWith(right, f, internalCause.parallel)(left)))(core.zip(internalFiber._await(right))(internalFiber._await(left))))(core.zipRight(fiberRuntime.fiberInterruptFork(right))(fiberRuntime.fiberInterruptFork(left))), () => core.zipWith(internalFiber.join(left), internalFiber.join(right), restoreTrace(f)))(restore(core.deferredAwait(deferred))))(core.zip(forkZipWithPar(that, graft, restore, deferred, ref))(forkZipWithPar(self, graft, restore, deferred, ref)));\n})).traced(trace));\n/** @internal */\nconst forkZipWithPar = (self, graft, restore, deferred, ref) => fiberRuntime.forkDaemon(core.matchCauseEffect(graft(restore(self)), cause => core.zipRight(core.deferredFail(deferred, void 0), core.failCause(cause)), value => {\n  const flag = MutableRef.get(ref);\n  if (flag) {\n    core.deferredUnsafeDone(deferred, core.unit());\n    return core.succeed(value);\n  }\n  MutableRef.set(true)(ref);\n  return core.succeed(value);\n}));\n// circular with Synchronized\n/** @internal */\nconst SynchronizedSymbolKey = \"@effect/io/Ref/Synchronized\";\n/** @internal */\nexport const SynchronizedTypeId = /*#__PURE__*/Symbol.for(SynchronizedSymbolKey);\n/** @internal */\nexport const synchronizedVariance = {\n  _A: _ => _\n};\n/** @internal */\nclass SynchronizedImpl {\n  constructor(ref, withLock) {\n    this.ref = ref;\n    this.withLock = withLock;\n    this[_a] = synchronizedVariance;\n    this[_b] = internalRef.refVariance;\n  }\n  modify(f) {\n    return Debug.bodyWithTrace((trace, restore) => this.modifyEffect(a => core.succeed(restore(f)(a))).traced(trace));\n  }\n  modifyEffect(f) {\n    return Debug.bodyWithTrace((trace, restore) => this.withLock(core.flatMap(([b, a]) => core.as(internalRef.set(this.ref, a), b))(core.flatMap(internalRef.get(this.ref), restore(f)))).traced(trace));\n  }\n}\n_a = SynchronizedTypeId, _b = internalRef.RefTypeId;\n/** @internal */\nexport const makeSynchronized = /*#__PURE__*/Debug.methodWithTrace(trace => value => core.sync(() => unsafeMakeSynchronized(value)).traced(trace));\n/** @internal */\nexport const unsafeMakeSynchronized = value => {\n  const ref = internalRef.unsafeMake(value);\n  const sem = unsafeMakeSemaphore(1);\n  return new SynchronizedImpl(ref, sem.withPermits(1));\n};\n/** @internal */\nexport const updateSomeAndGetEffectSynchronized = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, pf) => self.modifyEffect(value => {\n  const result = restore(pf)(value);\n  switch (result._tag) {\n    case \"None\":\n      {\n        return core.succeed([value, value]);\n      }\n    case \"Some\":\n      {\n        return core.map(result.value, a => [a, a]);\n      }\n  }\n}).traced(trace));\n// circular with Fiber\n/** @internal */\nexport const zipFiber = /*#__PURE__*/Debug.untracedDual(2, () => (self, that) => zipWithFiber(self, that, (a, b) => [a, b]));\n/** @internal */\nexport const zipLeftFiber = /*#__PURE__*/Debug.untracedDual(2, () => (self, that) => zipWithFiber(self, that, (a, _) => a));\n/** @internal */\nexport const zipRightFiber = /*#__PURE__*/Debug.untracedDual(2, () => (self, that) => zipWithFiber(self, that, (_, b) => b));\n/** @internal */\nexport const zipWithFiber = /*#__PURE__*/Debug.untracedDual(3, restore => (self, that, f) => ({\n  [internalFiber.FiberTypeId]: internalFiber.fiberVariance,\n  id: () => FiberId.getOrElse(that.id())(self.id()),\n  await: Debug.methodWithTrace(trace => () => core.exit(zipWithPar(core.flatten(that.await()), restore(f))(core.flatten(self.await()))).traced(trace)),\n  children: Debug.methodWithTrace(trace => () => self.children().traced(trace)),\n  inheritAll: Debug.methodWithTrace(trace => () => core.zipRight(that.inheritAll(), self.inheritAll()).traced(trace)),\n  poll: Debug.methodWithTrace(trace => () => core.zipWith(self.poll(), that.poll(), (optionA, optionB) => Option.flatMap(exitA => Option.map(exitB => Exit.zipWith(exitB, restore(f), internalCause.parallel)(exitA))(optionB))(optionA)).traced(trace)),\n  interruptAsFork: Debug.methodWithTrace(trace => id => core.zipRight(self.interruptAsFork(id), that.interruptAsFork(id)).traced(trace))\n}));\n//# sourceMappingURL=circular.mjs.map","import * as core from \"@effect/io/internal_effect_untraced/core\";\nimport * as circular from \"@effect/io/internal_effect_untraced/effect/circular\";\nimport * as internal from \"@effect/io/internal_effect_untraced/fiber\";\nimport * as fiberRuntime from \"@effect/io/internal_effect_untraced/fiberRuntime\";\n/**\n * @since 1.0.0\n * @category symbols\n */\nexport const FiberTypeId = internal.FiberTypeId;\n/**\n * @since 1.0.0\n * @category symbols\n */\nexport const RuntimeFiberTypeId = internal.RuntimeFiberTypeId;\n/**\n * @since 1.0.0\n * @category instances\n */\nexport const Order = internal.Order;\n/**\n * Returns `true` if the specified value is a `Fiber`, `false` otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexport const isFiber = internal.isFiber;\n/**\n * Returns `true` if the specified `Fiber` is a `RuntimeFiber`, `false`\n * otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexport const isRuntimeFiber = internal.isRuntimeFiber;\n/**\n * The identity of the fiber.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const id = internal.id;\nconst _await = internal._await;\nexport {\n/**\n * Awaits the fiber, which suspends the awaiting fiber until the result of the\n * fiber has been determined.\n *\n * @since 1.0.0\n * @category getters\n */\n_await as await };\n/**\n * Awaits on all fibers to be completed, successfully or not.\n *\n * @since 1.0.0\n * @category destructors\n */\nexport const awaitAll = fiberRuntime.fiberAwaitAll;\n/**\n * Retrieves the immediate children of the fiber.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const children = internal.children;\n/**\n * Collects all fibers into a single fiber producing an in-order list of the\n * results.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const collectAll = fiberRuntime.fiberCollectAll;\n/**\n * A fiber that is done with the specified `Exit` value.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const done = internal.done;\n/**\n * @since 1.0.0\n * @category destructors\n */\nexport const dump = internal.dump;\n/**\n * @since 1.0.0\n * @category destructors\n */\nexport const dumpAll = internal.dumpAll;\n/**\n * A fiber that has already failed with the specified value.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const fail = internal.fail;\n/**\n * Creates a `Fiber` that has already failed with the specified cause.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const failCause = internal.failCause;\n/**\n * Lifts an `Effect` into a `Fiber`.\n *\n * @since 1.0.0\n * @category conversions\n */\nexport const fromEffect = internal.fromEffect;\n/**\n * Gets the current fiber if one is running.\n *\n * @since 1.0.0\n * @category utilities\n */\nexport const getCurrentFiber = internal.getCurrentFiber;\n/**\n * Inherits values from all `FiberRef` instances into current fiber. This\n * will resume immediately.\n *\n * @since 1.0.0\n * @category destructors\n */\nexport const inheritAll = internal.inheritAll;\n/**\n * Interrupts the fiber from whichever fiber is calling this method. If the\n * fiber has already exited, the returned effect will resume immediately.\n * Otherwise, the effect will resume when the fiber exits.\n *\n * @since 1.0.0\n * @category interruption\n */\nexport const interrupt = core.interruptFiber;\n/**\n * Constructrs a `Fiber` that is already interrupted.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const interrupted = internal.interrupted;\n/**\n * Interrupts the fiber as if interrupted from the specified fiber. If the\n * fiber has already exited, the returned effect will resume immediately.\n * Otherwise, the effect will resume when the fiber exits.\n *\n * @since 1.0.0\n * @category interruption\n */\nexport const interruptAs = core.interruptAsFiber;\n/**\n * Interrupts the fiber as if interrupted from the specified fiber. If the\n * fiber has already exited, the returned effect will resume immediately.\n * Otherwise, the effect will resume when the fiber exits.\n *\n * @since 1.0.0\n * @category interruption\n */\nexport const interruptAsFork = internal.interruptAsFork;\n/**\n * Interrupts all fibers, awaiting their interruption.\n *\n * @since 1.0.0\n * @category interruption\n */\nexport const interruptAll = internal.interruptAll;\n/**\n * Interrupts all fibers as by the specified fiber, awaiting their\n * interruption.\n *\n * @since 1.0.0\n * @category interruption\n */\nexport const interruptAllWith = internal.interruptAllWith;\n/**\n * Interrupts the fiber from whichever fiber is calling this method. The\n * interruption will happen in a separate daemon fiber, and the returned\n * effect will always resume immediately without waiting.\n *\n * @since 1.0.0\n * @category interruption\n */\nexport const interruptFork = fiberRuntime.fiberInterruptFork;\n/**\n * Joins the fiber, which suspends the joining fiber until the result of the\n * fiber has been determined. Attempting to join a fiber that has erred will\n * result in a catchable error. Joining an interrupted fiber will result in an\n * \"inner interruption\" of this fiber, unlike interruption triggered by\n * another fiber, \"inner interruption\" can be caught and recovered.\n *\n * @since 1.0.0\n * @category destructors\n */\nexport const join = internal.join;\n/**\n * Joins all fibers, awaiting their _successful_ completion. Attempting to\n * join a fiber that has erred will result in a catchable error, _if_ that\n * error does not result from interruption.\n *\n * @since 1.0.0\n * @category destructors\n */\nexport const joinAll = fiberRuntime.fiberJoinAll;\n/**\n * Maps over the value the Fiber computes.\n *\n * @since 1.0.0\n * @category mapping\n */\nexport const map = internal.map;\n/**\n * Effectually maps over the value the fiber computes.\n *\n * @since 1.0.0\n * @category mapping\n */\nexport const mapEffect = internal.mapEffect;\n/**\n * Passes the success of this fiber to the specified callback, and continues\n * with the fiber that it returns.\n *\n * @since 1.0.0\n * @category mapping\n */\nexport const mapFiber = internal.mapFiber;\n/**\n * Folds over the `Fiber` or `RuntimeFiber`.\n *\n * @since 1.0.0\n * @category folding\n */\nexport const match = internal.match;\n/**\n * A fiber that never fails or succeeds.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const never = internal.never;\n/**\n * Returns a fiber that prefers `this` fiber, but falls back to the `that` one\n * when `this` one fails. Interrupting the returned fiber will interrupt both\n * fibers, sequentially, from left to right.\n *\n * @since 1.0.0\n * @category alternatives\n */\nexport const orElse = internal.orElse;\n/**\n * Returns a fiber that prefers `this` fiber, but falls back to the `that` one\n * when `this` one fails. Interrupting the returned fiber will interrupt both\n * fibers, sequentially, from left to right.\n *\n * @since 1.0.0\n * @category alternatives\n */\nexport const orElseEither = internal.orElseEither;\n/**\n * Tentatively observes the fiber, but returns immediately if it is not\n * already done.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const poll = internal.poll;\n/**\n * Pretty-prints a `RuntimeFiber`.\n *\n * @since 1.0.0\n * @category destructors\n */\nexport const pretty = internal.pretty;\n/**\n * Returns a chunk containing all root fibers.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const roots = internal.roots;\n/**\n * Returns a chunk containing all root fibers.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const unsafeRoots = internal.unsafeRoots;\n/**\n * Converts this fiber into a scoped effect. The fiber is interrupted when the\n * scope is closed.\n *\n * @since 1.0.0\n * @category destructors\n */\nexport const scoped = fiberRuntime.fiberScoped;\n/**\n * Returns the `FiberStatus` of a `RuntimeFiber`.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const status = internal.status;\n/**\n * Returns a fiber that has already succeeded with the specified value.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const succeed = internal.succeed;\n/**\n * A fiber that has already succeeded with unit.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const unit = internal.unit;\n/**\n * Zips this fiber and the specified fiber together, producing a tuple of\n * their output.\n *\n * @since 1.0.0\n * @category zipping\n */\nexport const zip = circular.zipFiber;\n/**\n * Same as `zip` but discards the output of that `Fiber`.\n *\n * @since 1.0.0\n * @category zipping\n */\nexport const zipLeft = circular.zipLeftFiber;\n/**\n * Same as `zip` but discards the output of this `Fiber`.\n *\n * @since 1.0.0\n * @category zipping\n */\nexport const zipRight = circular.zipRightFiber;\n/**\n * Zips this fiber with the specified fiber, combining their results using the\n * specified combiner function. Both joins and interruptions are performed in\n * sequential order from left to right.\n *\n * @since 1.0.0\n * @category zipping\n */\nexport const zipWith = circular.zipWithFiber;\n//# sourceMappingURL=Fiber.mjs.map","import * as Debug from \"@effect/io/Debug\";\nimport * as Exit from \"@effect/io/Exit\";\nimport * as Fiber from \"@effect/io/Fiber\";\nimport * as FiberId from \"@effect/io/Fiber/Id\";\nimport * as FiberRefs from \"@effect/io/FiberRefs\";\nimport * as internalCause from \"@effect/io/internal_effect_untraced/cause\";\nimport * as core from \"@effect/io/internal_effect_untraced/core\";\nimport * as FiberRuntime from \"@effect/io/internal_effect_untraced/fiberRuntime\";\nimport * as fiberScope from \"@effect/io/internal_effect_untraced/fiberScope\";\nimport { unsafeRunSync, unsafeRunSyncExit } from \"@effect/io/internal_effect_untraced/logger\";\nimport * as OpCodes from \"@effect/io/internal_effect_untraced/opCodes/effect\";\nimport * as runtimeFlags from \"@effect/io/internal_effect_untraced/runtimeFlags\";\nimport * as _supervisor from \"@effect/io/internal_effect_untraced/supervisor\";\nimport { identity } from \"@fp-ts/core/Function\";\nimport * as Option from \"@fp-ts/core/Option\";\nimport * as Context from \"@fp-ts/data/Context\";\n/** @internal */\nexport const unsafeFork = runtime => (effect, scheduler) => runtime.unsafeFork(effect, scheduler);\n/** @internal */\nexport const unsafeRunCallback = runtime => (effect, onExit) => {\n  const fiberRuntime = unsafeFork(runtime)(effect);\n  if (onExit) {\n    fiberRuntime.unsafeAddObserver(exit => {\n      onExit(exit);\n    });\n  }\n  return (id, onExitInterrupt) => unsafeRunCallback(runtime)(Fiber.interruptAs(id ?? FiberId.none)(fiberRuntime), onExitInterrupt ? exit => {\n    return onExitInterrupt(Exit.flatten(exit));\n  } : void 0);\n};\n/** @internal */\nexport const unsafeRunSyncEither = runtime => effect => Debug.untraced(() => unsafeRunSync(runtime)(core.either(effect)));\n/** @internal */\nexport const unsafeRunPromise = runtime => effect => {\n  return new Promise((resolve, reject) => {\n    unsafeRunCallback(runtime)(effect, exit => {\n      switch (exit._tag) {\n        case OpCodes.OP_SUCCESS:\n          {\n            resolve(exit.value);\n            break;\n          }\n        case OpCodes.OP_FAILURE:\n          {\n            reject(internalCause.squashWith(identity)(exit.cause));\n            break;\n          }\n      }\n    });\n  });\n};\n/** @internal */\nexport const unsafeRunPromiseExit = runtime => effect => {\n  return new Promise(resolve => {\n    unsafeRunCallback(runtime)(effect, exit => {\n      resolve(exit);\n    });\n  });\n};\n/** @internal */\nexport const unsafeRunPromiseEither = runtime => effect => unsafeRunPromise(runtime)(core.either(effect));\n/** @internal */\nexport class RuntimeImpl {\n  constructor(context, runtimeFlags, fiberRefs) {\n    this.context = context;\n    this.runtimeFlags = runtimeFlags;\n    this.fiberRefs = fiberRefs;\n  }\n  unsafeFork(effect, scheduler) {\n    const fiberId = FiberId.unsafeMake();\n    let fiberRefs = FiberRefs.updatedAs(this.fiberRefs, fiberId, core.currentContext, this.context);\n    if (scheduler) {\n      fiberRefs = FiberRefs.updatedAs(fiberRefs, fiberId, core.currentScheduler, scheduler);\n    }\n    const fiberRuntime = new FiberRuntime.FiberRuntime(fiberId, FiberRefs.forkAs(fiberRefs, fiberId), this.runtimeFlags, this);\n    const supervisor = fiberRuntime.getSupervisor();\n    if (supervisor !== _supervisor.none) {\n      supervisor.onStart(this.context, effect, Option.none(), fiberRuntime);\n      fiberRuntime.unsafeAddObserver(exit => supervisor.onEnd(exit, fiberRuntime));\n    }\n    fiberScope.globalScope.add(this.runtimeFlags, fiberRuntime);\n    fiberRuntime.start(effect);\n    return fiberRuntime;\n  }\n}\n/** @internal */\nexport const make = (context, runtimeFlags, fiberRefs) => new RuntimeImpl(context, runtimeFlags, fiberRefs);\n/** @internal */\nexport const runtime = /*#__PURE__*/Debug.methodWithTrace(trace => () => core.withFiberRuntime((state, status) => core.succeed(new RuntimeImpl(state.getFiberRef(core.currentContext), status.runtimeFlags, state.unsafeGetFiberRefs()))).traced(trace));\n/** @internal */\nexport const defaultRuntimeFlags = /*#__PURE__*/runtimeFlags.make(runtimeFlags.Interruption, runtimeFlags.CooperativeYielding);\n/** @internal */\nexport const defaultRuntime = /*#__PURE__*/make( /*#__PURE__*/Context.empty(), defaultRuntimeFlags, /*#__PURE__*/FiberRefs.unsafeMake( /*#__PURE__*/new Map()));\n/** @internal */\nexport const unsafeRunEffect = /*#__PURE__*/unsafeRunCallback(defaultRuntime);\n/** @internal */\nexport const unsafeForkEffect = /*#__PURE__*/unsafeFork(defaultRuntime);\n/** @internal */\nexport const unsafeRunPromiseEffect = /*#__PURE__*/unsafeRunPromise(defaultRuntime);\n/** @internal */\nexport const unsafeRunPromiseEitherEffect = /*#__PURE__*/unsafeRunPromiseEither(defaultRuntime);\n/** @internal */\nexport const unsafeRunPromiseExitEffect = /*#__PURE__*/unsafeRunPromiseExit(defaultRuntime);\n/** @internal */\nexport const unsafeRunSyncEffect = /*#__PURE__*/unsafeRunSync(defaultRuntime);\n/** @internal */\nexport const unsafeRunSyncExitEffect = /*#__PURE__*/unsafeRunSyncExit(defaultRuntime);\n/** @internal */\nexport const unsafeRunSyncEitherEffect = /*#__PURE__*/unsafeRunSyncEither(defaultRuntime);\n// circular with Effect\n/** @internal */\nexport const asyncEffect = /*#__PURE__*/Debug.methodWithTrace((trace, restoreTrace) => register => core.flatMap(core.deferredMake(), deferred => core.flatMap(runtime(), runtime => core.uninterruptibleMask(restore => core.zipRight(FiberRuntime.fork(restore(core.catchAllCause(restoreTrace(register)(cb => unsafeRunCallback(runtime)(core.intoDeferred(deferred)(cb))), cause => core.deferredFailCause(deferred, cause)))), restore(core.deferredAwait(deferred)))))).traced(trace));\n//# sourceMappingURL=runtime.mjs.map","import { prettySafe } from \"@effect/io/internal_effect_untraced/cause-pretty\";\nimport { unsafeRunSyncEffect } from \"@effect/io/internal_effect_untraced/runtime\";\n/** @internal */\nexport const pretty = cause => unsafeRunSyncEffect(prettySafe(cause));\n//# sourceMappingURL=cause-pretty-run.mjs.map","import * as internal from \"@effect/io/internal_effect_untraced/cause\";\nimport * as _pretty_run from \"@effect/io/internal_effect_untraced/cause-pretty-run\";\n/**\n * @since 1.0.0\n * @category symbols\n */\nexport const CauseTypeId = internal.CauseTypeId;\n/**\n * @since 1.0.0\n * @category symbols\n */\nexport const RuntimeExceptionTypeId = internal.RuntimeExceptionTypeId;\n/**\n * @since 1.0.0\n * @category symbols\n */\nexport const InterruptedExceptionTypeId = internal.InterruptedExceptionTypeId;\n/**\n * @since 1.0.0\n * @category symbols\n */\nexport const IllegalArgumentExceptionTypeId = internal.IllegalArgumentExceptionTypeId;\n/**\n * @since 1.0.0\n * @category symbols\n */\nexport const NoSuchElementExceptionTypeId = internal.NoSuchElementExceptionTypeId;\n/**\n * @since 1.0.0\n * @category symbols\n */\nexport const InvalidHubCapacityExceptionTypeId = internal.InvalidHubCapacityExceptionTypeId;\n/**\n * @since 1.0.0\n * @category symbols\n */\nexport const StackAnnotationTypeId = internal.StackAnnotationTypeId;\n/**\n * Constructs a new `Empty` cause.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const empty = internal.empty;\n/**\n * Constructs a new `Fail` cause from the specified `error`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const fail = internal.fail;\n/**\n * Constructs a new `Die` cause from the specified `defect`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const die = internal.die;\n/**\n * Constructs a new `Interrupt` cause from the specified `fiberId`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const interrupt = internal.interrupt;\n/**\n * Constructs a new `Annotated` cause from the specified `annotation`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const annotated = internal.annotated;\n/**\n * Constructs a new `Parallel` cause from the specified `left` and `right`\n * causes.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const parallel = internal.parallel;\n/**\n * Constructs a new `Sequential` cause from the specified pecified `left` and\n * `right` causes.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const sequential = internal.sequential;\n/**\n * Returns `true` if the specified value is a `Cause`, `false` otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexport const isCause = internal.isCause;\n/**\n * Returns `true` if the specified `Cause` is an `Empty` type, `false`\n * otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexport const isEmptyType = internal.isEmptyType;\n/**\n * Returns `true` if the specified `Cause` is a `Fail` type, `false`\n * otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexport const isFailType = internal.isFailType;\n/**\n * Returns `true` if the specified `Cause` is a `Die` type, `false`\n * otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexport const isDieType = internal.isDieType;\n/**\n * Returns `true` if the specified `Cause` is an `Interrupt` type, `false`\n * otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexport const isInterruptType = internal.isInterruptType;\n/**\n * Returns `true` if the specified `Cause` is an `Annotated` type, `false`\n * otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexport const isAnnotatedType = internal.isAnnotatedType;\n/**\n * Returns `true` if the specified `Cause` is a `Sequential` type, `false`\n * otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexport const isSequentialType = internal.isSequentialType;\n/**\n * Returns `true` if the specified `Cause` is a `Parallel` type, `false`\n * otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexport const isParallelType = internal.isParallelType;\n/**\n * Returns the size of the cause, calculated as the number of individual `Cause`\n * nodes found in the `Cause` semiring structure.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const size = internal.size;\n/**\n * Returns `true` if the specified cause is empty, `false` otherwise.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const isEmpty = internal.isEmpty;\n/**\n * Returns `true` if the specified cause contains a failure, `false` otherwise.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const isFailure = internal.isFailure;\n/**\n * Returns `true` if the specified cause contains a defect, `false` otherwise.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const isDie = internal.isDie;\n/**\n * Returns `true` if the specified cause contains an interruption, `false`\n * otherwise.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const isInterrupted = internal.isInterrupted;\n/**\n * Returns `true` if the specified cause contains only interruptions (without\n * any `Die` or `Fail` causes), `false` otherwise.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const isInterruptedOnly = internal.isInterruptedOnly;\n/**\n * Returns a `List` of all recoverable errors of type `E` in the specified\n * cause.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const failures = internal.failures;\n/**\n * Returns a `List` of all unrecoverable defects in the specified cause.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const defects = internal.defects;\n/**\n * Returns a `HashSet` of `FiberId`s for all fibers that interrupted the fiber\n * described by the specified cause.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const interruptors = internal.interruptors;\n/**\n * Returns the `E` associated with the first `Fail` in this `Cause`, if one\n * exists.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const failureOption = internal.failureOption;\n/**\n * Returns the first checked error on the `Left` if available, if there are\n * no checked errors return the rest of the `Cause` that is known to contain\n * only `Die` or `Interrupt` causes.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const failureOrCause = internal.failureOrCause;\n/**\n * Converts the specified `Cause<Option<E>>` to an `Option<Cause<E>>` by\n * recursively stripping out any failures with the error `None`.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const flipCauseOption = internal.flipCauseOption;\n/**\n * Returns the defect associated with the first `Die` in this `Cause`, if one\n * exists.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const dieOption = internal.dieOption;\n/**\n * Returns the `FiberId` associated with the first `Interrupt` in the specified\n * cause, if one exists.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const interruptOption = internal.interruptOption;\n/**\n * Remove all `Fail` and `Interrupt` nodes from the specified cause, and return\n * a cause containing only `Die` cause/finalizer defects.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const keepDefects = internal.keepDefects;\n/**\n * Linearizes the specified cause into a `HashSet` of parallel causes where each\n * parallel cause contains a linear sequence of failures.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const linearize = internal.linearize;\n/**\n * Remove all `Fail` and `Interrupt` nodes from the specified cause, and return\n * a cause containing only `Die` cause/finalizer defects.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const stripFailures = internal.stripFailures;\n/**\n * Remove all `Die` causes that the specified partial function is defined at,\n * returning `Some` with the remaining causes or `None` if there are no\n * remaining causes.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const stripSomeDefects = internal.stripSomeDefects;\n/**\n * @since 1.0.0\n * @category mapping\n */\nexport const as = internal.as;\n/**\n * @since 1.0.0\n * @category mapping\n */\nexport const map = internal.map;\n/**\n * @since 1.0.0\n * @category sequencing\n */\nexport const flatMap = internal.flatMap;\n/**\n * @since 1.0.0\n * @category sequencing\n */\nexport const flatten = internal.flatten;\n/**\n * Returns `true` if the `self` cause contains or is equal to `that` cause,\n * `false` otherwise.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const contains = internal.contains;\n/**\n * Squashes a `Cause` down to a single defect, chosen to be the \"most important\"\n * defect.\n *\n * @since 1.0.0\n * @category destructors\n */\nexport const squash = internal.squash;\n/**\n * Squashes a `Cause` down to a single defect, chosen to be the \"most important\"\n * defect. If a recoverable error is found, the provided function will be used\n * to map the error a defect, and the resulting value will be returned.\n *\n * @since 1.0.0\n * @category destructors\n */\nexport const squashWith = internal.squashWith;\n/**\n * Uses the provided partial function to search the specified cause and attempt\n * to extract information from it.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const find = internal.find;\n/**\n * Filters causes which match the provided predicate out of the specified cause.\n *\n * @since 1.0.0\n * @category filtering\n */\nexport const filter = internal.filter;\n/**\n * Folds the specified cause into a value of type `Z`.\n *\n * @since 1.0.0\n * @category folding\n */\nexport const match = internal.match;\n/**\n * Reduces the specified cause into a value of type `Z`, beginning with the\n * provided `zero` value.\n *\n * @since 1.0.0\n * @category folding\n */\nexport const reduce = internal.reduce;\n/**\n * Reduces the specified cause into a value of type `Z` using a `Cause.Reducer`.\n * Also allows for accessing the provided context during reduction.\n *\n * @since 1.0.0\n * @category folding\n */\nexport const reduceWithContext = internal.reduceWithContext;\n/**\n * Represents a checked exception which occurs when a `Fiber` is interrupted.\n *\n * @since 1.0.0\n * @category errors\n */\nexport const InterruptedException = internal.InterruptedException;\n/**\n * Returns `true` if the specified value is an `InterruptedException`, `false`\n * otherwise.\n\n * @since 1.0.0\n * @category refinements\n */\nexport const isInterruptedException = internal.isInterruptedException;\n/**\n * Represents a checked exception which occurs when an invalid argument is\n * provided to a method.\n *\n * @since 1.0.0\n * @category errors\n */\nexport const IllegalArgumentException = internal.IllegalArgumentException;\n/**\n * Returns `true` if the specified value is an `IllegalArgumentException`, `false`\n * otherwise.\n\n * @since 1.0.0\n * @category refinements\n */\nexport const isIllegalArgumentException = internal.isIllegalArgumentException;\n/**\n * Represents a checked exception which occurs when an expected element was\n * unable to be found.\n *\n * @since 1.0.0\n * @category errors\n */\nexport const NoSuchElementException = internal.NoSuchElementException;\n/**\n  * Returns `true` if the specified value is an `IllegalArgumentException`, `false`\n  * otherwise.\n\n  * @since 1.0.0\n  * @category refinements\n  */\nexport const isNoSuchElementException = internal.isNoSuchElementException;\n/**\n * Represents a generic checked exception which occurs at runtime.\n *\n * @since 1.0.0\n * @category errors\n */\nexport const RuntimeException = internal.RuntimeException;\n/**\n  * Returns `true` if the specified value is an `RuntimeException`, `false`\n  * otherwise.\n\n  * @since 1.0.0\n  * @category refinements\n  */\nexport const isRuntimeException = internal.isRuntimeException;\n/**\n * Returns the specified `Cause` as a pretty-printed string.\n *\n * @since 1.0.0\n * @category rendering\n */\nexport const pretty = _pretty_run.pretty;\n/**\n * Checks if an annotation is a StackAnnotation\n *\n * @since 1.0.0\n * @category guards\n */\nexport const isStackAnnotation = internal.isStackAnnotation;\n/**\n * Removes any annotation from the cause\n *\n * @since 1.0.0\n * @category filtering\n */\nexport const unannotate = internal.unannotate;\n//# sourceMappingURL=Cause.mjs.map","/** @internal */\nexport const OP_EXTEND_SCOPE = \"ExtendScope\";\n/** @internal */\nexport const OP_FOLD = \"Fold\";\n/** @internal */\nexport const OP_FRESH = \"Fresh\";\n/** @internal */\nexport const OP_FROM_EFFECT = \"FromEffect\";\n/** @internal */\nexport const OP_SCOPED = \"Scoped\";\n/** @internal */\nexport const OP_SUSPEND = \"Suspend\";\n/** @internal */\nexport const OP_PROVIDE_TO = \"ProvideTo\";\n/** @internal */\nexport const OP_ZIP_WITH = \"ZipWith\";\n/** @internal */\nexport const OP_ZIP_WITH_PAR = \"ZipWithPar\";\n//# sourceMappingURL=layer.mjs.map","import * as Debug from \"@effect/io/Debug\";\nimport * as core from \"@effect/io/internal_effect_untraced/core\";\nimport * as Option from \"@fp-ts/core/Option\";\n/** @internal */\nexport const getAndUpdateEffect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => self.modifyEffect(value => core.map(restore(f)(value), result => [value, result])).traced(trace));\n/** @internal */\nexport const getAndUpdateSomeEffect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, pf) => self.modifyEffect(value => {\n  const result = restore(pf)(value);\n  switch (result._tag) {\n    case \"None\":\n      {\n        return core.succeed([value, value]);\n      }\n    case \"Some\":\n      {\n        return core.map(result.value, newValue => [value, newValue]);\n      }\n  }\n}).traced(trace));\n/** @internal */\nexport const modify = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => self.modify(restore(f)).traced(trace));\n/** @internal */\nexport const modifyEffect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => self.modifyEffect(restore(f)).traced(trace));\n/** @internal */\nexport const modifySomeEffect = /*#__PURE__*/Debug.dualWithTrace(3, (trace, restore) => (self, fallback, pf) => self.modifyEffect(value => Option.getOrElse(() => core.succeed([fallback, value]))(restore(pf)(value))).traced(trace));\n/** @internal */\nexport const updateEffect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => self.modifyEffect(value => core.map(restore(f)(value), result => [undefined, result])).traced(trace));\n/** @internal */\nexport const updateAndGetEffect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, f) => self.modifyEffect(value => core.map(restore(f)(value), result => [result, result])).traced(trace));\n/** @internal */\nexport const updateSomeEffect = /*#__PURE__*/Debug.dualWithTrace(2, (trace, restore) => (self, pf) => self.modifyEffect(value => {\n  const result = restore(pf)(value);\n  switch (result._tag) {\n    case \"None\":\n      {\n        return core.succeed([void 0, value]);\n      }\n    case \"Some\":\n      {\n        return core.map(result.value, a => [void 0, a]);\n      }\n  }\n}).traced(trace));\n//# sourceMappingURL=synchronizedRef.mjs.map","/**\n * @since 1.0.0\n */\nimport * as core from \"@effect/io/internal_effect_untraced/core\";\nimport * as fiberRuntime from \"@effect/io/internal_effect_untraced/fiberRuntime\";\n/**\n * @since 1.0.0\n * @category symbols\n */\nexport const ScopeTypeId = core.ScopeTypeId;\n/**\n * @since 1.0.0\n * @category symbols\n */\nexport const CloseableScopeTypeId = core.CloseableScopeTypeId;\n/**\n * @since 1.0.0\n * @category context\n */\nexport const Tag = fiberRuntime.scopeTag;\n/**\n * Adds a finalizer to this scope. The finalizer is guaranteed to be run when\n * the scope is closed.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const addFinalizer = core.scopeAddFinalizer;\n/**\n * A simplified version of `addFinalizerWith` when the `finalizer` does not\n * depend on the `Exit` value that the scope is closed with.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const addFinalizerExit = core.scopeAddFinalizerExit;\n/**\n * Closes a scope with the specified exit value, running all finalizers that\n * have been added to the scope.\n *\n * @since 1.0.0\n * @category destructors\n */\nexport const close = core.scopeClose;\n/**\n * Extends the scope of an `Effect` workflow that needs a scope into this\n * scope by providing it to the workflow but not closing the scope when the\n * workflow completes execution. This allows extending a scoped value into a\n * larger scope.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const extend = fiberRuntime.scopeExtend;\n/**\n * Forks a new scope that is a child of this scope. The child scope will\n * automatically be closed when this scope is closed.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const fork = core.scopeFork;\n/**\n * Uses the scope by providing it to an `Effect` workflow that needs a scope,\n * guaranteeing that the scope is closed with the result of that workflow as\n * soon as the workflow completes execution, whether by success, failure, or\n * interruption.\n *\n * @since 1.0.0\n * @category destructors\n */\nexport const use = fiberRuntime.scopeUse;\n/**\n * Creates a Scope where Finalizers will run according to the `ExecutionStrategy`.\n *\n * If an ExecutionStrategy is not provided `sequential` will be used.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const make = fiberRuntime.scopeMake;\n//# sourceMappingURL=Scope.mjs.map","import * as Cause from \"@effect/io/Cause\";\nimport * as Clock from \"@effect/io/Clock\";\nimport * as Debug from \"@effect/io/Debug\";\nimport * as core from \"@effect/io/internal_effect_untraced/core\";\nimport * as effect from \"@effect/io/internal_effect_untraced/effect\";\nimport * as circular from \"@effect/io/internal_effect_untraced/effect/circular\";\nimport * as fiberRuntime from \"@effect/io/internal_effect_untraced/fiberRuntime\";\nimport * as EffectOpCodes from \"@effect/io/internal_effect_untraced/opCodes/effect\";\nimport * as OpCodes from \"@effect/io/internal_effect_untraced/opCodes/layer\";\nimport * as ref from \"@effect/io/internal_effect_untraced/ref\";\nimport * as runtime from \"@effect/io/internal_effect_untraced/runtime\";\nimport * as synchronized from \"@effect/io/internal_effect_untraced/synchronizedRef\";\nimport * as ScheduleDecision from \"@effect/io/Schedule/Decision\";\nimport * as Intervals from \"@effect/io/Schedule/Intervals\";\nimport * as Scope from \"@effect/io/Scope\";\nimport * as Context from \"@fp-ts/data/Context\";\nimport * as Duration from \"@fp-ts/data/Duration\";\n/** @internal */\nconst LayerSymbolKey = \"@effect/io/Layer\";\n/** @internal */\nexport const LayerTypeId = /*#__PURE__*/Symbol.for(LayerSymbolKey);\n/** @internal */\nconst layerVariance = {\n  _RIn: _ => _,\n  _E: _ => _,\n  _ROut: _ => _\n};\n/** @internal */\nconst proto = {\n  [LayerTypeId]: layerVariance\n};\n/** @internal */\nexport const isLayer = u => {\n  return typeof u === \"object\" && u != null && LayerTypeId in u;\n};\n/** @internal */\nexport const isFresh = self => {\n  return self._tag === OpCodes.OP_FRESH;\n};\n// -----------------------------------------------------------------------------\n// MemoMap\n// -----------------------------------------------------------------------------\n/** @internal */\nclass MemoMap {\n  constructor(ref) {\n    this.ref = ref;\n  }\n  /**\n   * Checks the memo map to see if a layer exists. If it is, immediately\n   * returns it. Otherwise, obtains the layer, stores it in the memo map,\n   * and adds a finalizer to the `Scope`.\n   */\n  getOrElseMemoize(layer, scope) {\n    return core.flatten(synchronized.modifyEffect(this.ref, map => {\n      const inMap = map.get(layer);\n      if (inMap !== undefined) {\n        const [acquire, release] = inMap;\n        const cached = core.onExit(core.exitMatch(() => core.unit(), () => core.scopeAddFinalizerExit(scope, release)))(core.flatMap(([patch, b]) => core.as(b)(effect.patchFiberRefs(patch)))(acquire));\n        return core.succeed([cached, map]);\n      }\n      return core.flatMap(observers => core.flatMap(deferred => core.map(finalizerRef => {\n        const resource = core.uninterruptibleMask(restore => core.flatMap(innerScope => core.flatMap(exit => {\n          switch (exit._tag) {\n            case EffectOpCodes.OP_FAILURE:\n              {\n                return core.zipRight(core.failCause(exit.cause))(core.zipRight(core.scopeClose(innerScope, exit))(core.deferredFailCause(deferred, exit.cause)));\n              }\n            case EffectOpCodes.OP_SUCCESS:\n              {\n                return core.as(exit.value[1])(core.zipRight(core.deferredSucceed(deferred, exit.value))(core.zipRight(core.scopeAddFinalizerExit(scope, exit => core.flatMap(finalizer => finalizer(exit))(ref.get(finalizerRef))))(core.zipRight(ref.update(observers, n => n + 1))(ref.set(finalizerRef, exit => core.asUnit(core.whenEffect(ref.modify(observers, n => [n === 1, n - 1]))(core.scopeClose(innerScope, exit))))))));\n              }\n          }\n        })(core.exit(restore(core.flatMap(withScope(layer, innerScope), f => effect.diffFiberRefs(f(this)))))))(fiberRuntime.scopeMake()));\n        const memoized = [core.onExit(core.exitMatchEffect(() => core.unit(), () => ref.update(observers, n => n + 1)))(core.deferredAwait(deferred)), exit => core.flatMap(finalizer => finalizer(exit))(ref.get(finalizerRef))];\n        return [resource, isFresh(layer) ? map : map.set(layer, memoized)];\n      })(ref.make(() => core.unit())))(core.deferredMake()))(ref.make(0));\n    }));\n  }\n}\nconst makeMemoMap = () => {\n  return core.map(ref => new MemoMap(ref))(circular.makeSynchronized(new Map()));\n};\n/** @internal */\nexport const build = /*#__PURE__*/Debug.methodWithTrace(trace => self => fiberRuntime.scopeWith(scope => buildWithScope(scope)(self)).traced(trace));\n/** @internal */\nexport const buildWithScope = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, scope) => core.flatMap(makeMemoMap(), memoMap => core.flatMap(withScope(self, scope), run => run(memoMap))).traced(trace));\nconst withScope = (self, scope) => {\n  const op = self;\n  switch (op._tag) {\n    case OpCodes.OP_EXTEND_SCOPE:\n      {\n        return core.sync(() => memoMap => fiberRuntime.scopeWith(scope => memoMap.getOrElseMemoize(op.layer, scope)));\n      }\n    case OpCodes.OP_FOLD:\n      {\n        return core.sync(() => memoMap => core.matchCauseEffect(cause => memoMap.getOrElseMemoize(op.failureK(cause), scope), value => memoMap.getOrElseMemoize(op.successK(value), scope))(memoMap.getOrElseMemoize(op.layer, scope)));\n      }\n    case OpCodes.OP_FRESH:\n      {\n        return core.sync(() => _ => buildWithScope(scope)(op.layer));\n      }\n    case OpCodes.OP_FROM_EFFECT:\n      {\n        return core.sync(() => _ => op.effect);\n      }\n    case OpCodes.OP_PROVIDE_TO:\n      {\n        return core.sync(() => memoMap => core.flatMap(env => core.provideContext(env)(memoMap.getOrElseMemoize(op.second, scope)))(memoMap.getOrElseMemoize(op.first, scope)));\n      }\n    case OpCodes.OP_SCOPED:\n      {\n        return core.sync(() => _ => fiberRuntime.scopeExtend(op.effect, scope));\n      }\n    case OpCodes.OP_SUSPEND:\n      {\n        return core.sync(() => memoMap => memoMap.getOrElseMemoize(op.evaluate(), scope));\n      }\n    case OpCodes.OP_ZIP_WITH:\n      {\n        return core.sync(() => memoMap => core.zipWith(memoMap.getOrElseMemoize(op.second, scope), op.zipK)(memoMap.getOrElseMemoize(op.first, scope)));\n      }\n    case OpCodes.OP_ZIP_WITH_PAR:\n      {\n        return core.sync(() => memoMap => circular.zipWithPar(memoMap.getOrElseMemoize(op.second, scope), op.zipK)(memoMap.getOrElseMemoize(op.first, scope)));\n      }\n  }\n};\n// -----------------------------------------------------------------------------\n// Layer\n// -----------------------------------------------------------------------------\n/** @internal */\nexport const catchAll = /*#__PURE__*/Debug.untracedDual(2, restore => (self, onError) => matchLayer(self, restore(onError), succeedContext));\n/** @internal */\nexport const catchAllCause = /*#__PURE__*/Debug.untracedDual(2, restore => (self, onError) => matchCauseLayer(self, restore(onError), succeedContext));\n/** @internal */\nexport const die = defect => failCause(Cause.die(defect));\n/** @internal */\nexport const dieSync = evaluate => failCauseSync(() => Cause.die(evaluate()));\n/** @internal */\nexport const discard = self => map(self, () => Context.empty());\n/** @internal */\nexport const context = () => fromEffectContext(core.context());\n/** @internal */\nexport const extendScope = self => {\n  const extendScope = Object.create(proto);\n  extendScope._tag = OpCodes.OP_EXTEND_SCOPE;\n  extendScope.layer = self;\n  return extendScope;\n};\n/** @internal */\nexport const fail = error => failCause(Cause.fail(error));\n/** @internal */\nexport const failSync = evaluate => failCauseSync(() => Cause.fail(evaluate()));\n/** @internal */\nexport const failCause = cause => fromEffectContext(core.failCause(cause));\n/** @internal */\nexport const failCauseSync = evaluate => fromEffectContext(core.failCauseSync(evaluate));\n/** @internal */\nexport const flatMap = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => matchLayer(self, fail, restore(f)));\n/** @internal */\nexport const flatten = /*#__PURE__*/Debug.dual(2, (self, tag) => flatMap(self, Context.get(tag)));\n/** @internal */\nexport const fresh = self => {\n  const fresh = Object.create(proto);\n  fresh._tag = OpCodes.OP_FRESH;\n  fresh.layer = self;\n  return fresh;\n};\n/** @internal */\nexport const fromEffect = (tag, effect) => fromEffectContext(core.map(effect, service => Context.make(tag, service)));\n/** @internal */\nexport const fromEffectDiscard = effect => fromEffectContext(core.map(effect, () => Context.empty()));\n/** @internal */\nexport function fromEffectContext(effect) {\n  const fromEffect = Object.create(proto);\n  fromEffect._tag = OpCodes.OP_FROM_EFFECT;\n  fromEffect.effect = effect;\n  return fromEffect;\n}\n/** @internal */\nexport const fromFunction = (tagA, tagB, f) => fromEffectContext(core.serviceWith(tagA, a => Context.make(tagB, f(a))));\n/** @internal */\nexport const launch = /*#__PURE__*/Debug.methodWithTrace(trace => self => fiberRuntime.scopedEffect(core.zipRight(fiberRuntime.scopeWith(scope => buildWithScope(scope)(self)), core.never())).traced(trace));\n/** @internal */\nexport const map = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => flatMap(self, context => succeedContext(restore(f)(context))));\n/** @internal */\nexport const mapError = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => catchAll(self, error => failSync(() => restore(f)(error))));\n/** @internal */\nexport const matchCauseLayer = /*#__PURE__*/Debug.untracedDual(3, restore => (self, onFailure, onSuccess) => {\n  const fold = Object.create(proto);\n  fold._tag = OpCodes.OP_FOLD;\n  fold.layer = self;\n  fold.failureK = restore(onFailure);\n  fold.successK = restore(onSuccess);\n  return fold;\n});\n/** @internal */\nexport const matchLayer = /*#__PURE__*/Debug.untracedDual(3, restore => (self, onFailure, onSuccess) => matchCauseLayer(self, cause => {\n  const failureOrCause = Cause.failureOrCause(cause);\n  switch (failureOrCause._tag) {\n    case \"Left\":\n      {\n        return restore(onFailure)(failureOrCause.left);\n      }\n    case \"Right\":\n      {\n        return failCause(failureOrCause.right);\n      }\n  }\n}, restore(onSuccess)));\n/** @internal */\nexport const memoize = /*#__PURE__*/Debug.methodWithTrace(trace => self => fiberRuntime.scopeWith(scope => core.map(fromEffectContext)(effect.memoize(buildWithScope(self, scope)))).traced(trace));\n/** @internal */\nexport const merge = /*#__PURE__*/Debug.dual(2, (self, that) => zipWithPar(self, that, (a, b) => Context.merge(b)(a)));\n/** @internal */\nexport const mergeAll = (...layers) => {\n  let final = layers[0];\n  for (let i = 1; i < layers.length; i++) {\n    final = merge(layers[i])(final);\n  }\n  return final;\n};\n/** @internal */\nexport const orDie = self => catchAll(self, defect => die(defect));\n/** @internal */\nexport const orElse = /*#__PURE__*/Debug.untracedDual(2, restore => (self, that) => catchAll(self, restore(that)));\n/** @internal */\nexport const passthrough = self => merge(context(), self);\n/** @internal */\nexport const project = /*#__PURE__*/Debug.untracedDual(4, restore => (self, tagA, tagB, f) => map(self, context => Context.make(tagB, restore(f)(Context.unsafeGet(context, tagA)))));\n/** @internal */\nexport const provide = /*#__PURE__*/Debug.dual(2, (self, that) => suspend(() => {\n  const provideTo = Object.create(proto);\n  provideTo._tag = OpCodes.OP_PROVIDE_TO;\n  provideTo.first = Object.create(proto, {\n    _tag: {\n      value: OpCodes.OP_ZIP_WITH,\n      enumerable: true\n    },\n    first: {\n      value: context(),\n      enumerable: true\n    },\n    second: {\n      value: self\n    },\n    zipK: {\n      value: (a, b) => Context.merge(b)(a)\n    }\n  });\n  provideTo.second = that;\n  return provideTo;\n}));\n/** @internal */\nexport const provideMerge = /*#__PURE__*/Debug.dual(2, (self, that) => {\n  const zipWith = Object.create(proto);\n  zipWith._tag = OpCodes.OP_ZIP_WITH;\n  zipWith.first = self;\n  zipWith.second = provide(that)(self);\n  zipWith.zipK = (a, b) => {\n    return Context.merge(b)(a);\n  };\n  return zipWith;\n});\n/** @internal */\nexport const retry = /*#__PURE__*/Debug.dual(2, (self, schedule) => suspend(() => {\n  const stateTag = Context.Tag();\n  return flatMap(env => retryLoop(self, schedule, stateTag, Context.get(stateTag)(env).state))(succeed(stateTag, {\n    state: schedule.initial\n  }));\n}));\n/** @internal */\nconst retryLoop = (self, schedule, stateTag, state) => {\n  return catchAll(error => flatMap(env => fresh(retryLoop(self, schedule, stateTag, Context.get(stateTag)(env).state)))(retryUpdate(schedule, stateTag, error, state)))(self);\n};\n/** @internal */\nconst retryUpdate = (schedule, stateTag, error, state) => {\n  return fromEffect(stateTag, core.flatMap(now => core.flatMap(([state, _, decision]) => ScheduleDecision.isDone(decision) ? core.fail(error) : core.as({\n    state\n  })(Clock.sleep(Duration.millis(Intervals.start(decision.intervals) - now))))(schedule.step(now, error, state)))(Clock.currentTimeMillis()));\n};\n/** @internal */\nexport const scope = () => {\n  return scopedContext(core.map(scope => Context.make(Scope.Tag, scope))(fiberRuntime.acquireRelease(fiberRuntime.scopeMake(), (scope, exit) => scope.close(exit))));\n};\n/** @internal */\nexport const scoped = (tag, effect) => {\n  return scopedContext(core.map(effect, service => Context.make(tag, service)));\n};\n/** @internal */\nexport const scopedDiscard = effect => {\n  return scopedContext(core.as(Context.empty())(effect));\n};\n/** @internal */\nexport const scopedContext = effect => {\n  const scoped = Object.create(proto);\n  scoped._tag = OpCodes.OP_SCOPED;\n  scoped.effect = effect;\n  return scoped;\n};\n/** @internal */\nexport const service = tag => {\n  return fromEffect(tag, core.service(tag));\n};\n/** @internal */\nexport const succeed = (tag, resource) => {\n  return fromEffectContext(core.succeed(Context.make(tag, resource)));\n};\n/** @internal */\nexport const succeedContext = context => {\n  return fromEffectContext(core.succeed(context));\n};\n/** @internal */\nexport const suspend = evaluate => {\n  const suspend = Object.create(proto);\n  suspend._tag = OpCodes.OP_SUSPEND;\n  suspend.evaluate = evaluate;\n  return suspend;\n};\n/** @internal */\nexport const sync = (tag, evaluate) => {\n  return fromEffectContext(core.sync(() => Context.make(tag, evaluate())));\n};\n/** @internal */\nexport const syncContext = evaluate => {\n  return fromEffectContext(core.sync(evaluate));\n};\n/** @internal */\nexport const tap = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => flatMap(self, context => fromEffectContext(core.as(restore(f)(context), context))));\n/** @internal */\nexport const tapError = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => catchAll(self, e => fromEffectContext(core.flatMap(restore(f)(e), () => core.fail(e)))));\n/** @internal */\nexport const tapErrorCause = /*#__PURE__*/Debug.untracedDual(2, restore => (self, f) => catchAllCause(self, cause => fromEffectContext(core.flatMap(restore(f)(cause), () => core.failCause(cause)))));\n/** @internal */\nexport const toRuntime = self => {\n  return core.flatMap(context => core.provideContext(context)(runtime.runtime()))(fiberRuntime.scopeWith(scope => buildWithScope(scope)(self)));\n};\n/** @internal */\nexport const use = /*#__PURE__*/Debug.dual(2, (that, self) => suspend(() => {\n  const provideTo = Object.create(proto);\n  provideTo._tag = OpCodes.OP_PROVIDE_TO;\n  provideTo.first = Object.create(proto, {\n    _tag: {\n      value: OpCodes.OP_ZIP_WITH,\n      enumerable: true\n    },\n    first: {\n      value: context(),\n      enumerable: true\n    },\n    second: {\n      value: self\n    },\n    zipK: {\n      value: (a, b) => Context.merge(b)(a)\n    }\n  });\n  provideTo.second = that;\n  return provideTo;\n}));\n/** @internal */\nexport const useMerge = /*#__PURE__*/Debug.dual(2, (that, self) => {\n  const zipWith = Object.create(proto);\n  zipWith._tag = OpCodes.OP_ZIP_WITH;\n  zipWith.first = self;\n  zipWith.second = provide(that)(self);\n  zipWith.zipK = (a, b) => {\n    return Context.merge(b)(a);\n  };\n  return zipWith;\n});\n/** @internal */\nexport const zipWithPar = /*#__PURE__*/Debug.untracedDual(3, restore => (self, that, f) => suspend(() => {\n  const zipWithPar = Object.create(proto);\n  zipWithPar._tag = OpCodes.OP_ZIP_WITH_PAR;\n  zipWithPar.first = self;\n  zipWithPar.second = that;\n  zipWithPar.zipK = restore(f);\n  return zipWithPar;\n}));\n// circular with Effect\n/** @internal */\nexport const provideLayer = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, layer) => core.acquireUseRelease(fiberRuntime.scopeMake(), scope => core.flatMap(buildWithScope(layer, scope), context => core.provideContext(self, context)), (scope, exit) => core.scopeClose(scope, exit)).traced(trace));\n/** @internal */\nexport const provideSomeLayer = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, layer) =>\n// @ts-expect-error\nprovideLayer(self, merge(layer)(context())).traced(trace));\n/** @internal */\nexport const toLayer = /*#__PURE__*/Debug.dual(2, (self, tag) => fromEffect(tag, self));\n/** @internal */\nexport const toLayerScoped = /*#__PURE__*/Debug.dual(2, (self, tag) => scoped(tag, self));\n//# sourceMappingURL=layer.mjs.map","import * as internal from \"@effect/io/internal_effect_untraced/layer\";\n/**\n * @since 1.0.0\n * @category symbols\n */\nexport const LayerTypeId = internal.LayerTypeId;\n/**\n * Returns `true` if the specified value is a `Layer`, `false` otherwise.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const isLayer = internal.isLayer;\n/**\n * Returns `true` if the specified `Layer` is a fresh version that will not be\n * shared, `false` otherwise.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const isFresh = internal.isFresh;\n/**\n * Builds a layer into a scoped value.\n *\n * @since 1.0.0\n * @category destructors\n */\nexport const build = internal.build;\n/**\n * Builds a layer into an `Effect` value. Any resources associated with this\n * layer will be released when the specified scope is closed unless their scope\n * has been extended. This allows building layers where the lifetime of some of\n * the services output by the layer exceed the lifetime of the effect the\n * layer is provided to.\n *\n * @since 1.0.0\n * @category destructors\n */\nexport const buildWithScope = internal.buildWithScope;\n/**\n * Recovers from all errors.\n *\n * @since 1.0.0\n * @category error handling\n */\nexport const catchAll = internal.catchAll;\n/**\n * Recovers from all errors.\n *\n * @since 1.0.0\n * @category error handling\n */\nexport const catchAllCause = internal.catchAllCause;\n/**\n * Constructs a `Layer` that passes along the specified context as an\n * output.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const context = internal.context;\n/**\n * Constructs a layer that dies with the specified defect.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const die = internal.die;\n/**\n * Constructs a layer that dies with the specified defect.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const dieSync = internal.dieSync;\n/**\n * Replaces the layer's output with `void` and includes the layer only for its\n * side-effects.\n *\n * @since 1.0.0\n * @category mapping\n */\nexport const discard = internal.discard;\n/**\n * Constructs a layer from the specified effect.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const effect = internal.fromEffect;\n/**\n * Constructs a layer from the specified effect discarding it's output.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const effectDiscard = internal.fromEffectDiscard;\n/**\n * Constructs a layer from the specified effect, which must return one or more\n * services.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const effectContext = internal.fromEffectContext;\n/**\n * Extends the scope of this layer, returning a new layer that when provided\n * to an effect will not immediately release its associated resources when\n * that effect completes execution but instead when the scope the resulting\n * effect depends on is closed.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const extendScope = internal.extendScope;\n/**\n * Constructs a layer that fails with the specified error.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const fail = internal.fail;\n/**\n * Constructs a layer that fails with the specified error.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const failSync = internal.failSync;\n/**\n * Constructs a layer that fails with the specified cause.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const failCause = internal.failCause;\n/**\n * Constructs a layer that fails with the specified cause.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const failCauseSync = internal.failCauseSync;\n/**\n * Constructs a layer dynamically based on the output of this layer.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexport const flatMap = internal.flatMap;\n/**\n * Flattens layers nested in the context of an effect.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexport const flatten = internal.flatten;\n/**\n * Creates a fresh version of this layer that will not be shared.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const fresh = internal.fresh;\nconst fromFunction = internal.fromFunction;\nexport {\n/**\n * Constructs a layer from the context using the specified function.\n *\n * @since 1.0.0\n * @category constructors\n */\nfromFunction as function };\n/**\n * Builds this layer and uses it until it is interrupted. This is useful when\n * your entire application is a layer, such as an HTTP server.\n *\n * @since 1.0.0\n * @category conversions\n */\nexport const launch = internal.launch;\n/**\n * Returns a new layer whose output is mapped by the specified function.\n *\n * @since 1.0.0\n * @category mapping\n */\nexport const map = internal.map;\n/**\n * Returns a layer with its error channel mapped using the specified function.\n *\n * @since 1.0.0\n * @category mapping\n */\nexport const mapError = internal.mapError;\n/**\n * Feeds the error or output services of this layer into the input of either\n * the specified `failure` or `success` layers, resulting in a new layer with\n * the inputs of this layer, and the error or outputs of the specified layer.\n *\n * @since 1.0.0\n * @category folding\n */\nexport const matchLayer = internal.matchLayer;\n/**\n * Feeds the error or output services of this layer into the input of either\n * the specified `failure` or `success` layers, resulting in a new layer with\n * the inputs of this layer, and the error or outputs of the specified layer.\n *\n * @since 1.0.0\n * @category folding\n */\nexport const matchCauseLayer = internal.matchCauseLayer;\n/**\n * Returns a scoped effect that, if evaluated, will return the lazily computed\n * result of this layer.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const memoize = internal.memoize;\n/**\n * Combines this layer with the specified layer, producing a new layer that\n * has the inputs and outputs of both.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const merge = internal.merge;\n/**\n * Merges all the layers together in parallel.\n *\n * @since 1.0.0\n * @category zipping\n */\nexport const mergeAll = internal.mergeAll;\n/**\n * Translates effect failure into death of the fiber, making all failures\n * unchecked and not a part of the type of the layer.\n *\n * @since 1.0.0\n * @category error handling\n */\nexport const orDie = internal.orDie;\n/**\n * Executes this layer and returns its output, if it succeeds, but otherwise\n * executes the specified layer.\n *\n * @since 1.0.0\n * @category error handling\n */\nexport const orElse = internal.orElse;\n/**\n * Returns a new layer that produces the outputs of this layer but also\n * passes through the inputs.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const passthrough = internal.passthrough;\n/**\n * Projects out part of one of the services output by this layer using the\n * specified function.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const project = internal.project;\n/**\n * Feeds the output services of this builder into the input of the specified\n * builder, resulting in a new builder with the inputs of this builder as\n * well as any leftover inputs, and the outputs of the specified builder.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const provide = internal.provide;\n/**\n * Feeds the output services of this layer into the input of the specified\n * layer, resulting in a new layer with the inputs of this layer, and the\n * outputs of both layers.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const provideMerge = internal.provideMerge;\n/**\n * Retries constructing this layer according to the specified schedule.\n *\n * @since 1.0.0\n * @category retrying\n */\nexport const retry = internal.retry;\n/**\n * A layer that constructs a scope and closes it when the workflow the layer\n * is provided to completes execution, whether by success, failure, or\n * interruption. This can be used to close a scope when providing a layer to a\n * workflow.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const scope = internal.scope;\n/**\n * Constructs a layer from the specified scoped effect.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const scoped = internal.scoped;\n/**\n * Constructs a layer from the specified scoped effect.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const scopedDiscard = internal.scopedDiscard;\n/**\n * Constructs a layer from the specified scoped effect, which must return one\n * or more services.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const scopedContext = internal.scopedContext;\n/**\n * Constructs a layer that accesses and returns the specified service from the\n * context.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const service = internal.service;\n/**\n * Constructs a layer from the specified value.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const succeed = internal.succeed;\n/**\n * Constructs a layer from the specified value, which must return one or more\n * services.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const succeedContext = internal.succeedContext;\n/**\n * Lazily constructs a layer. This is useful to avoid infinite recursion when\n * creating layers that refer to themselves.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const suspend = internal.suspend;\n/**\n * Lazily constructs a layer from the specified value.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const sync = internal.sync;\n/**\n * Lazily constructs a layer from the specified value, which must return one or more\n * services.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const syncContext = internal.syncContext;\n/**\n * Performs the specified effect if this layer succeeds.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexport const tap = internal.tap;\n/**\n * Performs the specified effect if this layer fails.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexport const tapError = internal.tapError;\n/**\n * Performs the specified effect if this layer fails.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexport const tapErrorCause = internal.tapErrorCause;\n/**\n * Converts a layer that requires no services into a scoped runtime, which can\n * be used to execute effects.\n *\n * @since 1.0.0\n * @category conversions\n */\nexport const toRuntime = internal.toRuntime;\n/**\n * Feeds the output services of this builder into the input of the specified\n * builder, resulting in a new builder with the inputs of this builder as\n * well as any leftover inputs, and the outputs of the specified builder.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const use = internal.use;\n/**\n * Feeds the output services of this layer into the input of the specified\n * layer, resulting in a new layer with the inputs of this layer, and the\n * outputs of both layers.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const useMerge = internal.useMerge;\n/**\n * Combines this layer the specified layer, producing a new layer that has the\n * inputs of both, and the outputs of both combined using the specified\n * function.\n *\n * @since 1.0.0\n * @category zipping\n */\nexport const zipWithPar = internal.zipWithPar;\n//# sourceMappingURL=Layer.mjs.map","import * as Debug from \"@effect/io/Debug\";\nimport * as core from \"@effect/io/internal_effect_untraced/core\";\nimport * as fiberRuntime from \"@effect/io/internal_effect_untraced/fiberRuntime\";\nimport * as layer from \"@effect/io/internal_effect_untraced/layer\";\nimport * as runtimeFlags from \"@effect/io/internal_effect_untraced/runtimeFlags\";\nimport * as runtimeFlagsPatch from \"@effect/io/internal_effect_untraced/runtimeFlagsPatch\";\nimport * as _supervisor from \"@effect/io/internal_effect_untraced/supervisor\";\nimport * as HashSet from \"@fp-ts/data/HashSet\";\n// circular with Logger\n/** @internal */\nexport const minimumLogLevel = /*#__PURE__*/Debug.untracedMethod(() => level => layer.scopedDiscard(fiberRuntime.fiberRefLocallyScoped(fiberRuntime.currentMinimumLogLevel, level)));\n/** @internal */\nexport const withMinimumLogLevel = /*#__PURE__*/Debug.dualWithTrace(2, trace => (self, level) => core.fiberRefLocally(fiberRuntime.currentMinimumLogLevel, level)(self).traced(trace));\n/** @internal */\nexport const addLogger = /*#__PURE__*/Debug.methodWithTrace(trace => logger => layer.scopedDiscard(fiberRuntime.fiberRefLocallyScopedWith(fiberRuntime.currentLoggers, HashSet.add(logger)).traced(trace)));\n/** @internal */\nexport const removeLogger = /*#__PURE__*/Debug.untracedMethod(() => logger => layer.scopedDiscard(fiberRuntime.fiberRefLocallyScopedWith(fiberRuntime.currentLoggers, HashSet.remove(logger))));\n/** @internal */\nexport const replaceLogger = /*#__PURE__*/Debug.dual(2, (logger, that) => layer.flatMap(removeLogger(logger), () => addLogger(that)));\n/** @internal */\nexport const addSupervisor = /*#__PURE__*/Debug.untracedMethod(() => supervisor => layer.scopedDiscard(fiberRuntime.fiberRefLocallyScopedWith(fiberRuntime.currentSupervisor, current => new _supervisor.Zip(current, supervisor))));\n/** @internal */\nexport const enableCooperativeYielding = /*#__PURE__*/Debug.untracedMethod(() => () => layer.scopedDiscard(fiberRuntime.withRuntimeFlagsScoped(runtimeFlagsPatch.enable(runtimeFlags.CooperativeYielding))));\n/** @internal */\nexport const enableInterruption = /*#__PURE__*/Debug.untracedMethod(() => () => layer.scopedDiscard(fiberRuntime.withRuntimeFlagsScoped(runtimeFlagsPatch.enable(runtimeFlags.Interruption))));\n/** @internal */\nexport const enableOpSupervision = /*#__PURE__*/Debug.untracedMethod(() => () => layer.scopedDiscard(fiberRuntime.withRuntimeFlagsScoped(runtimeFlagsPatch.enable(runtimeFlags.OpSupervision))));\n/** @internal */\nexport const enableRuntimeMetrics = /*#__PURE__*/Debug.untracedMethod(() => () => layer.scopedDiscard(fiberRuntime.withRuntimeFlagsScoped(runtimeFlagsPatch.enable(runtimeFlags.RuntimeMetrics))));\n/** @internal */\nexport const enableWindDown = /*#__PURE__*/Debug.untracedMethod(() => () => layer.scopedDiscard(fiberRuntime.withRuntimeFlagsScoped(runtimeFlagsPatch.enable(runtimeFlags.WindDown))));\n/** @internal */\nexport const disableCooperativeYielding = /*#__PURE__*/Debug.untracedMethod(() => () => layer.scopedDiscard(fiberRuntime.withRuntimeFlagsScoped(runtimeFlagsPatch.disable(runtimeFlags.CooperativeYielding))));\n/** @internal */\nexport const disableInterruption = /*#__PURE__*/Debug.untracedMethod(() => () => layer.scopedDiscard(fiberRuntime.withRuntimeFlagsScoped(runtimeFlagsPatch.disable(runtimeFlags.Interruption))));\n/** @internal */\nexport const disableOpSupervision = /*#__PURE__*/Debug.untracedMethod(() => () => layer.scopedDiscard(fiberRuntime.withRuntimeFlagsScoped(runtimeFlagsPatch.disable(runtimeFlags.OpSupervision))));\n/** @internal */\nexport const disableRuntimeMetrics = /*#__PURE__*/Debug.untracedMethod(() => () => layer.scopedDiscard(fiberRuntime.withRuntimeFlagsScoped(runtimeFlagsPatch.disable(runtimeFlags.RuntimeMetrics))));\n/** @internal */\nexport const disableWindDown = /*#__PURE__*/Debug.untracedMethod(() => () => layer.scopedDiscard(fiberRuntime.withRuntimeFlagsScoped(runtimeFlagsPatch.disable(runtimeFlags.WindDown))));\n/** @internal */\nexport const setConfigProvider = /*#__PURE__*/Debug.untracedMethod(() => configProvider => layer.scopedDiscard(fiberRuntime.withConfigProviderScoped(configProvider)));\n//# sourceMappingURL=circular.mjs.map","import * as core from \"@effect/io/internal_effect_untraced/core\";\nimport * as defaultServices from \"@effect/io/internal_effect_untraced/defaultServices\";\nimport * as effect from \"@effect/io/internal_effect_untraced/effect\";\nimport * as circular from \"@effect/io/internal_effect_untraced/effect/circular\";\nimport * as fiberRuntime from \"@effect/io/internal_effect_untraced/fiberRuntime\";\nimport * as layer from \"@effect/io/internal_effect_untraced/layer\";\nimport * as circularLayer from \"@effect/io/internal_effect_untraced/layer/circular\";\nimport * as _runtime from \"@effect/io/internal_effect_untraced/runtime\";\nimport * as _schedule from \"@effect/io/internal_effect_untraced/schedule\";\n/**\n * @since 1.0.0\n * @category symbols\n */\nexport const EffectTypeId = core.EffectTypeId;\n/**\n * This function returns `true` if the specified value is an `Effect` value,\n * `false` otherwise.\n *\n * This function can be useful for checking the type of a value before\n * attempting to operate on it as an `Effect` value. For example, you could\n * use `isEffect` to check the type of a value before using it as an\n * argument to a function that expects an `Effect` value.\n *\n * @param u - The value to check for being an `Effect` value.\n *\n * @returns `true` if the specified value is an `Effect` value, `false`\n * otherwise.\n *\n * @since 1.0.0\n * @category refinements\n */\nexport const isEffect = core.isEffect;\n/**\n * This function adds a finalizer to the scope of the calling `Effect` value.\n * The finalizer is guaranteed to be run when the scope is closed, and it may\n * depend on the `Exit` value that the scope is closed with.\n *\n * @param finalizer - The finalizer to add to the scope of the calling\n * `Effect` value. This function must take an `Exit` value as its parameter,\n * and return a new `Effect` value.\n *\n * @returns A new `Effect` value that represents the addition of the finalizer\n * to the scope of the calling `Effect` value.\n *\n * @since 1.0.0\n * @category finalization\n */\nexport const addFinalizer = fiberRuntime.addFinalizer;\n/**\n * This function submerges the error case of an `Either` value into an\n * `Effect` value. It is the inverse operation of `either`.\n *\n * If the `Either` value is a `Right` value, then the `Effect` value will\n * succeed with the value contained in the `Right`. If the `Either` value\n * is a `Left` value, then the `Effect` value will fail with the error\n * contained in the `Left`.\n *\n * @param self - The `Effect` value that contains an `Either` value as its\n * result.\n *\n * @returns A new `Effect` value that has the same context as the original\n * `Effect` value, but has the error case of the `Either` value submerged\n * into it.\n *\n * @since 1.0.0\n * @category error handling\n */\nexport const absolve = effect.absolve;\n/**\n * This function transforms an `Effect` value that may fail with a defect\n * into a new `Effect` value that may fail with an unknown error.\n *\n * The resulting `Effect` value will have the same context and success\n * type as the original `Effect` value, but it will have a more general\n * error type that allows it to fail with any type of error.\n *\n * @param self - The `Effect` value to transform.\n *\n * @returns A new `Effect` value that has the same context and success\n * type as the original `Effect` value, but a more general error type that\n * allows it to fail with any type of error.\n *\n * @since 1.0.0\n * @category error handling\n */\nexport const absorb = effect.absorb;\n/**\n * This function takes a mapping function `f` and returns a new function\n * that transforms an `Effect` value that may fail with a defect into a new\n * `Effect` value that may fail with an unknown error.\n *\n * If the original `Effect` value fails with a known error, then the\n * mapping function `f` will be applied to the error to convert it to an\n * unknown structure.\n *\n * The resulting `Effect` value will have the same context and success\n * type as the original `Effect` value, but it will have a more general\n * error type that allows it to fail with any type of error.\n *\n * @param f - The mapping function to apply to known errors. This function\n * must take an error of type `E` and return an unknown structure.\n *\n * @returns A new function that transforms an `Effect` value that may fail\n * with a defect into a new `Effect` value that may fail with an unknown\n * error.\n *\n * @since 1.0.0\n * @category error handling\n */\nexport const absorbWith = effect.absorbWith;\n/**\n * This function constructs a scoped resource from an `acquire` and `release`\n * `Effect` value.\n *\n * If the `acquire` `Effect` value successfully completes execution, then the\n * `release` `Effect` value will be added to the finalizers associated with the\n * scope of this `Effect` value, and it is guaranteed to be run when the scope\n * is closed.\n *\n * The `acquire` and `release` `Effect` values will be run uninterruptibly.\n * Additionally, the `release` `Effect` value may depend on the `Exit` value\n * specified when the scope is closed.\n *\n * @param acquire - The `Effect` value that acquires the resource.\n * @param release - The `Effect` value that releases the resource.\n *\n * @returns A new `Effect` value that represents the scoped resource.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const acquireRelease = fiberRuntime.acquireRelease;\n/**\n * This function is a variant of `acquireRelease` that allows the `acquire`\n * `Effect` value to be interruptible.\n *\n * Since the `acquire` `Effect` value could be interrupted after partially\n * acquiring resources, the `release` `Effect` value is not allowed to access\n * the resource produced by `acquire` and must independently determine what\n * finalization, if any, needs to be performed (e.g. by examining in memory\n * state).\n *\n * Additionally, the `release` `Effect` value may depend on the `Exit` value\n * specified when the scope is closed.\n *\n * @param acquire - The interruptible `Effect` value that acquires the\n * resource.\n * @param release - The `Effect` value that releases the resource. This function\n * must take an `Exit` value as its parameter, and return a new `Effect` value.\n *\n * @returns A new `Effect` value that represents the interruptible scoped\n * resource.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const acquireReleaseInterruptible = circular.acquireReleaseInterruptible;\n/**\n * This function is used to ensure that an `Effect` value that represents the\n * acquisition of a resource (for example, opening a file, launching a thread,\n * etc.) will not be interrupted, and that the resource will always be released\n * when the `Effect` value completes execution.\n *\n * `acquireUseRelease` does the following:\n *\n *   1. Ensures that the `Effect` value that acquires the resource will not be\n *      interrupted. Note that acquisition may still fail due to internal\n *      reasons (such as an uncaught exception).\n *   2. Ensures that the `release` `Effect` value will not be interrupted,\n *      and will be executed as long as the acquisition `Effect` value\n *      successfully acquires the resource.\n *\n * During the time period between the acquisition and release of the resource,\n * the `use` `Effect` value will be executed.\n *\n * If the `release` `Effect` value fails, then the entire `Effect` value will\n * fail, even if the `use` `Effect` value succeeds. If this fail-fast behavior\n * is not desired, errors produced by the `release` `Effect` value can be caught\n * and ignored.\n *\n * @param acquire - The `Effect` value that acquires the resource.\n * @param use - The `Effect` value that is executed between the acquisition\n * and release of the resource.\n * @param release - The `Effect` value that releases the resource.\n *\n * @returns A new `Effect` value that represents the acquisition, use, and\n * release of the resource.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const acquireUseRelease = core.acquireUseRelease;\n/**\n * This function checks if any fibers are attempting to interrupt the current\n * fiber, and if so, performs self-interruption.\n *\n * Note that this allows for interruption to occur in uninterruptible regions.\n *\n * @returns A new `Effect` value that represents the check for interruption\n * and the potential self-interruption of the current fiber.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const allowInterrupt = effect.allowInterrupt;\n/**\n * This function maps the success value of an `Effect` value to a specified\n * constant value.\n *\n * @param value - The constant value that the success value of the `Effect`\n * value will be mapped to.\n * @param self - The `Effect` value whose success value will be mapped to the\n * specified constant value.\n *\n * @returns A new `Effect` value that represents the mapping of the success\n * value of the original `Effect` value to the specified constant value.\n *\n * @since 1.0.0\n * @category mapping\n */\nexport const as = core.as;\n/**\n * This function maps the success value of an `Effect` value to a `Left` value\n * in an `Either` value.\n *\n * @param self - The `Effect` value whose success value will be mapped to a\n * `Left` value in an `Either` value.\n *\n * @returns A new `Effect` value that represents the mapping of the success\n * value of the original `Effect` value to a `Left` value in an `Either`\n * value.\n *\n * @since 1.0.0\n * @category mapping\n */\nexport const asLeft = effect.asLeft;\n/**\n * This function maps the error value of an `Effect` value to a `Left` value\n * in an `Either` value.\n *\n * @param self - The `Effect` value whose error value will be mapped to a\n * `Left` value in an `Either` value.\n *\n * @returns A new `Effect` value that represents the mapping of the error\n * value of the original `Effect` value to a `Left` value in an `Either`\n * value.\n *\n * @since 1.0.0\n * @category mapping\n */\nexport const asLeftError = effect.asLeftError;\n/**\n * This function maps the success value of an `Effect` value to a `Right` value\n * in an `Either` value.\n *\n * @param self - The `Effect` value whose success value will be mapped to a\n * `Right` value in an `Either` value.\n *\n * @returns A new `Effect` value that represents the mapping of the success\n * value of the original `Effect` value to a `Right` value in an `Either`\n * value.\n *\n * @since 1.0.0\n * @category mapping\n */\nexport const asRight = effect.asRight;\n/**\n * This function maps the error value of an `Effect` value to a `Right` value\n * in an `Either` value.\n *\n * @param self - The `Effect` value whose error value will be mapped to a\n * `Right` value in an `Either` value.\n *\n * @returns A new `Effect` value that represents the mapping of the error\n * value of the original `Effect` value to a `Right` value in an `Either`\n * value.\n *\n * @since 1.0.0\n * @category mapping\n */\nexport const asRightError = effect.asRightError;\n/**\n * This function maps the success value of an `Effect` value to a `Some` value\n * in an `Option` value. If the original `Effect` value fails, the returned\n * `Effect` value will also fail.\n *\n * @param self - The `Effect` value whose success value will be mapped to a\n * `Some` value in an `Option` value.\n *\n * @returns A new `Effect` value that represents the mapping of the success\n * value of the original `Effect` value to a `Some` value in an `Option`\n * value. The returned `Effect` value may fail if the original `Effect` value\n * fails.\n *\n * @category mapping\n * @since 1.0.0\n */\nexport const asSome = effect.asSome;\n/**\n * This function maps the error value of an `Effect` value to a `Some` value\n * in an `Option` value. If the original `Effect` value succeeds, the returned\n * `Effect` value will also succeed.\n *\n * @param self - The `Effect` value whose error value will be mapped to a\n * `Some` value in an `Option` value.\n *\n * @returns A new `Effect` value that represents the mapping of the error\n * value of the original `Effect` value to a `Some` value in an `Option`\n * value. The returned `Effect` value may succeed if the original `Effect`\n * value succeeds.\n *\n * @category mapping\n * @since 1.0.0\n */\nexport const asSomeError = effect.asSomeError;\n/**\n * This function maps the success value of an `Effect` value to `void`. If the\n * original `Effect` value succeeds, the returned `Effect` value will also\n * succeed. If the original `Effect` value fails, the returned `Effect` value\n * will fail with the same error.\n *\n * @param self - The `Effect` value whose success value will be mapped to `void`.\n *\n * @returns A new `Effect` value that represents the mapping of the success\n * value of the original `Effect` value to `void`.\n *\n * @since 1.0.0\n * @category mapping\n */\nexport const asUnit = core.asUnit;\n/**\n * Imports an asynchronous side-effect into a pure `Effect` value. See\n * `asyncMaybe` for the more expressive variant of this function that can\n * return a value synchronously.\n *\n * The callback function `Effect<R, E, A> => void` must be called at most once.\n *\n * The `FiberId` of the fiber that may complete the async callback may be\n * provided to allow for better diagnostics.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const async = core.async;\n/**\n * Converts an asynchronous, callback-style API into an `Effect`, which will\n * be executed asynchronously.\n *\n * With this variant, the registration function may return a an `Effect`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const asyncEffect = _runtime.asyncEffect;\n/**\n * Imports an asynchronous effect into a pure `Effect` value, possibly returning\n * the value synchronously.\n *\n * If the register function returns a value synchronously, then the callback\n * function `Effect<R, E, A> => void` must not be called. Otherwise the callback\n * function must be called at most once.\n *\n * The `FiberId` of the fiber that may complete the async callback may be\n * provided to allow for better diagnostics.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const asyncOption = effect.asyncOption;\n/**\n * Imports an asynchronous side-effect into an effect. It has the option of\n * returning the value synchronously, which is useful in cases where it cannot\n * be determined if the effect is synchronous or asynchronous until the register\n * is actually executed. It also has the option of returning a canceler,\n * which will be used by the runtime to cancel the asynchronous effect if the fiber\n * executing the effect is interrupted.\n *\n * If the register function returns a value synchronously, then the callback\n * function `Effect<R, E, A> => void` must not be called. Otherwise the callback\n * function must be called at most once.\n *\n * The `FiberId` of the fiber that may complete the async callback may be\n * provided to allow for better diagnostics.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const asyncInterruptEither = core.asyncInterruptEither;\n/**\n * Imports an asynchronous side-effect into an effect allowing control of interruption.\n *\n * The `FiberId` of the fiber that may complete the async callback may be\n * provided to allow for better diagnostics.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const asyncInterrupt = core.asyncInterrupt;\n/**\n * Imports a synchronous side-effect into a pure `Effect` value, translating any\n * thrown exceptions into typed failed effects creating with `Effect.fail`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const attempt = effect.attempt;\n/**\n * Returns a new effect that will not succeed with its value before first\n * waiting for the end of all child fibers forked by the effect.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const awaitAllChildren = circular.awaitAllChildren;\n/**\n * Returns an effect that, if evaluated, will return the cached result of this\n * effect. Cached results will expire after `timeToLive` duration.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const cached = circular.cached;\n/**\n * Returns an effect that, if evaluated, will return the cached result of this\n * effect. Cached results will expire after `timeToLive` duration. In\n * addition, returns an effect that can be used to invalidate the current\n * cached value before the `timeToLive` duration expires.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const cachedInvalidate = circular.cachedInvalidate;\nconst _catch = effect._catch;\nexport {\n/**\n * Recovers from specified error.\n *\n * @since 1.0.0\n * @category error handling\n */\n_catch as catch };\n/**\n * Recovers from all recoverable errors.\n *\n * **Note**: that `Effect.catchAll` will not recover from unrecoverable defects. To\n * recover from both recoverable and unrecoverable errors use\n * `Effect.catchAllCause`.\n *\n * @since 1.0.0\n * @category error handling\n */\nexport const catchAll = core.catchAll;\n/**\n * Recovers from both recoverable and unrecoverable errors.\n *\n * See `absorb`, `sandbox`, `mapErrorCause` for other functions that can\n * recover from defects.\n *\n * @since 1.0.0\n * @category error handling\n */\nexport const catchAllCause = core.catchAllCause;\n/**\n * Recovers from all defects with provided function.\n *\n * **WARNING**: There is no sensible way to recover from defects. This\n * method should be used only at the boundary between Effect and an external\n * system, to transmit information on a defect for diagnostic or explanatory\n * purposes.\n *\n * @since 1.0.0\n * @category error handling\n */\nexport const catchAllDefect = effect.catchAllDefect;\n/**\n * Recovers from some or all of the error cases.\n *\n * @since 1.0.0\n * @category error handling\n */\nexport const catchSome = core.catchSome;\n/**\n * Recovers from some or all of the error cases with provided cause.\n *\n * @since 1.0.0\n * @category error handling\n */\nexport const catchSomeCause = effect.catchSomeCause;\n/**\n * Recovers from some or all of the defects with provided partial function.\n *\n * **WARNING**: There is no sensible way to recover from defects. This\n * method should be used only at the boundary between Effect and an external\n * system, to transmit information on a defect for diagnostic or explanatory\n * purposes.\n *\n * @since 1.0.0\n * @category error handling\n */\nexport const catchSomeDefect = effect.catchSomeDefect;\n/**\n * Recovers from specified tagged error.\n *\n * @since 1.0.0\n * @category error handling\n */\nexport const catchTag = effect.catchTag;\n/**\n * Returns an effect that succeeds with the cause of failure of this effect,\n * or `Cause.empty` if the effect did succeed.\n *\n * @since 1.0.0\n * @category error handling\n */\nexport const cause = effect.cause;\n/**\n * Checks the interrupt status, and produces the effect returned by the\n * specified callback.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const checkInterruptible = core.checkInterruptible;\n/**\n * Retreives the `Clock` service from the context\n *\n * @since 1.0.0\n * @category context\n */\nexport const clock = effect.clock;\n/**\n * Retreives the `Clock` service from the context and provides it to the\n * specified effectful function.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const clockWith = effect.clockWith;\n/**\n * Uses the default config provider to load the specified config, or fail with\n * an error of type Config.Error.\n *\n * @since 1.0.0\n * @category config\n */\nexport const config = defaultServices.config;\n/**\n * Retrieves the default config provider, and passes it to the specified\n * function, which may return an effect that uses the provider to perform some\n * work or compute some value.\n *\n * @since 1.0.0\n * @category config\n */\nexport const configProviderWith = defaultServices.configProviderWith;\n/**\n * Evaluate each effect in the structure from left to right, collecting the\n * the successful values and discarding the empty cases. For a parallel version, see `collectPar`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const collect = fiberRuntime.collect;\n/**\n * Evaluate each effect in the structure from left to right, and collect the\n * results. For a parallel version, see `collectAllPar`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const collectAll = effect.collectAll;\n/**\n * Evaluate each effect in the structure from left to right, and discard the\n * results. For a parallel version, see `collectAllParDiscard`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const collectAllDiscard = effect.collectAllDiscard;\n/**\n * Evaluate each effect in the structure in parallel, and collect the results.\n * For a sequential version, see `collectAll`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const collectAllPar = fiberRuntime.collectAllPar;\n/**\n * Evaluate each effect in the structure in parallel, and discard the results.\n * For a sequential version, see `collectAllDiscard`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const collectAllParDiscard = fiberRuntime.collectAllParDiscard;\n/**\n * Evaluate each effect in the structure with `collectAll`, and collect the\n * results with given partial function.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const collectAllWith = effect.collectAllWith;\n/**\n * Evaluate each effect in the structure with `collectAllPar`, and collect\n * the results with given partial function.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const collectAllWithPar = fiberRuntime.collectAllWithPar;\n/**\n * Returns a filtered, mapped subset of the elements of the iterable based on a\n * partial function.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const collectAllWithEffect = effect.collectAllWithEffect;\n/**\n * Evaluate and run each effect in the structure and collect the results,\n * discarding results from failed effects.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const collectAllSuccesses = effect.collectAllSuccesses;\n/**\n * Evaluate and run each effect in the structure in parallel and collect the\n * results, discarding results from failed effects.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const collectAllSuccessesPar = fiberRuntime.collectAllSuccessesPar;\n/**\n * Collects the first element of the `Collection<A?` for which the effectual\n * function `f` returns `Some`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const collectFirst = effect.collectFirst;\n/**\n * Evaluate each effect in the structure in parallel, collecting the successful\n * values and discarding the empty cases.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const collectPar = fiberRuntime.collectPar;\n/**\n * Transforms all elements of the chunk for as long as the specified partial\n * function is defined.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const collectWhile = effect.collectWhile;\n/**\n * Evaluate the predicate, return the given `A` as success if predicate returns\n * true, and the given `E` as error otherwise\n *\n * For effectful conditionals, see `ifEffect`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const cond = effect.cond;\n/**\n * @since 1.0.0\n * @category context\n */\nexport const context = core.context;\n/**\n * Accesses the context of the effect.\n *\n * @since 1.0.0\n * @category context\n */\nexport const contextWith = effect.contextWith;\n/**\n * Effectually accesses the context of the effect.\n *\n * @since 1.0.0\n * @category context\n */\nexport const contextWithEffect = core.contextWithEffect;\n/**\n * Fail with the specifed `error` if the supplied partial function does not\n * match, otherwise continue with the returned value.\n *\n * @since 1.0.0\n * @category error handling\n */\nexport const continueOrFail = effect.continueOrFail;\n/**\n * Fail with the specifed `error` if the supplied partial function does not\n * match, otherwise continue with the returned value.\n *\n * @since 1.0.0\n * @category error handling\n */\nexport const continueOrFailEffect = effect.continueOrFailEffect;\n/**\n * Returns a new workflow that will not supervise any fibers forked by this\n * workflow.\n *\n * @since 1.0.0\n * @category supervision\n */\nexport const daemonChildren = fiberRuntime.daemonChildren;\n/**\n * Returns an effect that is delayed from this effect by the specified\n * `Duration`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const delay = effect.delay;\n/**\n * Constructs an effect with information about the current `Fiber`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const descriptor = effect.descriptor;\n/**\n * Constructs an effect based on information about the current `Fiber`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const descriptorWith = effect.descriptorWith;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const die = core.die;\n/**\n * Returns an effect that dies with a `RuntimeException` having the specified\n * text message. This method can be used for terminating a fiber because a\n * defect has been detected in the code.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const dieMessage = effect.dieMessage;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const dieSync = core.dieSync;\n/**\n * Returns an effect whose interruption will be disconnected from the\n * fiber's own interruption, being performed in the background without\n * slowing down the fiber's interruption.\n *\n * This method is useful to create \"fast interrupting\" effects. For\n * example, if you call this on a bracketed effect, then even if the\n * effect is \"stuck\" in acquire or release, its interruption will return\n * immediately, while the acquire / release are performed in the\n * background.\n *\n * See timeout and race for other applications.\n *\n * @since 1.0.0\n * @category interruption\n */\nexport const disconnect = circular.disconnect;\n/**\n * Returns a new workflow that executes this one and captures the changes in\n * `FiberRef` values.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const diffFiberRefs = effect.diffFiberRefs;\n/**\n * Binds an effectful value in a `do` scope\n *\n * @since 1.0.0\n * @category do notation\n */\nexport const bind = effect.bind;\n/**\n * Like bind for values\n *\n * @since 1.0.0\n * @category do notation\n */\nexport const bindValue = effect.bindValue;\n/**\n * @since 1.0.0\n * @category do notation\n */\nexport const Do = effect.Do;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const done = core.done;\n/**\n * Drops all elements until the effectful predicate returns true.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const dropUntil = effect.dropUntil;\n/**\n * Drops all elements so long as the predicate returns true.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const dropWhile = effect.dropWhile;\n/**\n * Returns an effect whose failure and success have been lifted into an\n * `Either`. The resulting effect cannot fail, because the failure case has\n * been exposed as part of the `Either` success case.\n *\n * This method is useful for recovering from effects that may fail.\n *\n * The error parameter of the returned `Effect` is `never`, since it is\n * guaranteed the effect does not model failure.\n *\n * @since 1.0.0\n * @category conversions\n */\nexport const either = core.either;\n/**\n * Returns an effect that, if this effect _starts_ execution, then the\n * specified `finalizer` is guaranteed to be executed, whether this effect\n * succeeds, fails, or is interrupted.\n *\n * For use cases that need access to the effect's result, see `onExit`.\n *\n * Finalizers offer very powerful guarantees, but they are low-level, and\n * should generally not be used for releasing resources. For higher-level\n * logic built on `ensuring`, see the `acquireRelease` family of methods.\n *\n * @since 1.0.0\n * @category finalization\n */\nexport const ensuring = circular.ensuring;\n/**\n * Acts on the children of this fiber (collected into a single fiber),\n * guaranteeing the specified callback will be invoked, whether or not this\n * effect succeeds.\n *\n * @since 1.0.0\n * @category finalization\n */\nexport const ensuringChild = circular.ensuringChild;\n/**\n * Acts on the children of this fiber, guaranteeing the specified callback\n * will be invoked, whether or not this effect succeeds.\n *\n * @since 1.0.0\n * @category finalization\n */\nexport const ensuringChildren = circular.ensuringChildren;\n/**\n * Returns an effect that ignores errors and runs repeatedly until it\n * eventually succeeds.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const eventually = effect.eventually;\n/**\n * Determines whether any element of the `Iterable<A>` satisfies the effectual\n * predicate `f`, working sequentially.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const exists = effect.exists;\n/**\n * Determines whether any element of the `Iterable<A>` satisfies the effectual\n * predicate `f`, working in parallel. Interrupts all effects on any failure or\n * finding an element that satisfies the predicate.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const existsPar = fiberRuntime.existsPar;\n/**\n * @since 1.0.0\n * @category utilities\n */\nexport const exit = core.exit;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const fail = core.fail;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const failSync = core.failSync;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const failCause = core.failCause;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const failCauseSync = core.failCauseSync;\n/**\n * @since 1.0.0\n * @category utilities\n */\nexport const fiberId = core.fiberId;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const fiberIdWith = core.fiberIdWith;\n/**\n * Filters the collection using the specified effectful predicate.\n *\n * @since 1.0.0\n * @category filtering\n */\nexport const filter = effect.filter;\n/**\n * Filters the collection in parallel using the specified effectual predicate.\n * See `filter` for a sequential version of it.\n *\n * @since 1.0.0\n * @category filtering\n */\nexport const filterPar = fiberRuntime.filterPar;\n/**\n * Filters the collection using the specified effectual predicate, removing\n * all elements that satisfy the predicate.\n *\n * @since 1.0.0\n * @category filtering\n */\nexport const filterNot = effect.filterNot;\n/**\n * Filters the collection in parallel using the specified effectual predicate.\n * See `filterNot` for a sequential version.\n *\n * @since 1.0.0\n * @category filtering\n */\nexport const filterNotPar = fiberRuntime.filterNotPar;\n/**\n * Filter the specified effect with the provided function, dying with specified\n * defect if the predicate fails.\n *\n * @since 1.0.0\n * @category filtering\n */\nexport const filterOrDie = effect.filterOrDie;\n/**\n * Filter the specified effect with the provided function, dying with specified\n * message if the predicate fails.\n *\n * @since 1.0.0\n * @category filtering\n */\nexport const filterOrDieMessage = effect.filterOrDieMessage;\n/**\n * Filters the specified effect with the provided function returning the value\n * of the effect if it is successful, otherwise returns the value of `orElse`.\n *\n * @since 1.0.0\n * @category filtering\n */\nexport const filterOrElse = effect.filterOrElse;\n/**\n * Filters the specified effect with the provided function returning the value\n * of the effect if it is successful, otherwise returns the value of `orElse`.\n *\n * @since 1.0.0\n * @category filtering\n */\nexport const filterOrElseWith = effect.filterOrElseWith;\n/**\n * Filter the specified effect with the provided function, failing with specified\n * error if the predicate fails.\n *\n * @since 1.0.0\n * @category filtering\n */\nexport const filterOrFail = effect.filterOrFail;\n/**\n * Returns the first element that satisfies the effectful predicate.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const find = effect.find;\n/**\n * This function takes an iterable of `Effect` values and returns a new\n * `Effect` value that represents the first `Effect` value in the iterable\n * that succeeds. If all of the `Effect` values in the iterable fail, then\n * the resulting `Effect` value will fail as well.\n *\n * This function is sequential, meaning that the `Effect` values in the\n * iterable will be executed in sequence, and the first one that succeeds\n * will determine the outcome of the resulting `Effect` value.\n *\n * @param effects - The iterable of `Effect` values to evaluate.\n *\n * @returns A new `Effect` value that represents the first successful\n * `Effect` value in the iterable, or a failed `Effect` value if all of the\n * `Effect` values in the iterable fail.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const firstSuccessOf = effect.firstSuccessOf;\n/**\n * This function is a pipeable operator that maps over an `Effect` value,\n * flattening the result of the mapping function into a new `Effect` value.\n *\n * @param f - The mapping function to apply to the `Effect` value.\n * This function must return another `Effect` value.\n *\n * @returns A new `Effect` value that is the result of flattening the\n * mapped `Effect` value.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexport const flatMap = core.flatMap;\n/**\n * @since 1.0.0\n * @category sequencing\n */\nexport const flatten = core.flatten;\n/**\n * Unwraps the optional error, defaulting to the provided value.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexport const flattenErrorOption = effect.flattenErrorOption;\n/**\n * Returns an effect that swaps the error/success cases. This allows you to\n * use all methods on the error channel, possibly before flipping back.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const flip = core.flip;\n/**\n * Swaps the error/value parameters, applies the function `f` and flips the\n * parameters back\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const flipWith = effect.flipWith;\n/**\n * Determines whether all elements of the `Collection<A>` satisfies the effectual\n * predicate `f`.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const forAll = effect.forAll;\n/**\n * Returns a new effect that will pass the success value of this effect to the\n * provided callback. If this effect fails, then the failure will be ignored.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const forEachEffect = effect.forEachEffect;\n/**\n * Applies the function `f` if the argument is non-empty and returns the\n * results in a new `Option<B>`.\n *\n * @since 1.0.0\n * @category elements\n */\nexport const forEachOption = effect.forEachOption;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const forEach = core.forEach;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const forEachDiscard = core.forEachDiscard;\n/**\n * Applies the function `f` to each element of the `Collection<A>` and returns\n * the result in a new `Chunk<B>` using the specified execution strategy.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const forEachExec = fiberRuntime.forEachExec;\n/**\n * Same as `forEach`, except that the function `f` is supplied\n * a second argument that corresponds to the index (starting from 0)\n * of the current element being iterated over.\n *\n * @since 1.0.0\n * @category traversing\n */\nexport const forEachWithIndex = effect.forEachWithIndex;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const forEachPar = fiberRuntime.forEachPar;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const forEachParDiscard = fiberRuntime.forEachParDiscard;\n/**\n * Same as `forEachPar`, except that the function `f` is supplied\n * a second argument that corresponds to the index (starting from 0)\n * of the current element being iterated over.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const forEachParWithIndex = fiberRuntime.forEachParWithIndex;\n/**\n * Repeats this effect forever (until the first error).\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const forever = effect.forever;\n/**\n * Returns an effect that forks this effect into its own separate fiber,\n * returning the fiber immediately, without waiting for it to begin executing\n * the effect.\n *\n * You can use the `fork` method whenever you want to execute an effect in a\n * new fiber, concurrently and without \"blocking\" the fiber executing other\n * effects. Using fibers can be tricky, so instead of using this method\n * directly, consider other higher-level methods, such as `raceWith`,\n * `zipPar`, and so forth.\n *\n * The fiber returned by this method has methods to interrupt the fiber and to\n * wait for it to finish executing the effect. See `Fiber` for more\n * information.\n *\n * Whenever you use this method to launch a new fiber, the new fiber is\n * attached to the parent fiber's scope. This means when the parent fiber\n * terminates, the child fiber will be terminated as well, ensuring that no\n * fibers leak. This behavior is called \"auto supervision\", and if this\n * behavior is not desired, you may use the `forkDaemon` or `forkIn` methods.\n *\n * @since 1.0.0\n * @category supervision\n */\nexport const fork = fiberRuntime.fork;\n/**\n * Forks the effect into a new fiber attached to the global scope. Because the\n * new fiber is attached to the global scope, when the fiber executing the\n * returned effect terminates, the forked fiber will continue running.\n *\n * @since 1.0.0\n * @category supervision\n */\nexport const forkDaemon = fiberRuntime.forkDaemon;\n/**\n * Returns an effect that forks all of the specified values, and returns a\n * composite fiber that produces a list of their results, in order.\n *\n * @since 1.0.0\n * @category supervision\n */\nexport const forkAll = circular.forkAll;\n/**\n * Returns an effect that forks all of the specified values, and returns a\n * composite fiber that produces unit. This version is faster than `forkAll`\n * in cases where the results of the forked fibers are not needed.\n *\n * @since 1.0.0\n * @category supervision\n */\nexport const forkAllDiscard = fiberRuntime.forkAllDiscard;\n/**\n * Forks the effect in the specified scope. The fiber will be interrupted\n * when the scope is closed.\n *\n * @since 1.0.0\n * @category supervision\n */\nexport const forkIn = circular.forkIn;\n/**\n * Forks the fiber in a `Scope`, interrupting it when the scope is closed.\n *\n * @since 1.0.0\n * @category supervision\n */\nexport const forkScoped = circular.forkScoped;\n/**\n * Like fork but handles an error with the provided handler.\n *\n * @since 1.0.0\n * @category supervision\n */\nexport const forkWithErrorHandler = fiberRuntime.forkWithErrorHandler;\n/**\n * Lifts an `Either<E, A>` into an `Effect<never, E, A>`.\n *\n * @since 1.0.0\n * @category conversions\n */\nexport const fromEither = core.fromEither;\n/**\n * Lifts an `Either<Cause<E>, A>` into an `Effect<never, E, A>`.\n *\n * @since 1.0.0\n * @category conversions\n */\nexport const fromEitherCause = effect.fromEitherCause;\n/**\n * Creates an `Effect` value that represents the exit value of the specified\n * fiber.\n *\n * @since 1.0.0\n * @category conversions\n */\nexport const fromFiber = circular.fromFiber;\n/**\n * Creates an `Effect` value that represents the exit value of the specified\n * fiber.\n *\n * @since 1.0.0\n * @category conversions\n */\nexport const fromFiberEffect = circular.fromFiberEffect;\n/**\n * Lifts an `Option` into an `Effect` but preserves the error as an option in\n * the error channel, making it easier to compose in some scenarios.\n *\n * @since 1.0.0\n * @category conversions\n */\nexport const fromOption = core.fromOption;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const gen = effect.gen;\n/**\n * Returns a collection of all `FiberRef` values for the fiber running this\n * effect.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const getFiberRefs = effect.getFiberRefs;\n/**\n * Lifts an `Option` into an `Effect`, if the option is not defined it fails\n * with `NoSuchElementException`.\n *\n * @since 1.0.0\n * @category conversions\n */\nexport const getOrFail = effect.getOrFail;\n/**\n * Lifts an `Option` into a `IO`, if the option is not defined it fails with\n * `void`.\n *\n * @since 1.0.0\n * @category conversions\n */\nexport const getOrFailDiscard = effect.getOrFailDiscard;\n/**\n * Lifts an `Maybe` into an `Effect`. If the option is not defined, fail with\n * the specified `e` value.\n *\n * @since 1.0.0\n * @category conversions\n */\nexport const getOrFailWith = effect.getOrFailWith;\n/**\n * Returns a successful effect with the head of the collection if the collection\n * is non-empty, or fails with the error `None` if the collection is empty.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const head = effect.head;\n/**\n * Runs `onTrue` if the result of `self` is `true` and `onFalse` otherwise.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const ifEffect = core.ifEffect;\n/**\n * Returns a new effect that ignores the success or failure of this effect.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const ignore = effect.ignore;\n/**\n * Returns a new effect that ignores the success or failure of this effect,\n * but which also logs failures at the Debug level, just in case the failure\n * turns out to be important.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const ignoreLogged = effect.ignoreLogged;\n/**\n * Inherits values from all `FiberRef` instances into current fiber.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const inheritFiberRefs = effect.inheritFiberRefs;\n/**\n * @since 1.0.0\n * @category interruption\n */\nexport const interrupt = core.interrupt;\n/**\n * @since 1.0.0\n * @category interruption\n */\nexport const interruptWith = core.interruptWith;\n/**\n * @since 1.0.0\n * @category interruption\n */\nexport const interruptible = core.interruptible;\n/**\n * @since 1.0.0\n * @category interruption\n */\nexport const interruptibleMask = core.interruptibleMask;\n/**\n * @since 1.0.0\n * @category utilities\n */\nexport const intoDeferred = core.intoDeferred;\n/**\n * Returns `true` if this effect is a failure, `false` otherwise.\n *\n * @since 1.0.0\n * @category getter\n */\nexport const isFailure = effect.isFailure;\n/**\n * Returns `true` if this effect is a success, `false` otherwise.\n *\n * @since 1.0.0\n * @category getter\n */\nexport const isSuccess = effect.isSuccess;\n/**\n * Iterates with the specified effectual function. The moral equivalent of:\n *\n * ```ts\n * let s = initial\n *\n * while (cont(s)) {\n *   s = body(s)\n * }\n *\n * return s\n * ```\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const iterate = effect.iterate;\n/**\n * \"Zooms in\" on the value in the `Left` side of an `Either`, moving the\n * possibility that the value is a `Right` to the error channel.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const left = effect.left;\n/**\n * Performs the specified operation while \"zoomed in\" on the `Left` case of an\n * `Either`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const leftWith = effect.leftWith;\n/**\n * Logs the specified message at the current log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexport const log = effect.log;\n/**\n * Logs the specified message at the debug log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexport const logDebug = effect.logDebug;\n/**\n * Logs the specified cause at the debug log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexport const logDebugCause = effect.logDebugCause;\n/**\n * Logs the specified message and cause at the debug log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexport const logDebugCauseMessage = effect.logDebugCauseMessage;\n/**\n * Logs the specified message at the error log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexport const logError = effect.logError;\n/**\n * Logs the specified cause at the error log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexport const logErrorCause = effect.logErrorCause;\n/**\n * Logs the specified message and cause at the error log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexport const logErrorCauseMessage = effect.logErrorCauseMessage;\n/**\n * Logs the specified message at the fatal log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexport const logFatal = effect.logFatal;\n/**\n * Logs the specified cause at the fatal log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexport const logFatalCause = effect.logFatalCause;\n/**\n * Logs the specified message and cause at the fatal log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexport const logFatalCauseMessage = effect.logFatalCauseMessage;\n/**\n * Logs the specified message at the informational log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexport const logInfo = effect.logInfo;\n/**\n * Logs the specified cause at the informational log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexport const logInfoCause = effect.logInfoCause;\n/**\n * Logs the specified message and cause at the informational log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexport const logInfoCauseMessage = effect.logInfoCauseMessage;\n/**\n * Logs the specified message at the warning log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexport const logWarning = effect.logWarning;\n/**\n * Logs the specified cause at the warning log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexport const logWarningCause = effect.logWarningCause;\n/**\n * Logs the specified message and cause at the warning log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexport const logWarningCauseMessage = effect.logWarningCauseMessage;\n/**\n * Logs the specified message at the trace log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexport const logTrace = effect.logTrace;\n/**\n * Logs the specified cause at the trace log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexport const logTraceCause = effect.logTraceCause;\n/**\n * Logs the specified message and cause at the trace log level.\n *\n * @since 1.0.0\n * @category logging\n */\nexport const logTraceCauseMessage = effect.logTraceCauseMessage;\n/**\n * Adjusts the label for the current logging span.\n *\n * @since 1.0.0\n * @category logging\n */\nexport const logSpan = effect.logSpan;\n/**\n * Annotates each log in this effect with the specified log annotation.\n *\n * @since 1.0.0\n * @category logging\n */\nexport const logAnnotate = effect.logAnnotate;\n/**\n * Retrieves the log annotations associated with the current scope.\n *\n * @since 1.0.0\n * @category logging\n */\nexport const logAnnotations = effect.logAnnotations;\n/**\n * Loops with the specified effectual function, collecting the results into a\n * list. The moral equivalent of:\n *\n * ```ts\n * let s  = initial\n * let as = [] as readonly A[]\n *\n * while (cont(s)) {\n *   as = [body(s), ...as]\n *   s  = inc(s)\n * }\n *\n * A.reverse(as)\n * ```\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const loop = effect.loop;\n/**\n * Loops with the specified effectual function purely for its effects. The\n * moral equivalent of:\n *\n * ```ts\n * let s = initial\n *\n * while (cont(s)) {\n *   body(s)\n *   s = inc(s)\n * }\n * ```\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const loopDiscard = effect.loopDiscard;\n/**\n * @since 1.0.0\n * @category mapping\n */\nexport const map = core.map;\n/**\n * Statefully and effectfully maps over the elements of this chunk to produce\n * new elements.\n *\n * @since 1.0.0\n * @category mapping\n */\nexport const mapAccum = effect.mapAccum;\n/**\n * Returns an effect whose failure and success channels have been mapped by\n * the specified pair of functions, `f` and `g`.\n *\n * @since 1.0.0\n * @category mapping\n */\nexport const mapBoth = effect.mapBoth;\n/**\n * Returns an effect with its error channel mapped using the specified function.\n *\n * @since 1.0.0\n * @category mapping\n */\nexport const mapError = core.mapError;\n/**\n * Returns an effect with its full cause of failure mapped using the specified\n * function. This can be used to transform errors while preserving the\n * original structure of `Cause`.\n *\n * See `absorb`, `sandbox`, `catchAllCause` for other functions for dealing\n * with defects.\n *\n * @since 1.0.0\n * @category mapping\n */\nexport const mapErrorCause = effect.mapErrorCause;\n/**\n * Returns an effect whose success is mapped by the specified side effecting\n * `f` function, translating any thrown exceptions into typed failed effects.\n *\n * @since 1.0.0\n * @category mapping\n */\nexport const mapTryCatch = effect.mapTryCatch;\n/**\n * Folds over the failure value or the success value to yield an effect that\n * does not fail, but succeeds with the value returned by the left or right\n * function passed to `match`.\n *\n * @since 1.0.0\n * @category folding\n */\nexport const match = effect.match;\n/**\n * @since 1.0.0\n * @category error handling\n */\nexport const matchCause = core.matchCause;\n/**\n * @since 1.0.0\n * @category error handling\n */\nexport const matchCauseEffect = core.matchCauseEffect;\n/**\n * @since 1.0.0\n * @category error handling\n */\nexport const matchEffect = core.matchEffect;\n/**\n * Returns an effect that, if evaluated, will return the lazily computed\n * result of this effect.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const memoize = effect.memoize;\n/**\n * Returns a memoized version of the specified effectual function.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const memoizeFunction = circular.memoizeFunction;\n/**\n * Returns a new effect where the error channel has been merged into the\n * success channel to their common combined type.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const merge = effect.merge;\n/**\n * Merges an `Iterable<Effect<R, E, A>>` to a single effect, working\n * sequentially.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const mergeAll = effect.mergeAll;\n/**\n * Merges an `Iterable<Effect<R, E, A>>` to a single effect, working in\n * parallel.\n *\n * Due to the parallel nature of this combinator, `f` must be both:\n * - commutative: `f(a, b) == f(b, a)`\n * - associative: `f(a, f(b, c)) == f(f(a, b), c)`\n *\n * It's unsafe to execute side effects inside `f`, as `f` may be executed\n * more than once for some of `in` elements during effect execution.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const mergeAllPar = fiberRuntime.mergeAllPar;\n/**\n * Returns a new effect where boolean value of this effect is negated.\n *\n * @since 1.0.0\n * @category mapping\n */\nexport const negate = effect.negate;\n/**\n * Returns a effect that will never produce anything. The moral equivalent of\n * `while(true) {}`, only without the wasted CPU cycles.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const never = core.never;\n/**\n * Requires the option produced by this value to be `None`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const none = effect.none;\n/**\n * Lifts an `Option` into a `Effect`. If the option is empty it succeeds with\n * `void`. If the option is defined it fails with the content.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const noneOrFail = effect.noneOrFail;\n/**\n * Lifts an `Option` into a `Effect`. If the option is empty it succeeds with\n * `undefined`. If the option is defined it fails with an error computed by\n * the specified function.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const noneOrFailWith = effect.noneOrFailWith;\n/**\n * @since 1.0.0\n * @category mutations\n */\nexport const onDone = fiberRuntime.onDone;\n/**\n * @since 1.0.0\n * @category mutations\n */\nexport const onDoneCause = fiberRuntime.onDoneCause;\n/**\n * Runs the specified effect if this effect fails, providing the error to the\n * effect if it exists. The provided effect will not be interrupted.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const onError = core.onError;\n/**\n * Ensures that a cleanup functions runs, whether this effect succeeds, fails,\n * or is interrupted.\n *\n * @category finalization\n * @since 1.0.0\n */\nexport const onExit = core.onExit;\n/**\n * @since 1.0.0\n * @category finalization\n */\nexport const onInterrupt = core.onInterrupt;\n/**\n * Returns an effect that will be executed at most once, even if it is\n * evaluated multiple times.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const once = effect.once;\n/**\n * Executes this effect, skipping the error but returning optionally the\n * success.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const option = effect.option;\n/**\n * Translates effect failure into death of the fiber, making all failures\n * unchecked and not a part of the type of the effect.\n *\n * @since 1.0.0\n * @category alternatives\n */\nexport const orDie = core.orDie;\n/**\n * Keeps none of the errors, and terminates the fiber with them, using the\n * specified function to convert the `E` into a `Throwable`.\n *\n * @since 1.0.0\n * @category alternatives\n */\nexport const orDieWith = core.orDieWith;\n/**\n * Executes this effect and returns its value, if it succeeds, but otherwise\n * executes the specified effect.\n *\n * @since 1.0.0\n * @category alternatives\n */\nexport const orElse = core.orElse;\n/**\n * Returns an effect that will produce the value of this effect, unless it\n * fails, in which case, it will produce the value of the specified effect.\n *\n * @since 1.0.0\n * @category alternatives\n */\nexport const orElseEither = effect.orElseEither;\n/**\n * Executes this effect and returns its value, if it succeeds, but otherwise\n * fails with the specified error.\n *\n * @since 1.0.0\n * @category alternatives\n */\nexport const orElseFail = effect.orElseFail;\n/**\n * Returns an effect that will produce the value of this effect, unless it\n * fails with the `None` value, in which case it will produce the value of\n * the specified effect.\n *\n * @since 1.0.0\n * @category alternatives\n */\nexport const orElseOptional = effect.orElseOptional;\n/**\n * Executes this effect and returns its value, if it succeeds, but\n * otherwise succeeds with the specified value.\n *\n * @since 1.0.0\n * @category alternatives\n */\nexport const orElseSucceed = effect.orElseSucceed;\n/**\n * Exposes all parallel errors in a single call.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const parallelErrors = effect.parallelErrors;\n/**\n * @since 1.0.0\n * @category mutations\n */\nexport const parallelFinalizers = fiberRuntime.parallelFinalizers;\n/**\n * Feeds elements of type `A` to a function `f` that returns an effect.\n * Collects all successes and failures in a tupled fashion.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const partition = effect.partition;\n/**\n * Feeds elements of type `A` to a function `f` that returns an effect.\n * Collects all successes and failures in parallel and returns the result as a\n * tuple.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const partitionPar = fiberRuntime.partitionPar;\n/**\n * Applies the specified changes to the `FiberRef` values for the fiber\n * running this workflow.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const patchFiberRefs = effect.patchFiberRefs;\n/**\n * Like `tryPromise` but produces a defect in case of errors.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const promise = effect.promise;\n/**\n * Like `promise` but allows for interruption via AbortSignal\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const promiseInterrupt = effect.promiseInterrupt;\n/**\n * Provides the effect with its required context, which eliminates its\n * dependency on `R`.\n *\n * @since 1.0.0\n * @category context\n */\nexport const provideContext = core.provideContext;\n/**\n * Provides a layer to the effect, which translates it to another level.\n *\n * @since 1.0.0\n * @category context\n */\nexport const provideLayer = layer.provideLayer;\n/**\n * Provides the effect with the single service it requires. If the effect\n * requires more than one service use `provideContext` instead.\n *\n * @since 1.0.0\n * @category context\n */\nexport const provideService = effect.provideService;\n/**\n * Provides the effect with the single service it requires. If the effect\n * requires more than one service use `provideContext` instead.\n *\n * @since 1.0.0\n * @category context\n */\nexport const provideServiceEffect = effect.provideServiceEffect;\n/**\n * Provides some of the context required to run this effect,\n * leaving the remainder `R0`.\n *\n * @since 1.0.0\n * @category context\n */\nexport const contramapContext = core.contramapContext;\n/**\n * Splits the context into two parts, providing one part using the\n * specified layer and leaving the remainder `R0`.\n *\n * @since 1.0.0\n * @category context\n */\nexport const provideSomeLayer = layer.provideSomeLayer;\n/**\n * Returns an effect that races this effect with the specified effect,\n * returning the first successful `A` from the faster side. If one effect\n * succeeds, the other will be interrupted. If neither succeeds, then the\n * effect will fail with some error.\n *\n * Note that both effects are disconnected before being raced. This means that\n * interruption of the loser will always be performed in the background. If this\n * behavior is not desired, you can use `Effect.raceWith`, which will not\n * disconnect or interrupt losers.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const race = circular.race;\n/**\n * Returns an effect that races this effect with all the specified effects,\n * yielding the value of the first effect to succeed with a value. Losers of\n * the race will be interrupted immediately\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const raceAll = fiberRuntime.raceAll;\n/**\n * Returns an effect that races this effect with the specified effect,\n * returning the first successful `A` from the faster side. If one effect\n * succeeds, the other will be interrupted. If neither succeeds, then the\n * effect will fail with some error.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const raceAwait = circular.raceAwait;\n/**\n * Returns an effect that races this effect with the specified effect,\n * yielding the first result to succeed. If neither effect succeeds, then the\n * composed effect will fail with some error.\n *\n * WARNING: The raced effect will safely interrupt the \"loser\", but will not\n * resume until the loser has been cleanly terminated.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const raceEither = circular.raceEither;\n/**\n * Forks this effect and the specified effect into their own fibers, and races\n * them, calling one of two specified callbacks depending on which fiber wins\n * the race. This method does not interrupt, join, or otherwise do anything\n * with the fibers. It can be considered a low-level building block for\n * higher-level operators like `race`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const raceFibersWith = circular.raceFibersWith;\n/**\n * Returns an effect that races this effect with the specified effect,\n * yielding the first result to complete, whether by success or failure. If\n * neither effect completes, then the composed effect will not complete.\n *\n * WARNING: The raced effect will safely interrupt the \"loser\", but will not\n * resume until the loser has been cleanly terminated. If early return is\n * desired, then instead of performing `l raceFirst r`, perform\n * `l.disconnect raceFirst r.disconnect`, which disconnects left and right\n * interrupt signal, allowing a fast return, with interruption performed\n * in the background.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const raceFirst = circular.raceFirst;\n/**\n * Returns an effect that races this effect with the specified effect, calling\n * the specified finisher as soon as one result or the other has been computed.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const raceWith = circular.raceWith;\n/**\n * Retreives the `Random` service from the context.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const random = effect.random;\n/**\n * Retreives the `Random` service from the context and uses it to run the\n * specified workflow.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const randomWith = effect.randomWith;\n/**\n * Folds an `Iterable<A>` using an effectual function f, working sequentially\n * from left to right.\n *\n * @since 1.0.0\n * @category folding\n */\nexport const reduce = effect.reduce;\n/**\n * Reduces an `Iterable<Effect<R, E, A>>` to a single effect, working\n * sequentially.\n *\n * @since 1.0.0\n * @category folding\n */\nexport const reduceAll = effect.reduceAll;\n/**\n * Reduces an `Iterable<Effect<R, E, A>>` to a single effect, working in\n * parallel.\n *\n * @since 1.0.0\n * @category folding\n */\nexport const reduceAllPar = fiberRuntime.reduceAllPar;\n/**\n * Folds an `Iterable<A>` using an effectual function f, working sequentially from left to right.\n *\n * @since 1.0.0\n * @category folding\n */\nexport const reduceRight = effect.reduceRight;\n/**\n * Folds over the elements in this chunk from the left, stopping the fold early\n * when the predicate is not satisfied.\n *\n * @since 1.0.0\n * @category folding\n */\nexport const reduceWhile = effect.reduceWhile;\n/**\n * Keeps some of the errors, and terminates the fiber with the rest\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const refineOrDie = effect.refineOrDie;\n/**\n * Keeps some of the errors, and terminates the fiber with the rest, using\n * the specified function to convert the `E` into a defect.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const refineOrDieWith = effect.refineOrDieWith;\n/**\n * Fail with the returned value if the `PartialFunction` matches, otherwise\n * continue with our held value.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const reject = effect.reject;\n/**\n * Continue with the returned computation if the `PartialFunction` matches,\n * translating the successful match into a failure, otherwise continue with\n * our held value.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const rejectEffect = effect.rejectEffect;\n/**\n * Returns a new effect that repeats this effect according to the specified\n * schedule or until the first failure. Scheduled recurrences are in addition\n * to the first execution, so that `io.repeat(Schedule.once)` yields an effect\n * that executes `io`, and then if that succeeds, executes `io` an additional\n * time.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const repeat = _schedule.repeat_Effect;\n/**\n * Returns a new effect that repeats this effect the specified number of times\n * or until the first failure. Repeats are in addition to the first execution,\n * so that `io.repeatN(1)` yields an effect that executes `io`, and then if\n * that succeeds, executes `io` an additional time.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const repeatN = effect.repeatN;\n/**\n * Returns a new effect that repeats this effect according to the specified\n * schedule or until the first failure, at which point, the failure value and\n * schedule output are passed to the specified handler.\n *\n * Scheduled recurrences are in addition to the first execution, so that\n * `pipe(effect, Effect.repeat(Schedule.once()))` yields an effect that executes\n * `effect`, and then if that succeeds, executes `effect` an additional time.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const repeatOrElse = _schedule.repeatOrElse_Effect;\n/**\n * Returns a new effect that repeats this effect according to the specified\n * schedule or until the first failure, at which point, the failure value and\n * schedule output are passed to the specified handler.\n *\n * Scheduled recurrences are in addition to the first execution, so that\n * `pipe(effect, Effect.repeat(Schedule.once()))` yields an effect that executes\n * `effect`, and then if that succeeds, executes `effect` an additional time.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const repeatOrElseEither = _schedule.repeatOrElseEither_Effect;\n/**\n * Repeats this effect until its value satisfies the specified predicate or\n * until the first failure.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const repeatUntil = _schedule.repeatUntil_Effect;\n/**\n * Repeats this effect until its value satisfies the specified effectful\n * predicate or until the first failure.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const repeatUntilEffect = _schedule.repeatUntilEffect_Effect;\n/**\n * Repeats this effect until its value is equal to the specified value or\n * until the first failure.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const repeatUntilEquals = _schedule.repeatUntilEquals_Effect;\n/**\n * Repeats this effect while its value satisfies the specified effectful\n * predicate or until the first failure.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const repeatWhile = _schedule.repeatWhile_Effect;\n/**\n * Repeats this effect while its value satisfies the specified effectful\n * predicate or until the first failure.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const repeatWhileEffect = _schedule.repeatWhileEffect_Effect;\n/**\n * Repeats this effect for as long as its value is equal to the specified\n * value or until the first failure.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const repeatWhileEquals = _schedule.repeatWhileEquals_Effect;\n/**\n * Retries with the specified retry policy. Retries are done following the\n * failure of the original `io` (up to a fixed maximum with `once` or `recurs`\n * for example), so that that `io.retry(Schedule.once)` means \"execute `io`\n * and in case of failure, try again once\".\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const retry = _schedule.retry_Effect;\n/**\n * Retries this effect the specified number of times.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const retryN = _schedule.retryN_Effect;\n/**\n * Retries with the specified schedule, until it fails, and then both the\n * value produced by the schedule together with the last error are passed to\n * the recovery function.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const retryOrElse = _schedule.retryOrElse_Effect;\n/**\n * Retries with the specified schedule, until it fails, and then both the\n * value produced by the schedule together with the last error are passed to\n * the recovery function.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const retryOrElseEither = _schedule.retryOrElseEither_Effect;\n/**\n * Retries this effect until its error satisfies the specified predicate.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const retryUntil = _schedule.retryUntil_Effect;\n/**\n * Retries this effect until its error satisfies the specified effectful\n * predicate.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const retryUntilEffect = _schedule.retryUntilEffect_Effect;\n/**\n * Retries this effect until its error is equal to the specified error.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const retryUntilEquals = _schedule.retryUntilEquals_Effect;\n/**\n * Retries this effect while its error satisfies the specified predicate.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const retryWhile = _schedule.retryWhile_Effect;\n/**\n * Retries this effect while its error satisfies the specified effectful\n * predicate.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const retryWhileEffect = _schedule.retryWhileEffect_Effect;\n/**\n * Retries this effect for as long as its error is equal to the specified\n * error.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const retryWhileEquals = _schedule.retryWhileEquals_Effect;\n/**\n * Replicates the given effect `n` times.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const replicate = effect.replicate;\n/**\n * Performs this effect the specified number of times and collects the\n * results.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const replicateEffect = effect.replicateEffect;\n/**\n * Performs this effect the specified number of times, discarding the\n * results.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const replicateEffectDiscard = effect.replicateEffectDiscard;\n/**\n * Unearth the unchecked failure of the effect (opposite of `orDie`).\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const resurrect = effect.resurrect;\n/**\n * \"Zooms in\" on the value in the `Right` side of an `Either`, moving the\n * possibility that the value is a `Left` to the error channel.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const right = effect.right;\n/**\n * Performs the specified operation while \"zoomed in\" on the `Right` case of an\n * `Either`.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const rightWith = effect.rightWith;\n/**\n * Returns an effect that accesses the runtime, which can be used to\n * (unsafely) execute tasks. This is useful for integration with legacy code\n * that must call back into Effect code.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const runtime = _runtime.runtime;\n/**\n * Retrieves an effect that succeeds with the current runtime flags, which\n * govern behavior and features of the runtime system.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const runtimeFlags = core.runtimeFlags;\n/**\n * Exposes the full `Cause` of failure for the specified effect.\n *\n * @since 1.0.0\n * @category error handling\n */\nexport const sandbox = effect.sandbox;\n/**\n * Runs this effect according to the specified schedule.\n *\n * See `scheduleFrom` for a variant that allows the schedule's decision to\n * depend on the result of this effect.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const schedule = _schedule.schedule_Effect;\n/**\n * Runs this effect according to the specified schedule in a new fiber\n * attached to the current scope.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const scheduleForked = circular.scheduleForked;\n/**\n * Runs this effect according to the specified schedule starting from the\n * specified input value.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const scheduleFrom = _schedule.scheduleFrom_Effect;\n/**\n * @since 1.0.0\n * @category context\n */\nexport const scope = fiberRuntime.scope;\n/**\n * Accesses the current scope and uses it to perform the specified effect.\n *\n * @since 1.0.0\n * @category scoping\n */\nexport const scopeWith = fiberRuntime.scopeWith;\n/**\n * Scopes all resources uses in this workflow to the lifetime of the workflow,\n * ensuring that their finalizers are run as soon as this workflow completes\n * execution, whether by success, failure, or interruption.\n *\n * @since 1.0.0\n * @category context\n */\nexport const scoped = fiberRuntime.scopedEffect;\n/**\n * Returns a new scoped workflow that runs finalizers added to the scope of\n * this workflow sequentially in the reverse of the order in which they were\n * added. Note that finalizers are run sequentially by default so this only\n * has meaning if used within a scope where finalizers are being run in\n * parallel.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const sequentialFinalizers = fiberRuntime.sequentialFinalizers;\n/**\n * Extracts the specified service from the context of the effect.\n *\n * @since 1.0.0\n * @category context\n */\nexport const service = core.service;\n/**\n * Accesses the specified service in the context of the effect.\n *\n * @since 1.0.0\n * @category context\n */\nexport const serviceWith = core.serviceWith;\n/**\n * Effectfully accesses the specified service in the context of the effect.\n *\n * @since 1.0.0\n * @category context\n */\nexport const serviceWithEffect = core.serviceWithEffect;\n/**\n * Sets the current `ConfigProvider`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const setConfigProvider = circularLayer.setConfigProvider;\n/**\n * Sets the `FiberRef` values for the fiber running this effect to the values\n * in the specified collection of `FiberRef` values.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const setFiberRefs = effect.setFiberRefs;\n/**\n * Returns an effect that suspends for the specified duration. This method is\n * asynchronous, and does not actually block the fiber executing the effect.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const sleep = effect.sleep;\n/**\n * Converts an option on values into an option on errors.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const some = fiberRuntime.some;\n/**\n * Extracts the optional value, or returns the given 'orElse'.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const someOrElse = effect.someOrElse;\n/**\n * Extracts the optional value, or executes the given 'orElse' effect.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const someOrElseEffect = effect.someOrElseEffect;\n/**\n * Extracts the optional value, or fails with the given error 'e'.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const someOrFail = effect.someOrFail;\n/**\n * Extracts the optional value, or fails with a `NoSuchElementException`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const someOrFailException = effect.someOrFailException;\n/**\n * Perfoms the specified operation while \"zoomed in\" on the `Some` case of an\n * `Option`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const someWith = fiberRuntime.someWith;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const struct = effect.struct;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const structPar = fiberRuntime.structPar;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const succeed = core.succeed;\n/**\n * Returns an effect which succeeds with the value wrapped in a `Left`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const succeedLeft = effect.succeedLeft;\n/**\n * Returns an effect which succeeds with `None`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const succeedNone = effect.succeedNone;\n/**\n * Returns an effect which succeeds with the value wrapped in a `Right`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const succeedRight = effect.succeedRight;\n/**\n * Returns an effect which succeeds with the value wrapped in a `Some`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const succeedSome = effect.succeedSome;\n/**\n * Summarizes a effect by computing some value before and after execution, and\n * then combining the values to produce a summary, together with the result of\n * execution.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const summarized = effect.summarized;\n/**\n * Returns an effect with the behavior of this one, but where all child fibers\n * forked in the effect are reported to the specified supervisor.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const supervised = circular.supervised;\n/**\n * Returns a lazily constructed effect, whose construction may itself require\n * effects. When no context is required (i.e., when `R == unknown`) it is\n * conceptually equivalent to `flatten(succeed(io))`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const suspend = effect.suspend;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const suspendSucceed = core.suspendSucceed;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const sync = core.sync;\n/**\n * Takes all elements so long as the effectual predicate returns true.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const takeWhile = effect.takeWhile;\n/**\n * Tags each metric in this effect with the specific tag.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const tagged = effect.tagged;\n/**\n * Tags each metric in this effect with the specific tag.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const taggedWithLabels = effect.taggedWithLabels;\n/**\n * Tags each metric in this effect with the specific tag.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const taggedWithLabelSet = effect.taggedWithLabelSet;\n/**\n * Tags each metric in a scope with a the specific tag.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const taggedScoped = fiberRuntime.taggedScoped;\n/**\n * Tags each metric in a scope with a the specific tag.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const taggedScopedWithLabels = fiberRuntime.taggedScopedWithLabels;\n/**\n * Tags each metric in a scope with a the specific tag.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const taggedScopedWithLabelSet = fiberRuntime.taggedScopedWithLabelSet;\n/**\n * Retrieves the metric tags associated with the current scope.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const tags = core.tags;\n/**\n * @since 1.0.0\n * @category sequencing\n */\nexport const tap = core.tap;\n/**\n * Returns an effect that effectfully \"peeks\" at the failure or success of\n * this effect.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexport const tapBoth = effect.tapBoth;\n/**\n * Returns an effect that effectually \"peeks\" at the defect of this effect.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexport const tapDefect = effect.tapDefect;\n/**\n * Returns an effect that effectfully \"peeks\" at the result of this effect.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexport const tapEither = effect.tapEither;\n/**\n * Returns an effect that effectfully \"peeks\" at the failure of this effect.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexport const tapError = effect.tapError;\n/**\n * Returns an effect that effectually \"peeks\" at the cause of the failure of\n * this effect.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexport const tapErrorCause = effect.tapErrorCause;\n/**\n * Returns an effect that effectfully \"peeks\" at the success of this effect.\n * If the partial function isn't defined at the input, the result is\n * equivalent to the original effect.\n *\n * @since 1.0.0\n * @category sequencing\n */\nexport const tapSome = effect.tapSome;\n/**\n * Returns a new effect that executes this one and times the execution.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const timed = effect.timed;\n/**\n * A more powerful variation of `timed` that allows specifying the clock.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const timedWith = effect.timedWith;\n/**\n * Returns an effect that will timeout this effect, returning `None` if the\n * timeout elapses before the effect has produced a value; and returning\n * `Some` of the produced value otherwise.\n *\n * If the timeout elapses without producing a value, the running effect will\n * be safely interrupted.\n *\n * WARNING: The effect returned by this method will not itself return until\n * the underlying effect is actually interrupted. This leads to more\n * predictable resource utilization. If early return is desired, then instead\n * of using `effect.timeout(d)`, use `effect.disconnect.timeout(d)`, which\n * first disconnects the effect's interruption signal before performing the\n * timeout, resulting in earliest possible return, before an underlying effect\n * has been successfully interrupted.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const timeout = circular.timeout;\n/**\n * The same as `timeout`, but instead of producing a `None` in the event of\n * timeout, it will produce the specified error.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const timeoutFail = circular.timeoutFail;\n/**\n * The same as `timeout`, but instead of producing a `None` in the event of\n * timeout, it will produce the specified failure.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const timeoutFailCause = circular.timeoutFailCause;\n/**\n * Returns an effect that will timeout this effect, returning either the\n * default value if the timeout elapses before the effect has produced a\n * value or returning the result of applying the function `f` to the\n * success value of the effect.\n *\n * If the timeout elapses without producing a value, the running effect will\n * be safely interrupted.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const timeoutTo = circular.timeoutTo;\n/**\n * Constructs a layer from this effect.\n *\n * @since 1.0.0\n * @category conversions\n */\nexport const toLayer = layer.toLayer;\n/**\n * Constructs a layer from this effect.\n *\n * @since 1.0.0\n * @category conversions\n */\nexport const toLayerContext = layer.fromEffectContext;\n/**\n * Constructs a layer from this effect.\n *\n * @since 1.0.0\n * @category conversions\n */\nexport const toLayerDiscard = layer.fromEffectDiscard;\n/**\n * Constructs a layer from this effect.\n *\n * @since 1.0.0\n * @category conversions\n */\nexport const toLayerScopedDiscard = layer.scopedDiscard;\n/**\n * Constructs a layer from this effect.\n *\n * @since 1.0.0\n * @category conversions\n */\nexport const toLayerScoped = layer.toLayerScoped;\n/**\n * Transplants specified effects so that when those effects fork other\n * effects, the forked effects will be governed by the scope of the fiber that\n * executes this effect.\n *\n * This can be used to \"graft\" deep grandchildren onto a higher-level scope,\n * effectively extending their lifespans into the parent scope.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const transplant = core.transplant;\n/**\n * Imports a synchronous side-effect into a pure value, translating any\n * thrown exceptions into typed failed effects.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const tryCatch = effect.tryCatch;\n/**\n * Create an `Effect` that when executed will construct `promise` and wait for\n * its result, errors will be handled using `onReject`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const tryCatchPromise = effect.tryCatchPromise;\n/**\n * Like `tryCatchPromise` but allows for interruption via AbortSignal\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const tryCatchPromiseInterrupt = effect.tryCatchPromiseInterrupt;\n/**\n * Executed `that` in case `self` fails with a `Cause` that doesn't contain\n * defects, executes `success` in case of successes\n *\n * @since 1.0.0\n * @category alternatives\n */\nexport const tryOrElse = core.tryOrElse;\n/**\n * Create an `Effect` that when executed will construct `promise` and wait for\n * its result, errors will produce failure as `unknown`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const tryPromise = effect.tryPromise;\n/**\n * Like `tryPromise` but allows for interruption via AbortSignal\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const tryPromiseInterrupt = effect.tryPromiseInterrupt;\n/**\n * Like `forEach` + `identity` with a tuple type.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const tuple = effect.tuple;\n/**\n * Like tuple but parallel, same as `forEachPar` + `identity` with a tuple type.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const tuplePar = fiberRuntime.tuplePar;\n/**\n * Used to unify functions that would otherwise return `Effect<A, B, C> | Effect<D, E, F>`\n *\n * @category utilities\n * @since 1.0.0\n */\nexport const unified = core.unified;\n/**\n * When this effect succeeds with a cause, then this method returns a new\n * effect that either fails with the cause that this effect succeeded with, or\n * succeeds with unit, depending on whether the cause is empty.\n *\n * This operation is the opposite of `cause`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const uncause = effect.uncause;\n/**\n * Constructs a `Chunk` by repeatedly applying the effectual function `f` as\n * long as it returns `Some`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const unfold = effect.unfold;\n/**\n * @since 1.0.0\n * @category interruption\n */\nexport const uninterruptible = core.uninterruptible;\n/**\n * @since 1.0.0\n * @category interruption\n */\nexport const uninterruptibleMask = core.uninterruptibleMask;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const unit = core.unit;\n/**\n * Converts a `Effect<R, Either<E, B>, A>` into a `Effect<R, E, Either<A, B>>`.\n * The inverse of `left`.\n *\n * @since 1.0.0\n * @category getters\n */\nexport const unleft = effect.unleft;\n/**\n * The moral equivalent of `if (!p) exp`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const unless = effect.unless;\n/**\n * The moral equivalent of `if (!p) exp` when `p` has side-effects.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const unlessEffect = effect.unlessEffect;\n/**\n * Takes some fiber failures and converts them into errors.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const unrefine = effect.unrefine;\n/**\n * Takes some fiber failures and converts them into errors, using the specified\n * function to convert the `E` into an `E1 | E2`.\n *\n * @since 1.0.0\n * @category error handling\n */\nexport const unrefineWith = effect.unrefineWith;\n/**\n * Converts a `Effect<R, Either<B, E>, A>` into a `Effect<R, E, Either<B, A>>`.\n * The inverse of `right`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const unright = effect.unright;\n/**\n * Unsafely creates a new Semaphore\n *\n * @since 1.0.0\n * @category locking\n */\nexport const unsafeMakeSemaphore = circular.unsafeMakeSemaphore;\n/**\n * Creates a new Semaphore\n *\n * @since 1.0.0\n * @category locking\n */\nexport const makeSemaphore = circular.makeSemaphore;\n/**\n * @since 1.0.0\n * @category execution\n */\nexport const runFork = _runtime.unsafeForkEffect;\n/**\n * @since 1.0.0\n * @category execution\n */\nexport const runCallback = _runtime.unsafeRunEffect;\n/**\n * @since 1.0.0\n * @category execution\n */\nexport const runPromiseEither = _runtime.unsafeRunPromiseEitherEffect;\n/**\n * Runs an `Effect` workflow, returning a `Promise` which resolves with the\n * result of the workflow or rejects with an error.\n *\n * @since 1.0.0\n * @category execution\n */\nexport const runPromise = _runtime.unsafeRunPromiseEffect;\n/**\n * Runs an `Effect` workflow, returning a `Promise` which resolves with the\n * `Exit` value of the workflow.\n *\n * @since 1.0.0\n * @category execution\n */\nexport const runPromiseExit = _runtime.unsafeRunPromiseExitEffect;\n/**\n * @since 1.0.0\n * @category execution\n */\nexport const runSync = _runtime.unsafeRunSyncEffect;\n/**\n * @since 1.0.0\n * @category execution\n */\nexport const runSyncExit = _runtime.unsafeRunSyncExitEffect;\n/**\n * @since 1.0.0\n * @category execution\n */\nexport const runSyncEither = _runtime.unsafeRunSyncEitherEffect;\n/**\n * The inverse operation `sandbox(effect)`\n *\n * Terminates with exceptions on the `Left` side of the `Either` error, if it\n * exists. Otherwise extracts the contained `Effect< R, E, A>`\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const unsandbox = effect.unsandbox;\n/**\n * Scopes all resources acquired by `resource` to the lifetime of `use`\n * without effecting the scope of any resources acquired by `use`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const using = fiberRuntime.using;\n/**\n * Converts an option on errors into an option on values.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const unsome = fiberRuntime.unsome;\n/**\n * Updates the `FiberRef` values for the fiber running this effect using the\n * specified function.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const updateFiberRefs = effect.updateFiberRefs;\n/**\n * @since 1.0.0\n * @category runtime\n */\nexport const updateRuntimeFlags = core.updateRuntimeFlags;\n/**\n * Updates the service with the required service entry.\n *\n * @since 1.0.0\n * @category context\n */\nexport const updateService = effect.updateService;\n/**\n * Sequentially zips the this result with the specified result. Combines both\n * `Cause`s when both effects fail.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const validate = effect.validate;\n/**\n * Returns an effect that executes both this effect and the specified effect,\n * in parallel. Combines both Cause<E1>` when both effects fail.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const validatePar = circular.validatePar;\n/**\n * Feeds elements of type `A` to `f` and accumulates all errors in error\n * channel or successes in success channel.\n *\n * This combinator is lossy meaning that if there are errors all successes\n * will be lost. To retain all information please use `partition`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const validateAll = effect.validateAll;\n/**\n * Feeds elements of type `A` to `f `and accumulates, in parallel, all errors\n * in error channel or successes in success channel.\n *\n * This combinator is lossy meaning that if there are errors all successes\n * will be lost. To retain all information please use [[partitionPar]].\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const validateAllPar = fiberRuntime.validateAllPar;\n/**\n * Feeds elements of type `A` to `f` and accumulates all errors, discarding\n * the successes.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const validateAllDiscard = effect.validateAllDiscard;\n/**\n * Feeds elements of type `A` to `f` in parallel and accumulates all errors,\n * discarding the successes.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const validateAllParDiscard = fiberRuntime.validateAllParDiscard;\n/**\n * Feeds elements of type `A` to `f` until it succeeds. Returns first success\n * or the accumulation of all errors.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const validateFirst = effect.validateFirst;\n/**\n * Feeds elements of type `A` to `f` until it succeeds. Returns first success\n * or the accumulation of all errors.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const validateFirstPar = fiberRuntime.validateFirstPar;\n/**\n * Sequentially zips this effect with the specified effect using the specified\n * combiner function. Combines the causes in case both effect fail.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const validateWith = effect.validateWith;\n/**\n * Returns an effect that executes both this effect and the specified effect,\n * in parallel, combining their results with the specified `f` function. If\n * both sides fail, then the cause will be combined.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const validateWithPar = circular.validateWithPar;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const whileLoop = core.whileLoop;\n/**\n * The moral equivalent of `if (p) exp`.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const when = effect.when;\n/**\n * Runs an effect when the supplied partial function matches for the given\n * value, otherwise does nothing.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const whenCase = effect.whenCase;\n/**\n * Runs an effect when the supplied partial function matches for the given\n * value, otherwise does nothing.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const whenCaseEffect = effect.whenCaseEffect;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const whenEffect = core.whenEffect;\n/**\n * Executes this workflow when value of the specified `FiberRef` satisfies the\n * predicate.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const whenFiberRef = effect.whenFiberRef;\n/**\n * Executes this workflow when the value of the `Ref` satisfies the predicate.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const whenRef = effect.whenRef;\n/**\n * Executes the specified workflow with the specified implementation of the\n * clock service.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const withClock = defaultServices.withClock;\n/**\n * Sets the implementation of the clock service to the specified value and\n * restores it to its original value when the scope is closed.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const withClockScoped = fiberRuntime.withClockScoped;\n/**\n * Executes the specified workflow with the specified configuration provider.\n *\n * @since 1.0.0\n * @category config\n */\nexport const withConfigProvider = defaultServices.withConfigProvider;\n/**\n * Sets the configuration provider to the specified value and restores it to its original value\n * when the scope is closed.\n *\n * @since 1.0.0\n * @category config\n */\nexport const withConfigProviderScoped = fiberRuntime.withConfigProviderScoped;\n/**\n * Returns a new scoped workflow that returns the result of this workflow as\n * well as a finalizer that can be run to close the scope of this workflow.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const withEarlyRelease = fiberRuntime.withEarlyRelease;\n/**\n * @since 1.0.0\n * @category mutations\n */\nexport const withMetric = effect.withMetric;\n/**\n * @since 1.0.0\n * @category concurrency\n */\nexport const withParallelism = core.withParallelism;\n/**\n * Runs the specified effect with an unbounded maximum number of fibers for\n * parallel operations.\n *\n * @since 1.0.0\n * @category aspects\n */\nexport const withParallelismUnbounded = core.withParallelismUnbounded;\n/**\n * @since 1.0.0\n * @category runtime\n */\nexport const withRuntimeFlags = core.withRuntimeFlags;\n/**\n * @since 1.0.0\n * @category runtime\n */\nexport const withRuntimeFlagsScoped = fiberRuntime.withRuntimeFlagsScoped;\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const yieldNow = core.yieldNow;\n/**\n * @since 1.0.0\n * @category products\n */\nexport const zip = core.zip;\n/**\n * @since 1.0.0\n * @category products\n */\nexport const zipLeft = core.zipLeft;\n/**\n * @since 1.0.0\n * @category products\n */\nexport const zipRight = core.zipRight;\n/**\n * @since 1.0.0\n * @category products\n */\nexport const zipWith = core.zipWith;\n/**\n * Zips this effect and that effect in parallel.\n *\n * @since 1.0.0\n * @category zipping\n */\nexport const zipPar = circular.zipPar;\n/**\n * Returns an effect that executes both this effect and the specified effect,\n * in parallel, returning result of that effect. If either side fails,\n * then the other side will be interrupted.\n *\n * @since 1.0.0\n * @category zipping\n */\nexport const zipParLeft = circular.zipParLeft;\n/**\n * Returns an effect that executes both this effect and the specified effect,\n * in parallel, returning result of the provided effect. If either side fails,\n * then the other side will be interrupted.\n *\n * @since 1.0.0\n * @category zipping\n */\nexport const zipParRight = circular.zipParRight;\n/**\n * Sequentially zips this effect with the specified effect using the\n * specified combiner function.\n *\n * @since 1.0.0\n * @category zipping\n */\nexport const zipWithPar = circular.zipWithPar;\n/**\n * Schedules a potentially blocking effect to occur with background priority.\n *\n * Note: this is equivalent to pipe(yieldNow(\"background\"), zipRight(self))\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const blocking = effect.blocking;\n//# sourceMappingURL=Effect.mjs.map","import * as internal from \"@effect/io/internal_effect_untraced/configProvider\";\n/**\n * @since 1.0.0\n * @category symbols\n */\nexport const ConfigProviderTypeId = internal.ConfigProviderTypeId;\n/**\n * @since 1.0.0\n * @category symbols\n */\nexport const FlatConfigProviderTypeId = internal.FlatConfigProviderTypeId;\n/**\n * The service tag for `ConfigProvider`.\n *\n * @since 1.0.0\n * @category context\n */\nexport const Tag = internal.configProviderTag;\n/**\n * Creates a new config provider.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const make = internal.make;\n/**\n * Creates a new flat config provider.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const makeFlat = internal.makeFlat;\n/**\n * A config provider that loads configuration from context variables,\n * using the default System service.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const fromEnv = internal.fromEnv;\n/**\n * Constructs a new `ConfigProvider` from a key/value (flat) provider, where\n * nesting is embedded into the string keys.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const fromFlat = internal.fromFlat;\n/**\n * Constructs a ConfigProvider using a map and the specified delimiter string,\n * which determines how to split the keys in the map into path segments.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const fromMap = internal.fromMap;\n/**\n * Returns a new config provider that will automatically convert all property\n * names to constant case. This can be utilized to adapt the names of\n * configuration properties from the default naming convention of camel case\n * to the naming convention of a config provider.\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const constantCase = internal.constantCase;\n/**\n * Returns a new config provider that will automatically tranform all path\n * configuration names with the specified function. This can be utilized to\n * adapt the names of configuration properties from one naming convention to\n * another.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const contramapPath = internal.contramapPath;\n/**\n * Returns a new config provider that will automatically convert all property\n * names to kebab case. This can be utilized to adapt the names of\n * configuration properties from the default naming convention of camel case\n * to the naming convention of a config provider.\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const kebabCase = internal.kebabCase;\n/**\n * Returns a new config provider that will automatically convert all property\n * names to lower case. This can be utilized to adapt the names of\n * configuration properties from the default naming convention of camel case\n * to the naming convention of a config provider.\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const lowerCase = internal.lowerCase;\n/**\n * Returns a new config provider that will automatically nest all\n * configuration under the specified property name. This can be utilized to\n * aggregate separate configuration sources that are all required to load a\n * single configuration value.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const nested = internal.nested;\n/**\n * Returns a new config provider that preferentially loads configuration data\n * from this one, but which will fall back to the specified alternate provider\n * if there are any issues loading the configuration from this provider.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const orElse = internal.orElse;\n/**\n * Returns a new config provider that will automatically un-nest all\n * configuration under the specified property name. This can be utilized to\n * de-aggregate separate configuration sources that are all required to load a\n * single configuration value.\n *\n * @since 1.0.0\n * @category mutations\n */\nexport const unnested = internal.unnested;\n/**\n * Returns a new config provider that will automatically convert all property\n * names to upper case. This can be utilized to adapt the names of\n * configuration properties from the default naming convention of camel case\n * to the naming convention of a config provider.\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const snakeCase = internal.snakeCase;\n/**\n * Returns a new config provider that will automatically convert all property\n * names to upper case. This can be utilized to adapt the names of\n * configuration properties from the default naming convention of camel case\n * to the naming convention of a config provider.\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const upperCase = internal.upperCase;\n/**\n * Returns a new config provider that transforms the config provider with the\n * specified function within the specified path.\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const within = internal.within;\n//# sourceMappingURL=Provider.mjs.map","import * as tsplus_module_1 from \"@effect/io/Config\";\nimport * as tsplus_module_2 from \"actions-upload-to-gist/_common\";\nimport * as tsplus_module_3 from \"@effect/io/Layer\";\nimport * as tsplus_module_4 from \"@effect/io/Effect\";\nimport * as tsplus_module_5 from \"@fp-ts/core/Option\";\nimport * as tsplus_module_6 from \"@effect/io/Exit\";\nimport * as tsplus_module_7 from \"@effect/io/Cause\";\nimport * as tsplus_module_8 from \"@effect/io/Config/Provider\";\nimport * as Dotenv from \"dotenv\";\nDotenv.config();\nconst GitLive = tsplus_module_2.Git.makeLayer({\n    userName: tsplus_module_1.string(\"github_actor\"),\n    userEmail: tsplus_module_1.map(tsplus_module_1.string(\"github_actor\"), (_) => `${_}@users.noreply.github.com`),\n    git: tsplus_module_1.succeed({}),\n});\nconst GithubLive = tsplus_module_2.Github.makeLayer(tsplus_module_1.nested(tsplus_module_1.struct({\n    token: tsplus_module_1.secret(\"token\"),\n}), \"input\"));\nconst GistLive = tsplus_module_3.provide(tsplus_module_2.Gist.GistLive)((tsplus_module_3.merge(GithubLive)(GitLive)));\nconst program = tsplus_module_4.flatMap(tsplus_module_4.service(tsplus_module_2.Gist.Gist), gist => tsplus_module_4.flatMap(tsplus_module_4.config(tsplus_module_1.nested(tsplus_module_1.struct({\n    name: tsplus_module_1.optional(tsplus_module_1.string(\"name\")),\n    path: tsplus_module_1.string(\"path\"),\n}), \"input\")), ({ name, path }) => tsplus_module_4.flatMap(gist.createAndAdd(path, tsplus_module_5.getOrUndefined(name)), info => tsplus_module_4.map(tsplus_module_4.logInfo(`Created gist: ${info.html_url}`), () => void 0))));\ntsplus_module_4.runCallback(tsplus_module_4.withConfigProvider(tsplus_module_4.provideLayer(program, GistLive), tsplus_module_8.upperCase(tsplus_module_8.fromEnv())), (exit) => {\n    if (tsplus_module_6.isFailure(exit)) {\n        console.log(tsplus_module_7.squash(exit.cause));\n    }\n});\n//# sourceMappingURL=main.js.map"],"names":[],"sourceRoot":""}